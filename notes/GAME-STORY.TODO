Todos:

    ☐ 10/05/2025 : QUEST - la quete d'Eliegor peut être bloquée à la dernière étape "l'arrosage".
        => ça fonctionne généralement avec un rockgolem instancié via l'editeur, les graines doivent être ramassées pendant la quête.
        => avoir ces graines dans l'inventaire avant d'accepter la quête ne fonctionne pas. Mais ce n'est pas le problème avec l'arrosage.





    ☐ 30/03/2023 : voir pour generer des actors dans le monde avec des tasks/activités (chasseur, batisseur, agriculteur, alchimiste, commercant, voleur, assassin par exemple)
        => ce qui pourra ensuite faire de bon interacteur pour une generation aleatoire de quete (comme DaggerFall)
        ==> pas mal de costumes à faire
        => 30/05/2023 : il faudrait un character builder pour vérifier les costumes sur un scml : verifier les fonctions permettant le characterMapping -> GameHelpers::SetEquipmentList, EquipmentList, et GOT::PreLoadObjects
        ==> il prendrait le scml et permettrait de charger un costume (character mapping) ainsi que la mise en couleur des differents sprites.
        ==> probleme avec les yeux et les bouches : pour un meme sprite soit on cree differentes versions de sprite pour le position sur chaque tete (ca va alourdir les textures) soit on cree un fichier pour chaque tete contenant les positions d'origine pour chaque sprite.
        ===> l'ajout de la couleur pour chaque sprite et de l'offset d'origine par rapport au parent peut être réalisé en ajoutant à Urho3D::Spriter::Ref (Color color_; float x_,y_,angle_;)
        ===> réaliser des fonctions SaveXML pour chaque data de Urho3D::Spriter pour permettre la sauvegarde d'une entité Spriter.
        ====> 02/06/2023 : implementation OK dans Urho3D::AnimationSet2D et Urho3D::Spriter
        ===> ajouter des fonctions permettant la modification et le rendu des couleurs et des offsets positions
        ====> ok pour les premiers essais avec la couleur (cf PerformTest_SaveAnimationSet()) : la couleur d'un ou plusieurs sprites est liée à l'entité.
            Si l'on veut la meme entité avec une couleur de peau differente par exemple, il faut dupliquer l'entité et utiliser AnimationSet2D::SetEntityObjectRefAttr.
        ====> plutot lier la couleur et l'offset au charactermapping. et ainsi créer des charactermapping pour les differentes couleurs de peau et les differentes positions pour les yeux et bouches en fonction des tetes.
        ====> il faudrait créer des nouvelles données dans le charactermapping : replacementColor_, linkageOffset_ (un sprite (tete...) pourra ajouter des liens avec d'autre sprites (oeil,bouche...), ces sprites seront alors offseté de la valeur indiquée)

    ☐ 18/12/2020 : Mise en place d'Acteurs dans le World2D.
        => commencer par le Marchand, lui ajouter aussi des missions.
        ==> ajouter aussi aux missions des textes d'introduction / histoires ...
        ===> ajouter un journal de quetes : il doit indiquer les quetes terminées, en cours. Pour toutes les quetes, affichage du contexte, acteur ayant donné la quete, localisation sur la carte, résumé de taches finies.
        ===> une quete rassemble de nombreuses missions dans un contexte (scenarios/textes) et une temporalité clairement définie.
        ====> commencer par une quete lineaire.
        ====> puis extrapoler avec des quetes à embranchement.
        ==> reprendre Mission et MissionManager, MissionGenerator.
        ===> il faut développer les objectifs de mission PROTECTOR, EXPLORER, CREATOR ... cf GameGoal.h
        ====> pour les objectifs PROTECTOR, EXPLORER il faut associer un actorid et une worldposition.
        ====> le mPoint est soit predefini, soit généré en fonction de la difficulté de la mission (ecart entre map de depart et mPoint de destination)
        ====> la validation de ce mPoint et la definition de la position n'intervient que lorsque la map est générée et que les conditions sont reunies (ex : Dungeon, GOT_Start). Si les conditions ne sont pas respectees, trouver un mPoint au voisinage.
        => Exemple de Quete Simple :
        ==> Donneur de Quete "Ernest"
        ===> Trouver les Quetes Accessibles (en fonction des quetes pre-requis réalisés, des niveaux de quetes necessaires ?)
        ===> choisir une quete correspondant au niveau (voir au niveau inferieur)
        ====> Affichage du dialogue d'introduction de la quete
            " Ernest : Veux-tu que je te parle des Golem de Pierre vivants dans la region ?"
            " Golem de Pierre => Ce sont d'imposants geants issus de la première ère de notre monde, engendrés par les restes de la magie primordiale et de la Terre Mère."
            " J'ai entendu dire que si l'on plantait une graine d'Eliegor sur sa tete alors, ce géant se lierait pour toujours à son donateur ! "
            " Mais biensur ce n'est qu'une histoire ancienne ... enfin si tu es assez teméraire peut-être que tu serais interessé par cette graine."
            " Graine d'Eliegor => Cette semence provient d'une fleur d'un rouge violacé intense, que l'on trouve généralement au sommet de certaines montagnes."
            " Veux-tu partir en quete du Golem D'Eliegor ?"
        =====> Cette quete est composé de deux objectifs : EXPLORER pour trouver la graine d'Eliegor, CREATOR pour creer le golem d'Eliegor à partir des ingredients (Golem, Graine D'Eliegor) et des outils Pelle et Arrosoir.
        =====> chaque texte de quete pourrait contenir des mots clé permettant d'avoir acces à d'autre dialogue ?
        ======> 20/12/2021 : Ajout de UIC_JournalPanel, JournalData et modification de Mission, MissionManager ...
        =======> il faut remplir journal_fr.xml avec les données de quetes (Texte de journal et ObjectiveData)
        =======> pour la quete du golem d'Eliegor : il faut creer un filet pour attrapper la graine, ainsi que la pelle et l'arrosoir qui seront à utiliser sur la tete du golem avec la graine.
        ======> 11/04/2022 : reprise de la creation de contenu : ajouter l'objet Pelle, pouvoir l'equiper, et pouvoir interagir avec le rockgolem.
        =======> pour l'objectif CREATOR : utiliser les recipes du craft, Modification de Objective::Update.
        =======> quand la quete est complete => ajouter une animation de floraison au RockGolem, le changer de faction et débloquer l'avatar rockgolem.
        ========> modification des Reward à faire : une recompense peut aussi être une nouvelle capacité débloquée, un nouvel avatar, une nouvelle quete ... ajouter des nouvelles category COT::ABILITY, COT::AVATAR, COT::QUEST
        =========> completer le code de UIC_JournalPanel::OnMissionUpdated() en s'inspirant de UIC_MissionPanel::Update()
        ========> mettre l'AnimatedSprite2D Entity RockGolem + l'AnimatedSprite2D Entity flore dans le node avatar.
        =========> plusieurs AnimatedSprite2D dans le node root pose probleme au GameHelpers::CopyAttributes() => modification à faire
        ==========> 16/04/2022 : creer des nodes fils pour la flore evite d'avoir à toucher à CopyAttributes. Petite Modification pour le changement de layer dans GOC_Destroyer::SetViewZ.
        =========> OK 21/04/2022 : serialization du journal => Mission::SaveXML() fait => RAF Mission::Save() et Mission::Load()
        ==========> la quete fonctionne correctement dans les grandes lignes : il faut maintenant l'étoffer.
        ===========> OK : 1. utilisation du filet pour attraper la graine : attribut "Catchers" ajouter à GOC_Collectable
        ===========> 2. utilisation de la pelle sur la tete du rockgolem pour planter la graine : ajouter un trigger avec déclenchement conditionnel : etoffer GOC_Detector
        ============> ajout de bool GOC_Detector::attackDetector_ attribute "Attack Only".
        =============> preferer analyser la collision dans GOC_Collide2D lorsque la shape body est un trigger avec un CollisionMask=CM_DETECTOR.
            ce qui permet d'enregistrer la collision pour analyse ulterieure avec MissionManager. Il faut juste s'assurer que les players ont bien leur collisionShape attack avec ce CM
        ==============> ajout dans Player::UpdateComponents()
        ===========> 3. utilisation de l'arrosoir sur la tete du rockgolem pour faire pousser la plante : de meme.
        ==========> 06/05/2022 : OK ajout de ObjectiveCommand, ObjectiveCommandData permettant dans un objectif de mission de soit tester une condition, soit realiser une action.
        ===========> ObjectiveCondition::Check et ObjectiveAction::Execute
        ==========> pouvoir ajouter/invoquer des followers (comme le skeleton et eliegorgolem) => ajouter la category COT::FOLLOWERS.
        ===========> reajout de GOB_Follow::Stop()
        ====> la serialization des quetes en cours à faire, notamment il faut sauvegarder les Varslot des missions.
        =====> 10/05/2022 : OK correctif dans Map::SetEntities_Load() : controller->SetMainController() doit etre fait avant le SendEvent(WORLD_ENTITYCREATE), pour permettre
            à GOC_Destroyer d'envoyer GO_APPEAR vers GOManager::HandleGOAppear() avec le bon maincontrol.
        =====> 10/05/2022 : OK correctif dans Mission::LoadXML() pour bien setter les MissionData, ObjectiveData et les ObjectiveVars.
        =====> en mode Arena, à la mort de l'avatar, le jeu est sauvegardé mais sans l'entité RockGolem qui avait était ajouté et devenu EliegorGolem suite à la quete ...
        ======> la sauvegarde automatique à la mort de l'avatar ne sauvegarde pas les entités alliés ?
        =====> 15/05/2022 : lorsque l'on realise la quete en arena : eliegorgolem spawn et il est bloquer dans un decors ...
        =====> 15/05/2022 : lorsque l'on realise la quete en arena et que l'on tue eliegorgolem, la partie devrait etre gagnée.
        =====> 15/05/2022 : la fenetre de dialogue du journal n'est pas bien dimensionnée, lorsque la fenetre du jeu au lancement est superieure a 1920x1080 ... il doit y avoir redimensionnement de la fenetre de dialogue.
        ======> voir Player::ResizeUI()
        =======> OK : utilisation de UI::SetScale() dans Game::HandleWindowResize -> GameStatus::ResetScreen() ald homemade GameStatus::SetUIScale()
        ========> implique des légères modifications dans Urho3D::UI et Urho3D::Input
        ========> correctif dans GameHelpers::OrthoWorldToScreen.
        ========> utilisation de GameHelpers::GetInputPosition() ald GameStatus::cursor_->GetPosition() : la position du cursor devait être corrigé du facteur GameStatus::uiScale_
        =======> mettre en option l'utilisation de UI::SetScale() car il ne s'agit pas d'une solution permettant d'obtenir un pixel perfect pour l'ui.
        =======> il faudrait un mix entre les deux solutions : rescale du framing

        => pour le mode histoire "prédéfinie" ajouter la liste json de actors comprenant les infos id, type, position etc...
        ==> charger la liste à l'initialisation. Les avatar des actors sont instanciés au moment du chargement de la map associée.
        ==> cf PlayState::InitLevel() et World2D::SaveWorld()
        ===> 07/03/2021 : World2D::UpdateActors et Ajout d'ActorInfo dans Actor
        ====> 09/03/2021 : lors du SaveWorld, sauvegarde des Actors dans une nouvelle liste json en mode normal ou bien dans la liste initiale en mode Editor (faire un backup de l'ancienne version).
        =====> 08/10/2022 : ajout de MapStorage::CopyInitialWorldFiles pour initialiser les fichiers du monde avec ceux de la distribution
        ======> permet d'avoir les actors chargés en mode histoire.

    ☐ checker la view pour le Player::HandleClic() si pas sur la meme view que l'interactor ne rien faire.


Archive:

    ✔ 

