
/** ============= **/
/** GAME GENERAL  **/
/** ============= **/

/* TODO
------

=====> IMPORTANT : 01/09/2021 par defaut le net simulateur est activé. NE PAS OUBLIER D'ACTIVER dans slikenet/include/defines.h la ligne #Define _RETAIL pour desactiver le NetSimulator en version Publique.

=> 13/08/2025 : desactivation/invisible de la qualité des textures dans le menu Options - cf 09/11/2022

=> 12/08/2025 : meilleure intégration de Wayland - simulation du changement de mode video. Wayland ne permet pas de changer de resolution d'écran (mode set) directement via l'application comme X11 pour une question de sécurité.
A priori cela doit être possible en demandant à l'environnement ... cela rend l'affaire complexe car dépendant de l'environnement linux à priori.

=> 21/02/2023 : partitionnement de l'implementation en une libraire FromBonesLib (source dans app/main/cpp) et un Launcher Game (source dans app/main/cpplauncher) pour permettre l'ajout de l'editeur en librairie dynamique
==> pas mal de modification make, bake et sources
===> pour le moment que pour linux
===> GameStatics devient GameContext.
===> ajout de DefsCore.h ajoutant FROMBONES_API pour l'export librairie des classes.
===> pour le moment que certaines classe sont taggés FROMBONES_API.
===> l'installation des libraries se fait ./lib/vk ou gl et utilisation de LD_LIBRARY_PATH dans script de lancement : voir pour l'installation via cmake.

=> 11/11/2022 : compilation pour Android (sous Ubuntu 22.04)
==> correctif pour Vulkan empechant la compilation. VkImage, VkImageView en 32bits ne sont pas l'équivalent de void* donc erreur => remplacement dans GPUObject par les bons type Vk.
=> le build.gradle.kts projet n'est pas encore optimal : il faut modifier manuellement l'extendFor de configurations.debugImplementation et de configurations.releaseImplementation en fonction de l'api graphique souhaitée (soit en Gl soit en Vk).

=> 09/11/2022 : la nouvelle branche FromBones-Vulkan integre desormais RPI4 en CrossCompile
==> des modifications sont apportées dans les scripts Bake, cmake (Urho3D et SDL).
===> pour compiler pour RPI4 en cross compile sur linux : bake config build rpi4
====> pour le moment pas de port vulkan sur rpi4 => utilise lib GL (qui sous rpi4 est GLES2 : surement defini dans SDL)
===> modification de Urho3D::GetPlatform : ajout de "RaspBerry Pi4" : utiliser dans Game::Setup() ce qui permet d'utiliser l'engineConfig raspberrypi4.xml.

=> 09/11/2022 : problemes graphiques sous RPI4 du au TextureQuality du engineConfig.xml, il faut le mettre à 2. Le TextureQuality correspond au niveau de mipmap.
==> Le probleme c'est que AnimatedSprite2D gére mal le changement de TextureQuality (Contrairement au StaticSprite2D)
===> pour ne pas avoir de pb il faut definir les 2 qualités quality "low=0" quality "high=0" au meme niveau.
===> en utilisant mipmap enable="false" (peut-etre à tord) le probleme est le meme.
====> le niveau de mipmaps est different du niveau de Quality de Texture : on peut avoir different levels de mipmaps pour chaque niveau de Qualité de texture (LOW, MED, HIGH) pour assurer le LOD dans les jeux 3D (zoom, dezoom)
==> Solution 1 : supprimer l'option TextureQuality directement dans le Jeu.
==> Solution 2 : modifier Urho3D pour que le parametre de texture mimap enable="false" supprime le pb. ce qui revient à verouiller la Qualité de Texture
===>  modification de Texture::SetParameters. ajout de SetMipsToSkip(QUALITY_LOW, 0); SetMipsToSkip(QUALITY_HIGH, 0);
==> Solution 3 : trouver la solution pour AnimatedSprite2D.
===> Choix solution 1 pour FromBones : Regler la qualité de texture à 2 et ne plus en changer.
====> Verouiller l'option dans l'UI
====> dans Game::LoadGameConfig toujours regler la TextureQuality à 2. TextureQuality défini dans engineConfig.xml n'aura plus d'influence.
====> RAF : l'option de TextureQuality sera utiliser à termer pour changer ldpi, mdpi, hdpi de façon dynamique.

=> 08/04/2022 : reprise du developpement du contenu du jeu apres 2 mois sur le port de VULKAN pour URHO3D.

- 14/01/2022 : Remplacement de la build chain (reprise de celle d'Urho3D-1.71->1.8)
=> permet de compiler pour Android avec Gradle (utilise le compiler clang)
=> reprise de Urho3D1.5 modifié pour FromBones (qui est sans c++11)
==> voir pour enlever CivetWeb si non utilisé
==> build réussi pour android arm64-v8a
==> corriger les cmakes (pb avec les defines en cache)
===> pour le moment utilisation des variables env defini dans script/android
===> FromBones Android a besoin que Urhokko soit compilé en STATIC. (on pourrait le compiler en SHARED mais la lib dynamique ne permet pas l'acces aux méthodes des thirdparty d'Urho, ce qui pose pb avec FromBones)
====> dans Urhokko, régler les env dans /script/android puis executer ./script/android publishToMavenLocal
====> 1.créer nouveau projet : rake new[FromBones,../../Projets]
      2.remplacer le dossier bin,
      3.remplacer le dossier app/src/main/cpp,
      4.editer le fichier app/src/java/../MainActivity.java pour que la lib "FromBones".so soit bien charger au lancement de l'appli
      5.verifier que le dossier app/src/res soit bien remplit avec les icones de l'application aux differents dpi.
      6.verifier que les libs urho3d static .a sont bien dans les dossiers Urhokko/android/urho3d-lib/.cxx/cmake/$BUILDTYPE/$ARCHI/lib
      7.lancer ./script/android build
      8.installer sur device ./script/android installDebug
      9.fonctionne également sous android studio en lançant (important : URHO3D_HOME doit bien etre defini donc lancer ./script/android studio)
      10. pour linux, lancer ./build-linux : bonne nouvelle la build est moins volumineuse (14.9M contre 16.9M avec l'ancienne build chain)
       => ne pas oublier de compiler urho pour linux avant !
===> mise à jour de l'ancienne build chain
====> dans FromBones_master : utiliser "./bake linux android config install" pour tout construire
===> batch zipper (pour ancienne et nouvelle buildchain) creer pour l'archivage rapide (ne sauvegarde que les sources, datas, sans les build et autre intermediaires)

- 14/01/2022 : sur Android, des modifications sont à faire pour obtenir les versions de gles et permettre de pointer vers le bon rep Shader. (cf Game::Start())
==> patch rapide pour le moment
=> si besoin mettre engine-config.xml à la base de l'apk
==> ne fonctionne pas !
=> ne pas prendre en compte le sensor gyroscope dans le menu
==> OK : desactivation E_JOYSTICKAXISMOVE & E_JOYSTICKHATMOVE
=> en world, la texture des rendercolliders est mal appliquée (pourquoi en world et pas en arena ?)
===> pb de shader ? ne pas utiliser la texture (qui est une textureatlas) mais seulement un alpha noir => c ok, il s'agit du pb classique en gles avec les textureatlas malgré des resultats encourageant (fonctionne en arena ...)
====> OK : des pbs de scintillement : il s'agit d'un pb au niveau shader PS du encore à la suppression de l'interpolation. Inversion de l'ordre dans le shader => c à priori ok.
=> les furnitures enclume, tenture, pieges ne sont pas sur le bon tile (pb anchor ?), les furnitures vegetaux en interieur sont pivotés, le fil d'araignée est incliné à 45° et n'a plus de rotation dynamique.
==> les 3 problemes se produisent en HDPI, cf. Texture::dpiRatio_
===> OK : utiliser ce ratio en interne dans Sprite2D::GetDrawRectangle() uniquement.
====> voir pour aussi modifier Sprite2D::GetRectangle ?
===> sur FromBones BuildChainV2 (new build) - le pb persiste pour les furnitures (ne sont pas sur le bon tile) toujours en hdpi et aussi en mdpi.
====> comparaison entre linux et android de Map::SetFurnitures() (adb logcat -v time Urho3D:E *:S)
android...SetFurnitures : Map=0 0 ... furnitures_[0] : id=16782356 type=GOT_Porte(107529393) ... entityid=255(entry=255)     ... position=64.01 80.65 (tindex=113 tposition=129 129) ...
linux  ...SetFurnitures : Map=0 0 ... furnitures_[0] : id=16782356 type=GOT_Porte(107529393) ... entityid=0(entry=4294967295)... position=62.72 79.36 (tindex=113 tposition=-127 -127) .
=====> Verifier EntityData, MapData::AddEntityData(), MapData::UpdateEntityNode()
======> OK : probleme avec les char. il faut bien utiliser "signed char" ou "unsigned char" mais jamais simplement "char" car selon la plateforme, le resultat peut-etre signé ou non. Cela doit etre du au changement de compilateur (ninja).
=> OK : artisanat, n'affiche plus les outils comme il faut.
==> correctif dans UIC_CraftPanel::UpdateSlot. pour utiliser Slot::uisprite_.
    Attention Slot::sprite_ peut ne pas correspondre à l'entité. S'il s'agit d'un AnimatedSprite sans attribut "Sprite" alors c'est le premier sprite de la spritesheet qui sera pris par défaut.
    Dans le cas de l'enclume ou de la marmite, la spritesheet était furnituresdung01.png et le premier sprite de cette spritesheet est l'encadrement d'armoire ... Slot::Set() -> GameHelpers::GetSpriteForType()
=> OK : sur android remettre l'icone du jeu.
=> OK : Crash à cause des missions : normalement corrigé
=> OK : modifier l'UIC_StatusPanel pour que l'utilisation tactile des fleches permette toujours de voir le défilement des avatars.
=> rendre plus jolie l'exterieur, les dungeons, les sols ont besoin d'effets de lumière.
==> OK : activation RenderColliders pour le frontview cf NUMDUNGEONRENDERCOLLIDERS... et RenderCollider::CreateRenderShape
=> sur mobile c'est trop petit : changer le zoom de la camera dans MainMenu et PlayState.
==> OK : ajout rapide d'un zoom de 1.5f dans ViewManager::ResizeViewports() + MenuState::HandleScreenResized() + PlayState::HandleScreenResized
=> OK : toujours des pbs avec le grapin : grapin spawné, changement d'avatar sans cette abilité, rechangement d'avatar avec cette abilité, détachement du grpin, le physique n'est pas enlevé ou bien un autre physique est mis ...
==> etre sur que le grapin spawné ne s'accrocha si il est en cours de destruction
    (cas spawn, clic pour nouveau spawn, le premier spawn est pas encore accroché à un mur, lorsque la demande d'un nouveau spawn arrivé puis il s'accroche alors qu'nn nouveau grapin est spawné ... le premier grapin ne pourra alors plus etre decroché)
===> Ajout GOC_PhysicsGrapin::isReleasing_ et Correctif dans ABI_Grapin::Use()
=> OK : lors du changement d'avatar, ne pas activer la dernière abilité disponible. Plutot laisser active l'abilité du precedent avatar si elle existe pour le nouvel avatar. Autrement n'activez que la premiere ability native.
==> cf. ajout Equipment::SaveActiveAbility() et Equipment::SetActiveAbility(), Modification GOC_Abilities::AddAbility() et UIC_AbilityPanel::OnAbilityUpdated() => UIC_AbilityPanel::lastAbilityHash_ ne sert plus.
=> OK : les potions de soins doivent faire recuperer aussi les vies sans avoir à changer d'avatar.
==> Modification faite dans GOC_Life::ApplyAmountEnergy() => utilisation de GOC_Life::ApplyAttributes()
===> RAF : voir si ok en reseau.
=> OK : rendre independant deviceDPI_ pour l'UI (l'UI peut etre en hdpi alors que le reste en mdpi => mobile)
==> Deplacement des data UI dans Data/UI/Graphics en fonction du dpi
==> Ajout de GameStatus::gameConfig_.uiDeviceDPI_ et modification de Game::Setup().
==> OK : il faut egalement encore agrandir le screenjoystick
==> il y a aussi GameStatus::uiScale_ pour le dimensionnement des uiElement.
===> cf GameStatus::ResetScreen()
=> RAF : les stats d'equipement doivent encore poser pb. Equipment::Dump(), Player::Dump() command "dumpplayer"
===> ca à l'air d'etre bon : il faut plutot revoir les stats des equipments (armes et armures).
=> RAF : mettre en option le charactermapping pour les mobs skeleton et lizard : peut-etre que cela surcharge trop le cpu sur les configurations basses.
=> RAF : generer moins de static furnitures en configuration basse. pour verifier les drawables visibles (rendu) uniquement : utiliser la commande "render".
=> RAF : le setvisible d'une map lorsque le player entre dedans fait parfois defaut (encore).
=> RAF : des mobs coincé dans les murs (encore)
=> RAF : apres chargement d'une partie sauvegardée à partir du mainmenu, les entities Ai ne bougent pas: verifier si aimanager est démarré
=> RAF : erreur de changement d'arme entre lizard et skel (difficile à reproduire)
=> RAF : pb avec le framelimiter : ca sacade beaucoup. verifier l'engine. Sous Rpi ou Android le framelimiter est actif par defaut.

- 17/03/2021 : revoir le GamePlay
=> Arcade : premier mod à créer mode Solo sur la base pour chaque level => porte monstres tresor.
==> début du niveau : affichage de la mission
==> fin du niveau : ajout des récompenses : un trésor, ou un pnj apparait à la fin du niveau pour donner une récompense.
=> Battle : affronter et vaincre tous les personnages incarnés par joueurs en ligne ou BOT
==> commencer par le mode hors ligne (BOT) creer Plusieurs Actors avec AI performante
=> Wander : vagabonder dans le monde

===> 26/03/2021 : modification de PlayState, GOManager => ajout PlayState::CheckGameLogic(), les bot seront des GO_AI, les marchands seront des GO_AI_None.
====> ajout de GOB_PlayerCPU à modifier

- REFACTORING 1.6 : Nouvelle structure Source (dossiers) mise en place à consolider
=> repenser le découpage par dossiers (unité fonctionnelle)
=> fusionner les Defs par unités fonctionnelles (à définir)
=> voir pour créer une interface générique pour les tables de hashage (attributes, events etc ...)
=> systeme map à regagner en cohérence :
==> intégration du viewmanager
==> redécoupage objectile + séparation Data/Code + Simplification du storage des BatchInfos avec un HashMap et des clés (ViewZ/View/Material) pour l'accés aux tables des chunks TILE(id=0) DECAL(id=1)
===> 80%
==> créer terrainmap par map
==> trop de faux gestionnaire sous forme de composant Map (master component), StaticTiledObject2D (component)
=> créer une interface commune pour les Pools (trop de classe pool différente : pools de node, pool de map ...)
=> créer une interface commune pour les managers (AI, GO, World)

- 30/10/2018 : le preloading des ressources doit commencer pendant le splashState, afficher un icone de chargement
=> rendre asynchrone ce preloading
==> OK le 04/11/2018
===> Tester sur RPI, et Android
====> 05/06/2020 : sous RPI4 en KMSDRM, le chargement est en boucle infini sur l'Objet Wearable Armure_Petit => Patch dans GOT::PreLoadObjects() remplacement de la boucle for par while

*/

/* DONE
------

- 09/11/2023 : Creation CMakePresets.json qui permet de gestion des build (meme chose que mon script Bake homemade)
=> permet l'utilisation dans VSCode sans probleme.
=> creer tous les presets necessaire. Pour le moment Linux Debug et Release BackEnd GL seulement.

- 10/12/2020 : creer le chargement et la sauvegarde d'une partie en World.
=> sauvegarde du world + sauvegarde des players déjà fait + position des players dans le world.
==> intégrer dans OptionState "Charger Partie" et "Sauvegarder Partie"
==> suppression dans PlayState::CreateScene()->GameHelpers::LoadSceneXML() du chargement de la scene sauvegardée (plus necessaire, de plus certains attributs comme "Map - Add ImageLayer" ne sont pas sauvegardés et sont indispensables)
==> il faut dissocier la sauvegarde continue des maps et entities du world, de la sauvegarde demandé par le joueur.
===> purger systematiquement les fichiers Maps et Entities avant lancement d'une partie de ...Local/Levels/Worldxx,
    si le mode "Charger Partie" est utilisé alors copier les fichiers de ...Local/Save/Levels/Worldxx dans ...Local/Levels/Worldxx
====> OK le 17/12/2020

- 17/12/2020 : probleme sous Android : de nouveau des NaN positions d'après les logs ... corruption mémoire ?
=> retester avec la version datant du 11/12/2020 avant le passage sous Win10 (14/12/2020)
==> aucun pb avec la version du 11/12
===> OK : il s'agissait de 2 modifications dans Urho3D/MathDefs.h functions "Round" sans inline alors que le inline est nécessaire.

- 03/12/2020 : recompilation et deploiement pour android-23 avec Android Studio 3.4 OK
-> correctif d'un crash dans AnimationEquipment::Update() remplacement de la boucle do while ... par un while simple. pb surement avec la post incrementation.

- 12/05/2020 : Lors du basculement de fenetre (GainFocus/LostFocus), la fenetre du jeu fait freezé 1à2sec le WindowManager Ubuntu si l'option VSYNC est ON, mais pb de sacade dans FromBones si VSYNC est OFF.
=> soit voire dans Urho3D et SDL, comment s'implemente le Vsync et de trouver la cause de ce freeze
=> soit voire dans FromBones, trouver la cause de la saccade lorsque VSYNC est OFF.
==> avec VSYNC OFF et sans FrameLimiter, il n'y a plus de saccade.
==> en mode windows : utiliser VSYNC OFF et FrameLimiter=vsync avec vsync=frequence vertical du moniteur, (60Hz sur un moniteur60Hz il n'y a pas de saccade)
==> en mode fullscreen : utiliser VSYNC ON

- 05/06/2018 : Crash après mort au moment du respawn
=> pas de crash dans la version précédente du 23/04/2018
==> essai frombones du 23/04/2018 avec Urho3D du 05/06/2018 => aucun pb
===> il s'agit d'un pb dans frombones et non pas dans urho3D => analyser les écarts dans FromBones entre la derniere version ne crashant pas et la suivante
====> version du 30/05/2018 crash
====> version du 04/05/2018 ok
=====> semble etre un pb dans le code du GOC_Animator2D : chercher le code causant pb
======> bug dans le directionalAnimations du à controller_ qui est un ptr uniquement sur GOC_Controller,
=======> cause : lors du destroy avatar, les components sont modifies notamment ceux qui sont removable (ils sont supprimés) impliquant dans GameHelpers::CopyAttributes() un changement dans les composants
========> utilisation de WeakPtr, crash corrigé !
=> 13/09/2018 : encore un Crash
==> il s'agit du GOC_Destroyer::Destroy() à utiliser pour les avatars avec une tempo minimum de 0.1f, autrement crash du à l'effacement du node portant GOC_Destroyer et donc de lui-meme

- le codage avec les code touches ne permet pas d'être portable sur différents types de clavier (azerty, qwerty etc...) :
=> OK (04/08/2017) : utilisation des scncodes pour les parties critiques
==> 02/01/2020 : changement dans GOC_ControllerPlayer::UpdateLocalControls() des touches par des scancodes en prenant bien en compte le layout americain : le player 1 a les controles WSAD (qwerty)
===> changement egalement de la cartographie pour les touches camera et debug dans PlayState::HandleUpdate() et PlayState::HandleCamera() : les deplacement camera sont au niveau du pavé num.
===> RAF : changer les touches du screenjoystick et debug en mode touchenabled

- Déploiement Android 17/12/2017 :
-> correctif mineur sur les sources.
-> utilisation de la toolchain de Urho1.7 intégré à la 1.5 (pour SpaceMatch)
-> intégration des modifications utilisées dans SpaceMatch concernant Game, sPlay et sMainMenu (touch, GameHelpers::OrthoWorldToScreen)
-> ATTENTION : dans Game::Start() le PreloadRessources() doit être fait avant le ResetScreen() autrement problème d'affichage (Renderer2D) pour les ObjectPool Nodes.


*/



/** ========= **/
/** GRAPHICS  **/
/** ========= **/

/* NOTE
------

- 30/08/2022 : si l'on souhaite ajouter une nouvelle texture dans un LAYERMATERIAL, il faut mettre à jour également le shader fragment avec la bonne quantité de samplers (=> sampler2D samplers[quantité])
 et pour vulkan recompiler les shaders (bake vulkan shaders)

- 22/05/2022 : ajout #define DISABLE_SRGB dans Urho3D::Graphics.h.

- 11/07/2020 : sous Windows il faut obligatoirement activer les WorkerThreads pour eviter le lag lors du Render SortAndUpdateGeometry à chaque UpdateStep
=> ne résoud pas tout : View::UpdateGeometries() update les threadable dans le WorkQueue et les non-threables dans le main
==> Renderer2D n'est pas Threadable (Renderer2D::GetUpdateGeometryType() == UPDATE_MAIN_THREAD)
===> cf Renderer2D::UpdateGeometry() : lag lorsque trop de vertex ? profiler avec Renderer2DUpdateVertex
====> correctif dans Renderer2D::HandleBeginViewUpdate() : les vertexbuffer étaient systématiquement recréer
====> base à 10000 vertex pour les vertexbuffer de Renderer2D
=====> le probleme est maintenant dans Render::Present (cf. Graphics::EndFrame())
====> amelioration de l'update minimap => mise en async
====> l'activation de Vsync limite les lags

- 30/12/2021 : utiliser l'outil d'automatisation de creation de Textures et SpriteSheets associées necessite
-> de faire attention que les equipements mis en place dans les SCML porteurs (petit,lizard,skel) n'aient pas les memes noms que ceux exportés dans equipment.svg
-> que les textures hdpi et ldpi contenant les pngs des SCML disposent d'un fichier de config .xml avec dpiscml => exemple <dpiscml ratio="1.5" /> (pour le hdpi)
-> <dpi scale="x"/> n'est pas à utiliser dans ce cas (lorsque l'on utilise une spritesheet par resolution dpi ;
   les textures spritesheets generées par l'outil ne sont pas un simple resize du mdpi - les sprites ont des positions differentes).

*/

/* TODO
------

- 26/06/2023 : depuis un bon moment, la pluie dans certains endroits (non corrélé au Front ou innerview) apparait en pointillé, voir à du mal à apparaitre ...
=> OK : dans Urho3D::AnimatedSprite2D::UpdateSourceBatches() et ..._Custom(), il faut toujours setter vertex.z_ ou vertex.position.z_. (Car vertex.position_ est un Vector3 en GL et un Vector2 en VK) et que l'on utilise une matrix2x3 =>
    resultat vector2 en VK et un vector3 avec le z_ non attribué (NA)...

- 23/06/2023 : modification de Urho3D::Spriter::SpriterInstance::UpdateTimelineKeys pour reutiliser les TimelineKey au lieu de toujours les effacer/recreer pour les bones et les sprites egalement.
=> ajout de Urho3D::Spriter::TimelineKey::Copy()
=> Resolution des problemes avec les KEY_POOLS : il faut allouer pas mal de keys du premier coup (on ne peut pas redimensionner après coup car les pool de key sont de simple Vector<TimelineKey/> sans méthodes operator ==(const TimelineKey) pour permettre le resize du Vector ...
==> pour les allouer pour le moment ca se passe dans Spriter::SpriterData::Register() mais on pourrait faire ça directement dans FromBones. En fait le nombre de Key va dépendre du nombre d'animatedSprite dans les ObjectPool etc...
==> les KEY_POOLS semblent moins rapide que l'allocation mémoire ... bizarre => faire un profilage.

- 01/06/2023 : parfois les parties StaticSprite2D des lustres ne s'affichent pas.
=> pb avec StaticSprite2D, Drawable2D ?
=> difficilement reproductible
==> OK : Patch dans Drawable2D::GetSourceBatchesToRender(Camera* camera) : si le sourceBatch n'a pas de vertices alors sourceBatchDirty_ = true

- 12/04/2023 : Fantomette ne s'affiche plus sous GL
=> OK : pour les RenderTarget avec ACTIVE_LAYERMATERIALS, il ne faut pas appliquer de CustomMaterial dans GOT::PreLoadObjects donc eviter de mettre node->GetDerivedComponents</StaticSprite2D/>()

- 31/03/2023 : les TileEntity créés pour fermer les zones de boss ne sont pas sur le bon layer par rapport aux particules qui passe au dessus de la partie Tile et au dessous de la partie Decals.
=> OK : ajout DRAWORDER_TILEENTITY

- 31/03/2023 : le splash de la vache doit etre au dessus des autres entités.
=> OK : ajout de l'attribut "Order in Layer" value="1000"" (attribut de Drawable2D)

- 21/03/2023 : les monstres comme mirubil depassent des murs
=> voir pour appliquer un depthstencil comme pour l'eau ? entre les pieces d'une meme view ca ne donnerait pas le bon resultat.
==> il faudrait appliquer un clipping par entity en fonction de sa localisation dans une piece et de la geometrie de la piece.

- 22/02/2023 : sans Activation du clipping, certains RenderShapes avec holes posent pb : si le rendershape est adjacent à un autre rendershape alors le hole s'affiche comme si il n'etait pas integré à la rendershape
=> surement PolyShape::Sanitate et la reaffectation des holes au bon contour.
==> dans Sanitate la duplication des hole et le Test par BoundingRect n'est pas suffisant occasionnant de garder des holes hors contours (ces holes se retrouver tracer plusieurs fois pour plusieurs contours).
===> OK : 23/02/2023 : utilisation de GameHelpers::IsInsidePolygon()

- 05/02/2023 : l'ajout du clipping pour les RenderShapes dont les formes sont complexes pose probleme.
=> l'utilisation de l'algo SutherLandHodgmanClip genere des contours avec des lignes qui s'intersectent dans les cas complexes ce qui ne permet pas de generer des triangles correctes.
=> on pourrait faire un test avec Clipper en upscale les Vector2 en IntVector2
==> à terme si le test fonctionne on pourrait modifier MapColliderGenerator pour generer des contours basés sur des IntVector2 : gain en rapidité
===> la transformation en Vector2 se referait au moment de la creation des batches.
=> 13/02/2023 : OK : Test concluant avec Clipper1. A voir pour la rapidité (allocation memoire etc...)
==> il reste encore des problemes pour les holes bien visible au niveau des fenetres (holes) qui ne sont pas evidées (RenderShape BACKVIEW)
===> certains holes font crasher la triangulation (polytri) : il s'agit de holes complexes.
===> PolyShape::Sanitate() doit reattribuer les holes lorsque un contour est explosé en plusieurs contours plus simples.
====> 15/02/2023 OK : ajout de PolyShape::SplitContour, il reste encore des cas en arena en BACKVIEW avec des holes qui split le contour de façon inattendue.
=====> OK : decalage du point splitter dans le second contour créé pour eviter qu'il soit en intersection avec ce meme point splitter du premier contour.
=====> 16/02/2023 : il reste un probleme specifique dans Arena avec un hole qui ferme un contour dans ce cas il faut reduire le hole (shrink). Ce probleme n'existe pas sans clipping.
======> OK : 17/02/2023 : Ajout de PolyShape::AdjustHoles() qui se fera dans le Sanitate une seule fois (donc au moment du PolyShape::AddContour)
=======> RAF : encore des cas avec des holes en bordure de clipping qui posent probleme !
==> faire un test de rapidité sous RPI4
===> le clipping des rendershapes n'est pas obligatoire sur des configurations Desktop normalement. on ne pourrait que l'activer pour RPI.

- 30/01/2023 : sous Android, le Texture Repeat des ScrollingShape et des RenderShape ne fonctionne pas
=> voir ce qui pose pb dans les vertex.uv_ et parametre de texture. Peut-etre que l'utilisation des TextureAtlas pose pb avec le TextureRepeat
==> meme probleme que celui du 12/12/2022 : specifique à Android (n'existe pas sous RPI Legacy GLES)
- 12/12/2022 : GLES => uniquement sous Android
=> pb avec les RenderShapes : lorsque la map de depart initial n'est pas (0,0) alors les textures des rendershapes sont comme tres zoomées !
==> ce probleme n'apparait pas en GL ni Vulkan.
===> pb de precision des coordonnées de textures lors du fract(vTextCoord) dans le shader 120 ?
=> 01/02/2023 : probleme resolu dans ScrollingShape
==> il fallait reduire les coord UV pour Android qui n'accepte pas de trop grandes coord UV.
===> appliquer le meme code dans RenderShape.
====> OK il y a encore quelque pb sur certains triangles mais ca reste convenable pour le moment
=====> 13/02/2023 : ca devrait etre bon -> plus de coord negative

- 29/01/2023 : sous RPI les grandes surfaces tel que les WorldEllipses provoquent des errors de blitting.
=> voir pour faire un clipping de ces grandes surfaces à la zone visible (frustum), donc mise à jour à chaque frame !
==> cf ACTIVE_WORLDELLIPSES, World2D::Set() => ScrollingShape
===> il faut realiser un clipping de l' ellipse avec le visibleRect.
====> 1. si le visiblerect est à l'interieur de l'ellipse : alors utiliser le visibleRect et calculer les uv pour conserver le mapping de la texture.
====> 2. si le visiblerect est à l'exterieur de l'ellipse, pas besoin d'afficher le ScrollingShape
====> 3. si intersection, faire un clipping avec l'algo "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping#C++" et calculer les uv pour conserver le mapping de la texture.
====> OK 30/01/2023 : ajout de GameHelpers::ClipShape()
====> generaliser le clipping pour les RenderShapes
====> faire l'implantation pour le multiviewport

- 28/01/2023 : le skeleton affiche 3 cranes à sa mort
=> surement un pb dans le CharaterMapping suite aux modifications
==> il est important pour GOC_BodyExploder2D que lors de la PrepareNodes le characterMapping soit dejà fait.
==> OK : Modifications de GameHelpers::SetEntityVariation() pour toujours au moins avoir un charactermapping de tete attribué.

- 28/01/2023 : certains lustres ne s'affichent plus.
=> pb avec StaticSprite2D ?
==> verifier les modifications dans Urho3D sur Drawable2D et StaticSprite2D
===> OK : pb avec Drawable2D::drawRect_ qui n'était pas initialiser

- 23/01/2023 : correctif dans AnimatedSprite2D pour la mise à jour du DrawRectangle : worldBoundingBoxDirty_ n'etait pas setté à true lorsque mise à jour dans UpdateDrawRectangle ce qui ne permettait pas de mettre à jour la worldBoundingBox qui est utilisait pour la visibilité.
=> modifier AnimatedSprite2D::UpdateDrawRectangle().
==> OK : tester sur les bougies en bordure de visibilité.

- 28/06/2022 : pb de charactermapping sur les lizard ou les skeleton apres loading de map, affichage de sprites casque ou armure non conformes
=> cf Map::SetEntities_Load(), l'equipment list n'est surement pas sauvegardé.
==> voir le composant AnimatedSprite pour les attributs à sauvegarder (sprites mapping ...)
===> compliquer à mettre en place
===> pour le moment mesure compensatoire mis en place : dans Map::SetEntities_Load() ajout d'un nouveau randomize du charactermapping apres le LoadAttributes() qui a lieu dans ObjectPool::CreateChildIn().
====> 20/01/2023 : reapparition du probleme faire un comparatif de code
=====> il y a eu changement de code à partir du 04/12/2022 dans GameHelpers::SetEntityVariation()
======> correctif dans GameHelpers::SetEquipmentList : La Torche pose pb car Weapon1 et pas de SpriteList.
======> la mesure compensatoire n'est pas suffisante car node->ApplyAttributes est appliqué après le GameHelpers::SetEntityVariation().
=======> OK : déplacement de GameHelpers::SetEntityVariation() de ObjectPoolCategory::GetPoolNode() vers ObjectPool::CreateChildIn() après GameHelpers::LoadNodeAttributes
=======> pour resoudre le probleme, il faudrait sauvegarder l'equipement utilisé pour le mapping pour toutes les entités le necessitant.

- 13/01/2023 : crash avec les RenderShapes dans la map=-12,-6 en partant de la map=-15,-1
=> fastpoly2tri.h entre en boucle infinie dans MPE_FlipEdgeEvent
==> ajout d'un return
==> cela genere neamoins un rendershape qui ne va pas etre bon : il faut trouver la source du probleme sur les vertex envoyés à fastpoly.

- 16/11/2022 : VULKAN
=> Perte du contexte graphique sous Android
==> il faut recreer la surface de la fenetre lorsque la fenetre est redimensionnée ou bien lorsque pas AcquireFrame
===> OK ajout de GraphicsImpl::surfaceDirty_ et modification GraphicsImpl::AcquireFrame() et Graphics::OnWindowResized()
=> sous Android, la version VK est plus lente que la version GL.
==> voir pour les sub render pass ? et la sync ? texture ?
=> RAF Viewport
==> important pour le jeu en multiplayer local

- 09/11/2022 : trouver une solution pour GLES2 pour les fluid (android et rpi)
=> le renderpath ForwardUrho2D.xml (2 passes) ne fonctionne pas ?
==> voir pour completer les shaders 120 puis refaire un test sous rpi4

- 09/11/2022 : Suppression de la directive ACTIVE_FLUID
=> celle-ci est remplacé par GameStatus::gameConfig_.fluidEnabled_ qui est parametrable dans les Options. Par contre en PlayState, il manquera un state fluid dirty pour reinitialiser la partie graphique (le renderPath ForwardUrho2D.xml par exemple)
==> il faut s'assurer que les fluidmap sont toujours créés pour rendre utilisable les fonctions comme GameHelpers::AdjustPositionInTile ... GOC_Destroyer::Unstuck().
===> ça a l'air d'etre le cas pas de ACTIVE_FLUID dans ObjectFeatured
=> 15/09/2022 : ajouter des watercolumn pour les cascades.

- 22/05/2022 : sous Android GLES2 hdpi bug d'affichage de texture sur EliegorGolem. Il s'agit bien de la bonne texture mais pas des bons sprites
=> l'entité a plusieurs AnimatedSprites ... peut-etre c'est lié ...
==> vu egalement sous VULKAN
==> cela provient surement du setviewZ qui ne doit pas bien fonctionner lorsqu'il y a plusieurs animatedSprite pour une meme entity.
===> 30/08/2022 : ça doit être résolu, il s'agit surement du meme bug : avec les LayerMaterials, il fallait bien s'assurer que le material est bien appliqué à tous les drawables du node (et sous nodes).
===> 13/09/2022 : apparement non, rare à reproduire : les flore apparaissent bien mais pas le corps de pierre. pb de visibilité d'animatedsprite ?

=> 30/08/2022 : probleme sous vulkan avec ubuntu22.04 au niveau du layer water2d : des artefacts apparaissent => un probleme de synchro.
==> le layer water2d est sous la meme renderpass que le background qui est utilisé en attachement pour l'effet d'onde de l'eau.
===> OK : bien dissocier en 2 renderpass : correctif dans GraphicsImpl::SetRenderPath : utilisation renderPathCommandIndex_=11 (ald 10).
===> RAF : il faudrait aussi resoudre les imagelayout (pour le moment mis à VK_IMAGE_LAYOUT_GENERAL)
====> cf aussi GraphicsImpl::CreateRenderPasses et Graphics::PrepareDraw et Texture2D::SetData

- 14/06/2022 : il faut résoudre avec Vulkan, les Render Targets
=> actuellement sous OGL, lorsque l'usage d'une Urho3D::Texture est TEXTURE_RENDERTARGET alors il est créé une Urho3D::RenderSurface qui peut etre lié à un viewport
==> ce viewport est lié à une scene, une camera. Une fois la scene rendu, la texture est "resolve" avec ce rendu. (BlitFrame ?)
==> cf. View::SetRenderTargets() => Graphics::SetRenderTarget() pour les outputs (attachements vers lesquels la scene doit etre rendu)
==> cf. View::SetTextures() => Graphics::SetTexture() pour les inputs (attachements utilisé par les stages shaders)
=> sous Vulkan : il faut utiliser VkRenderPass en utilisant dans la subpass un VkFramebuffer (attachement qui contient VkImageView + VkSampler : ceux-ci provenant de la texture créée).
=> pour une texture "viewport" utilisée en input dans le renderpath courant : il faut créer un Descriptor qui pointe vers les attachements du VkFrameBuffer de la frame courante.
==> voire les subpass utilisée dans https://developer.samsung.com/galaxy-gamedev/resources/articles/renderpasses.html
==> par renderpath, créer et stocker les renderpass.
===> cela va solutionner les renderpaths avec la pass refract qui utilise en input une texture viewport.
===> mais ne solutionnera pas l'exemple 10-RenderToTexture qui utilise une scene Rtt qui va etre rendu dans une texture.
====> pour cela pour creer les renderpass pour la scene Rtt, il faudra prendre en compte la renderSurface finale en plus du renderpath associé au viewport de la Scene Rtt.
===> creer une structure comme PipelineInfo pour RenderPath pour Vulkan.
====> OK 27/06/2022 : premier essai concluant avec 2 RenderPass utilisées.
=====> RAF : il reste à finaliser GraphicsImpl::SetRenderPath car pour le moment c'est specifique pour ForwardUrho2D.

- 03/06/2022 : l'on pourrait aussi utiliser le depthwrite systematiquement en specifiant toutes les positions z de tous les elements.
 et ecrire les layers du plus proche (-z) au plus éloigné (+z) inversant le draworder.

- 13/05/2022 : Portage de Urho3D sur Android Vulkan OK
=> modification des fichiers gradle, modification mineure dans Urho3D, integration des Validation layers.
=> pour Urho3D Vulkan ajouter un dossier Source/Shaders à compiler.
==> utilisation de l'homeMade SpirvShaderPacker (à modifier pour permettre les modes quiet ou verbose)
===> generer le variation hashname du shader dans l'outil.
=> l'utilisation d'Urho3D Vulkan Directional Light CRASH l'application quelque soit l'appareil cible.
==> 14/06/2022 : remplacement dans le shader LitSolid DIRLIGHT, l'uniform LightPS doit etre mis en set3 binding0 plutot que prendre le binding3 du set0
===> il y a un pb d'attribution lorsque l'on pass en descriptor dynamic : voir ce qui ne va pas dans ConstantBuffer et Graphics::PrepareDraw

- 18/03/2022 : Portage de Urho3D sur l'API Vulkan. Test avec FromBones.
=> crash avec les pipelines lorsque le define NUMVERTEXLIGHTS est utilisé.
==> on pourrait creer une pipeline pour chaque define NUMVERTEXLIGHTS=1à4. soit 4 pipelines à multiplier encore par le nombre déjà existant de shaders.
===> pour FromBones qui utilise peu de shaders en mode ACTIVE_LAYERMATERIALS, cela pourrait aller. Mais pas pour d'autres jeux 3D.
====> choix d'utiliser d'un seul shader (pipeline) quelque soit le nombre de vertexlights : ajout de cNumVertexLights
=> des problemes avec les pipelines à corriger pour l'UI : pour force à utiliser le BlendMode Alpha, utiliser UIElement::SetOpacity(0.95f)
=> 08/04/2022 : Pas mal de correctif dans Urho3D Vulkan sur le rendering avec Lights
==> OK : les VERTEXLIGHTS fonctionnent ainsi que les PERPIXEL Lights : utilisation de Light PERPIXEL avec avatar-petit OK ! mais pas avec OpenGL (il faut alors desactiver les lights PERPIXEL - cf GameHelpers::SetLightActivation(Player*))
==> Reste pas mal de choses à faire : notamment en priorité les RenderTargets, le MultiViews, test sur android ensuite le shadowing et l'Instancing.
=> 14/04/2022 : correctif pour le mode sRGB dans Urho3D Vulkan pour eviter le Gamma Correction automatiquement fait par VULKAN en cas de difference entre le mode srgb pour les textures et la swapchain.
==> le gamma correction est utilisé pour test sur okkologo (déclaré non sRGB) ce qui permet de faire briller le logo.

- 21/12/2021 : creer un outil pour automatiser la creation des spritesheets et texturefiles dans les bons dossiers.
-> il faut exporter les sprites à partir d'inkscape en 90ppp pour chaque entité.
-> pour un ensemble d'entités, créer une texture à la bonne resolution (768x768 en ldpi ... 1024x1024 en mdpi)
-> pour chaque scml, il faut une spritesheet associée.
=> indiquer le dossier contenant les scml
=> lire les fichiers png necessaire dans chaque scml
=> charger chaque png du dossier contenant les png (chaque png doit avoir un nom unique)
==> faire un essai avec la spritesheet1 (petit, lizard, skel et equipment)
===> redimensionner petit, lizard, skel pour mettre les nodes en scale 1,1,1
===> prendre soin des pivot pour les objets equipable (armors, swords, pistolet, torche etc..) et integrer les nouveaux equipements (filet, pelle)
====> l'equipement pose probleme : il faut renommer dans les SCML avec equipement (Petit, Lizard, skel) les equipements de façon unique sans redondance avec les pngs existants
=====> l'outil TexturePacker generera des spritesheets avec les bons attributs (taille et hotspot provenant des scmls) pour ces sprite2D sans position defini dans la texture
=====> puis AnimatedSprite2D effectuera bien la mise à l'echelle des equipements vers ces sprite2D "holder".
======> il faut donc faire attention que les equipements mis en place dans les SCML porteurs (petit,lizard,skel) n'aient pas les memes noms que ceux exportés dans equipment.scml
=======> OK : le probleme c'est pour l'equipement natif des entités non-joueurs qui ont l'equipement de base des scmls.
========> Revoir les SCML pour integrer au minimum les characterMaps Armor et No_Armor si un element est présent (ex skeleton warrior)
========> Ajouter une cmap Naked dans chaque entity SCML pour cacher tous les sprites d'equipement.
========> Ajouter le code pour générer un equipement "aléatoire" sur ces entités : GameHelpers::GetRandomizedEquipment
====> à modifier le dimensionnement des renderedAnimations.
====> OK : probleme concernant les scaling des weapons reglés par la modification de Urho3D::AnimatedSprite2D::SwapSprite() et l'ajout de l'attribut pour AnimatedSprite2D "MappingScaleRatio".
=====> il s'agit du rapport entre le width du sprite weapon du scml et celui du sprite contenu dans la texture exportée (exemple pour petit 68.f / 240.f = 0.28f)
======> à utiliser pour les avatars avec equipement comme petit, lizard et skeleton.
====> OK : inclure dans TexturePacker la possibilité de spécifier un sprite à mettre en premier position dans la spritesheet : utile pour les collectables pour indiquer le sprite à prendre en compte dans Slot.
====> OK : corriger la torche (surement le scaling dans Urho3D::AnimatedSprite2D::AddRenderedAnimation etant donner que la torche n'est pas orientée comme les épées)
====> OK : les colliders des collectable parts ne sont pas bien dimensionner : le staticsprite est centré par rapport à son hotspot et le collider par rapport au centre du node.
=====> le probleme est au niveau du GetBoundindBox, il faut utiliser à la place les dimensions du sprite et de son hotspot.
====> OK : modifier la taille de la jambe de bois, du bandeau et du crochet pour la remettre à la taille native du skel ou bien utiliser les characterMaps (necessiter de modifier le SCML de skel)
=====> redimensionnement de la jambe de bois et du crochet, le reste passe en charactermapping.
=> probleme avec le marchand et son armement : la torche et l'épée de feu sont 2x trop grosse =>
==> OK : utiliser le MappingScaleRatio : modification de Urho3D::AnimatedSprite2D::AddRenderedAnimation avec ajout du scaling mappingScaleRatio_.
=> OK : les scraps des bones sont trop gros : ajout du dpiratio dans GOC_BodyExploder2D::SetExplodedNodesComponents et modification de GameHelpers::SpawnScraps
====> OK : probleme de grossissement des bones lorsqu'ils tournent : probleme lié à StaticSprite2D ?
=====> correctif dans StaticSprite2D::UpdateSourceBatches() pour bien appliquer le scale (attention à la partie rotation entremelée).
====> RAF : les ailes sur le lizard ne reagissent pas bien au changement d'animations flyup. A la mort du Lizard avec ailes, l'animation aile continue, il faut l'enlever.
====> RAF : la cape est mal positionnée sur le skel : la cape a 3 sprites : le Wearable mapping n'a pas été configuré
=> redimensionner les collectables casque, epee etc... lors du drop ils apparaissent maintenant trop petits.

- 03/12/2021 : creer une structure effects (textureFX et Color) pour chaque Sprite2D d'AnimatedSprite2D.
-> Cela va permettre d'avoir des effets (notamment UNLIT) et une couleur specifiques pour chaque sprite composant un AnimatedSprite2D.
==> modification de la structure Urho3D::Spriter::File avec ajout int fx_
===> ok simple essai avec Sorceress, animation die, le feu est bien en Unlit.
====> OK dans les scml ajouter fx="1" aux files qui doivent etre unlit.

- 26/03/2020 : etablir une nouvelle arborescence pour les graphics permettant de changer de taille de textures en fonction du device cible
=> Data/Graphics/(lpdi-mpdi...)
==> voir dans Urho3D::FileSystem() s'il existe une fonction permettant de monter le repertoire /Data/Graphics/mdpi par défaut pour que 2D/animation.scml ou bien UI/menu.xml soient bien reconnus
===> utiliser ResourceCache::AddResourceDir() dans Game::Setup()
===> ok : ajout de GameStatus::GameState.deviceDPI_ et modification de Game::Setup
====> ajout de <variable name="deviceDPI_" value ="mdpi" /> dans engine_config.xml
====> OK : ajout de Urho3D::Texture::dpiScale_ et ajout dans qui permet l'integration rapide de toutes les spritesheets sans avoir à modifier les xml, ni les scml
=====> il suffit simplement de changer l'echelle de toutes les textures et d'ajouter dans les xml de texture le parametre <dpi scale="x"/>
    pour specifier qu'il s'agit d'une texture de tel resolutiondpi (par ex: <dpi scale="0.75"/> pour specifier qu'il s'agit d'une ldpi)
=> OK le 28/03/2020
==> Urho3D::Texture::GetDpiScale() est uniquement integrer à Sprite2D.
===> RAF : il faut également l'intégrer à l'UI
====> Integration dans BorderImage::SetImageRect

- 11/03/2021 : revoir le layering car les marchands interferent avec les players qui sont equipés.
=> à priori les players multibatch interferent tous
=> voir AnimatedSprite2D.

- 02/02/2021 : Test dans BackShape2DAtlas du Shader WireFrame et Grid sur les RenderShape InnerView
=> le but étant d'ajouter un effet d'alpha progressif sur la bordure avec le mode USE_CHUNKBATCH
==> avec les coordonnées Barycentriques il ne sera pas possible de ne garder que les edges de contours
==> Les Shaders dans ce cas n'apporteront pas de solution.
===> Creation d'une shape supplementaire pour les dégradés de bordure, ajout d'Embose dans RenderShape pour generation ces shapes cf. RenderShape::AddShape et RenderCollider::CreateRenderShape
====> pour un contour de n faces cela rajoute 2 triangles par face soit 2*n triangles
====> RAF : lors de l'embose (qui correspond à un offset sur polygon), si le contour a des trous, le contour "embose" risque d'etre en intersection avec ceux-ci. ce qui aboutit a un contour degeneré.
=====> il faut soit eviter ces cas, soit lors du ScaleShape(), il faut test si intersection avec les holes et dans ce cas modifier le contour.
======> des libs tel que CGAL::Straight_skeleton_2 permettent de creer une polyligne de centre et ainsi offseter par la suite simplement.
======> integration simple de ClipperLib mais sans utilisation pour le moment
======> Pour le moment les Holes qui sont en intersection avec le contour sont supprimés.
======> RAF : 12/02/2021 : une fois le SanitateContour effectué, le seul cas qui pose probleme c'est les Holes Adjacents (1 point commun avec le contour).
    Les Holes doivent etre ouverts et integrés au contour afin de permettre le shrink du contour et la creation des degradés de bordure
=======> La detection des intersections entre Contour et Hole ne semble pas fonctionner (trouve des intersections en testant un contour de 3x3 tile avec 1 hole sur le tile central).
========> remplacer FindIntersections() par un FindIntersections_HV() qui doit tester uniquement les segments horizontaux avec les segments verticaux.
=========> 24/02/2021 : OK.
=========> RAF : ouverture des contours shrinked avec les holes en intersection
====> cas des bordures de map : ne pas ajouter d'effet de dégradé si la map est connecté et que le tile voisin est plein
=====> 23/02/2021 : dégradés satisfaisants sur les bordures de map connectées.
====> RAF : trouver pourquoi dans certains cas, lors de la modification de contour (SetTile), les holes disparaissent alors qu'ils devraient etre la.
=====> peut-etre si split contour, les holes ne sont pas bien reaffecter au bon contour ? (cf SanitateShape)

- 10/12/2020 : au chargement d'entities qui ont un StaticSprite2D => Map::SetEntities_Load(), il faut faire un Drawable2D::ForceUpdateBatches
=> voir si dans la sauvegarde l'entity est Enabled ou non. voir l'interaction avec StaticSprite2D. pb de Draw Rectangle. Surement suite aux modifications apportées à Urho2D dans StaticSprite2D.
==> verifier les modifications faites à Drawable2D, StaticSprite2D et AnimatedSprite2D
    => Description de la phase UpdateSourceBatches
        => Renderer2D::HandleBeginViewUpdate()
            => Threaded WorkQueue => CheckDrawableVisibility()
                => Drawable::GetWorldBoundingBox2D() ====specifique===> StaticSprite2D::GetWorldBoundingBox2D
                => if (worldBoundingBoxDirty_)
                    => Drawable2D->StaticSprite2D::OnWorldBoundingBoxUpdate()
                        => Drawable2D::GetSourceBatchesToRender()
                            => Drawable2D::UpdateSourceBatchesToRender()

<Multiviews>
- 01/11/2020 : voir pour ajouter le MultipleViewports en mode 2-4 joueurs
=> cf Urho3D::Sample::MultipleViewports
==> pouvoir choisir le mode de jeu en multiviews ou bien sur une seule view (dans ce cas il faudra modifier de toute façon le code pour que les joueurs locaux restent dans la seule vue : mettre un collisionbox sur l'ecran limitant uniquement les joueurs locaux ? ce qui va limiter les chutes et les sauts)
===> 03/11/2020 : ajout de GameConfig::multiviews_ et utilisation dans PlayState::SetViewports()
==> définir un Viewport et une camera pour player. voir pour la possibilité de split/regroupement de viewport en cas d'éloignement/rapprochement des joueurs.
==> 03/11/2020 : ajout de la gestion de Viewports dans ViewManager : ajout de ViewportInfo, ViewManager::SetViewportLayout(), ViewManager::ResizeViewports()
    et grosse modification pour la gestion multiviewport notamment modification de Urho3D::Renderer2D et Urho3D::AnimatedSprite2D (suppression de Renderer2D:IsDrawableVisible)
==> A modifier ObjectTiled, DrawableScroller, World2D, GEF_Rain, GameHelpers::OrthoWorldToScreen, GameHelpers::ScreenToWorld2D
==> les Batches generés par les drawables tel que ObjectTiled et DrawableScroller devront tenir compte de chaque Viewport
===> World2D, WeatherManager devront pouvoir gerer les differents Viewports.
====> le pb va venir aussi de Urho3D::Renderer2D::GetFrustumBoundingBox et World2D::GetVisibleRect() utilisé notamment dans ObjectTiled::GetWorldBoundingBox2D() et de l'utilisation de l'unique Camera GameStatus::camera_
====> World2D::GetVisibleRect() va etre utilisé aussi par MapCreator::Update et GEF_Scrolling
====> le visibleRect va être updaté par World2D::UpdateStep qui se base sur la camera World2D::camera_
====> pour le moment WeatherManager est lié à GameStatus::cameraNode_
=> pour World2D, à chaque Update prendre la camera de chaque viewport en compte.
==> modifier World2D::UpdateVisibleCollideBorder() : les visiblerect sont à tester pour verifier si intersection => si intersection, regrouper les collisionshape en collision en une seule.
==> World2D::UpdateInstant() utilisé dans le changement de position de camera (teleportation) est délicat
===> il convient de differencier dans le process amont (World2D::UpdateVisibleLists(), World2D::mapsToShow_, World2D::mapsToHide_) les differents viewport en gardant à l'esprit qu'une carte visible peut être
    visible par plusieurs viewport et aussi pas à tous (il ne faut donc pas la caché dans ce cas). UpdateInstant sera a utilisé pour un ensemble de viewports pas forcément tous (cas de 2 joueurs qui se téléportent mais pas le troisième).
====> World2D::mapsToShow_, World2D::mapsToHide_ sont à mettre dans WorldViewInfo
==> pb en boucle: erreur dans la definition du worldVisibleRect
    [Sat Nov  7 10:07:16 2020] ERROR: GEF_Rain() - HandleUpdate() : worldVisibleRect is in Full BackGround => rain paused !
    [Sat Nov  7 10:07:16 2020] ERROR: GEF_Rain() - HandleUpdate() : worldVisibleRect is not in Full BackGround => rain resumed !
==> verifier dans ObjectTiled, l'attribution et l'utilisation de visibleRect_ et de chunkGroup_, notamment dans ObjectTiled::GetWorldBoundingBox2D() et ObjectTiled::UpdateChunksVisiblity()
===> les informations comme ObjectTiled::indexViewZ_, ObjectTiled::viewZ_, ObjectTiled::chunkGroup_ ... sont à lier à un viewport.
===> 11/11/2020 : OK grosse modification dans ObjectTiled rendant indépendants les sourcebatches.
====> sur viewport > 0, pb de changement de viewz sur les maps voisines de la map courante
=====> 12/11/2020 : correctif dans ViewManager::SwitchToViewIndex : le viewport doit etre celui du node player autrement les ViewManager::viewportInfos_ (notamment viewZindex_) ne sont pas updatées pour le bon viewport.
==> Desactivation de GameHelpers::ApplyLuminosity()
==> 14/11/2020 : Modification de DrawableScroller pour le multiviews
==> 16/11/2020 : Modification de WeatherManager, GEF_Scrolling et GEF_Rain pour le multiviews
===> OK changement des viewmasks inside et outside en multiviews pour les effets Weather (rain et cloud) cf VIEWPORTSCROLLER_INSIDE_MASK et VIEWPORTSCROLLER_OUTSIDE_MASK
===> lorsque les players sont dans la meme zone (visible rects en intersection), il faut que les effets soient les memes : voir pour synchroniser les effets.
====> 16/11/2020 : OK modification WeatherManager::Update() et GEF_Rain.
===> 16/11/2020 : OK Modification de GOC_Portal.
===> 17/11/2020 : OK GameHelpers::OrthoWorldToScreen, GameHelpers::ScreenToWorld2D
===> 17/11/2020 : Correctif des ViewMask des Lights dans GameHelpers::SetLightActivation(Node* node) et GOC_Destroyer::SetViewZ()
===> 17/11/2020 : Modification de la position des panels pour le multiview dans Player::ResizeUI()
===> 18/11/2020 : OK : appliquer le viewmask du viewport au DialogueFrame du Marchand : modifications dans Player::HandleClic(), Actor::SetEnableDialogue() et dans DialogueFrame::SetFrameLayer()
===> 19/11/2020 : OK voir pour World2D::UpdateInstant() pourquoi forcer viewport=0 => cela semble ralentir le chargement initial ... peut-etre à cause de l'updateStep qui rajoute des cartes à créer ? pb de viewRect ?
 le probleme venait de ViewManager::AddFocus qui utilisait World2D::UpdateInstant et dans la boucle initiale PlayState::SetViewports() cela posait pb car UpdateInstant utilise World2D::UpdateStep qui met à jour pour tous les viewports.
 Lors du premier UpdateInstant (viewport=0), World2D::UpdateStep ajoutait des Map 0,0 ; 0,1 ... pour les viewports suivants (les positions de camera sur ces viewports n'etant alors pas encore définies). => Suppression de UpdateInstant du AddFocus.
===> 18/11/2020 : il peut encore arriver que dans un viewport, le changement de viewZ pour une map ne soit pas bien effectué
====> il faut pouvoir faire la visibilité des ObjectTiled par viewport et non sur l'ensemble des viewports à chaque fois dans Map::SetVisibleTiles()
=====> ne pas utiliser ObjectTiled::SetCurrentViewZ() dans le Map::SetVisibleTiles() mais faire plutot un check du viewZ dans le ObjectTiled::GetWorldBoundingBox2D()
======> 19/11/2020 : OK suppression du code dans Map::SetVisibleTiles() et integration dans ObjectTiled::GetWorldBoundingBox2D().
===> 20/11/2020 : OK Patch dans GOC_Portal pour les entities mounted et en multiviews.
===> le SwitchViewZ ne fonctionne pas pour les player CPU en multiviews
====> 20/11/2020 : OK modification de GOC_Destroyer::SetViewZ() et ViewManager::SwitchToViewIndex()
===> en multiviews, en selectionnant dans le MainMenu 2 joueurs avec le second en temps que CPU, l'affichage sur le second viewport ne se fera pas
====> 21/11/2020 : OK modification de PlayState::SetViewports()
===> RAF : voir pour modifier ObjectMaped::HandleChangeViewIndex() qui est pour un seul viewport
===> RAF : verifier les fluidbatches
===> RAF : faire un essai de GameHelpers::TransferPlayersToMap()
===> RAF : RenderShape en multiviews ?
===> 19/12/2020 : RAF : finir la modification de World2D::UpdateVisibleCollideBorders()
</Multiviews>

- 02/07/2020 : voir pour reduire tous les sprites des scml pour se conformer à une echelle 1:1 dans les object.xml (petit, vampire, coffre, skeleton, les armes, les effets ...)
=> elsarion et raignee sont deja fait. La sorciere c'est ok. A verifier dans Inkscape. Refaire une galerie de monstre avec decors pour le dimensionnement des monstres.
==> 9 à redimensionner

- 14/05/2020 : en USE_CHUNKBATCH les RenderShapes ne sont pas sur le bon layer à cause de ChunkBatch qui ne differencie pas les differents type de Tile (TILE,DECAL,SEWING)
=> le layer des RenderShapes doit etre entre les Tiles/Sewing (en dessous) et les Decals(toujours au dessus)
=> il faudrait corriger les ChunkBatch dans ObjectTiled pour separer les differents type de Tile (TILE,DECAL,SEWING)
==> USE_CHUNKBATCH vaut-il le cout à modifier ?
===> Test du nombre de batches en Arena (en desactivant les Entities et avec les Furnitures)
====> avec USE_CHUNKBATCH => 20 batches en FRONTVIEW
====> sans USE_CHUNKBATCH => 21 batches en FRONTVIEW
=====> est-il plus rapide ?

- 09/04/2020 : ajout de color dans Urho3D::Spriter::Entity
=> permet d'ajouter des couleurs specifiques à chaque entité spriter et pas seulement à tout l'animationset : il faut ajouter dans le SCML l'attribut 'color' dans le tag entity (cf armoire.scml)
==> il s'agit d'une teinte globale pour une entity et non par sprite (ce qui sera un must to have)

- 23/02/2020 : la ceinture de l'armure du skeleton n'apparait pas sur le skeleton. elle apparait bien sur le lizard

- 11/02/2020 : régler la luminosité jour/nuit/transition avec ou sans l'activation de GameStatus::gameConfig_.enlightScene_
=> completer l'utilisation de GameStatus::luminosity_ pour les ObjectTiled et les RenderShape
=> en innerview en fonction de la profondeur sous terre, appliquer un modifier

- 28/12/2019 : DrawableScroller de BackGround => probleme en bord de monde (bordures de l'ellipse) : faire un clamp des X dans la plage de l'ellipse ? (cf scrolling parallax 17/04/20218)

- 14/12/2019 : ajouter les effets de climat et de temps
=> OK 21/12/2019 : Jour et Nuit => sprite soleil, sprite lune
==> voire pour le mode nuit modifier Enlightment progressivement
====> OK le 11/02/2020
==> voire pour ajouter les etoiles, constellations
=> OK 28/12/2019 : Cloud => synchroniser le défilement des nuages avec la direction des intemperies (rain)
==> voire pour ajouter un fond plus rempli en nuage avec un effet alpha progressif pour voiler les astres
-> Orage : assombrissement, ajout de nuages plus noirs, pluie forte, ajout eclair (sprite temporaire + luminosité)
-> Neige
-> Grele

- 10/04/2018 : ajouter ambiance de cave : lumière, brouillard, fumée => particule emitter ? => ce sont des furnitures

- 30/10/2019 : le Skeleton avec 2 katanas - les katanas ne s'affichent pas avec les bonnes positions, echelles
-> cf AnimatedSprite2D::SwapSprites
==> AnimateSprite2D utilise le sprite de remplacement comme reference pour stocker le SpriteInfo contenant les offset de position et de scale.
    Si ce sprite est deja utilisé dans cet AnimatedSprite2D, les offsets sont remplacés occasionnant ce pb.
===> OK : spriteInfoMapping_ HashMap( Sprite2D*, SpriteInfo ) devient HashMap(Sprite2D*, HashMap(Sprite2D*, SpriteInfo ) )
====> RAF : Voir pour remplacer par une structure plus simple et rapide HashMap ( unsigned, SpriteInfo ) avec unsigned un hash de 2 Sprite2D* ?

- 07/10/2018 : Terrain avec RenderShape
=> Par Map, créer la texture WeightMap à partir de la ObjectFeatured::terrainMap_ generée par worldGenerator/MapGenerator (cf 17/03/2018)
==> voir comment modifier les textures associées au shader par le code
==> voir comment ajouter ou modifier les parametres de shaders par le code
=> Finir la gestion asynchrone dans Map de UpdatePhysicColliders, UpdateRenderShapes, UpdateRenderColliders
=> Creer les shaders pour HLSL (Windows)
==> OK pour Terrain2D.hlsl à recuperer sur ROG
=> Modifier les shaders pour OpenGL 2.0 ES (Mobiles et Armv7) attention textureGrad(), dFdx() ... n'existe pas en OpenGL 2.0 ES
=> Gestion de l'eau
=> Les resultats sur RPI sont pire avec RenderShape qu'avec ObjectTiled
==> Creer MapChunk : Object qui intégre la gestion des physiccolliders et des rendercolliders
===> permet le remplacement des Chunks d' ObjectedTiled avec en plus la gestion des collisionShapes.
===> Utiliser RenderShape par layer : drawable2D qui detient les batches d'un layer (batch de mur, de bordure, de fluide ...)
===> MapChunk pointe vers N RenderShapes
==> remplacer les Vegetations AnimatedSprite par des StaticSprite
===> ok, pas mieux sur rpi avec les plantsStatics

- 05/10/2018 : Correctif du mipmaping dans Urho2D : pour varier la qualité de texture
=> prise en compte du level de texture dans Sprite2D::GetTextureRectangle et Sprite2D::SetFixedRectangle
=> ajout static Sprite2D::SetTextureLevels(quality) qui régle le level de mipmap pour l'ensemble des sprite2D en fonction de la qualité de texture demandée
=> en déclenchant touche "1" => Game::HandleKeyDownHUD => renderer->SetTextureQuality + Sprite2D::SetTextureLevels + Event WorldDirty => update des tilesheets (utilisant des tiles (sprite2D avec fixedRectangle)) + update des batchs objecttiled
==> RAF : méthode Sprite2D To Sprite (UI) a mettre à jour.

- 18/09/2018 : les herbages pourraient etre generes comme dans 62-geomReplication avec les effets de vent au lieu d'utiliser des AnimatedSprite2D
ou bien avec des Stretchablesprite ou bien avec un shader ?

- 13/04/2018 : probleme de scaling dans AnimatedSprite2D avec SpriteSheet SJSON
=> suite à l'ajout du parser SJSON, il reste des problemes dans le code AnimatedSprite2D::UpdateSourceBatchesSpriter_OneMaterial && MultiMaterial
==> voir plant02 les 2 versions avec Urho2dSpriterAnimation (sample) et analyser ce qui cloche

- 20/07/2018 : AnimatedSprite2D update seulement si le sprite est visible
    => Description de la phase UpdateAnimation
        => Scene::Update()
            => AnimatedSprite2D::UpdateAnimation()
                => if (Renderer2D::IsDrawableVisible(drawable))
                    => Drawable2D::GetWorldBoundingBox()
                        => AnimatedSprite2D::UpdateDrawRectangle()
                            => if (drawRectDirty_)
                                => if (spriterInstance->NoSpriteKeys)
                                    AnimatedSprite2D::UpdateSpriterAnimation()
                                    => SpriterInstance::Update()
                                    => sourceBatchesDirty_ = true;
                                => calculate drawRect_
    => Description de la phse d'activation (OnSetEnabled)
        => AnimatedSprite2D::OnSetEnabled()
            => Drawable2D::OnSetEnabled()
                => enabled_ = true
                    => worldBoundingBoxDirty_ = true
                    => visibility_ = Renderer2D::IsDrawableVisible(drawable)
                        => Drawable2D::GetWorldBoundingBox()
                            => StaticSprite2D::OnWorldBoundingBoxUpdate()

                => enabled_ = false

    => Description de la phase UpdateSourceBatches
        => Renderer2D::HandleBeginViewUpdate()
            => Threaded WorkQueue => CheckDrawableVisibility()
                => Drawable::GetWorldBoundingBox2D()
                => if (worldBoundingBoxDirty_)
                    => Drawable2D->StaticSprite2D::OnWorldBoundingBoxUpdate()
                        => Drawable2D::GetSourceBatchesToRender()
                            => Drawable2D::UpdateSourceBatchesToRender()
                                => AnimatedSprite2D::UpdateSourceBatches()
                                    => AnimatedSprite2D::UpdateSourceBatchesSpriter_OneMaterial
=> à tester !
    => à corriger dans AnimatedSprite2D, lorsque une entité devient visible, les batches doivent etre vide sinon flip sur l'ancienne position => OK
    => Urho3D modifié pour gerer la visibilité des Drawable2D (version Urho3D-1.5-20180722-AnimatedSprite2DVisibility)
    => Attention : à la mort d'une entité, réapparition éphémère de l'animation juste après disparition
    ==> voir le CheckVisibility dans Renderer2D, surement le fait que la visibilité soit reeffective alors que le node est disabled
    ===> voir dans GOC_Animator2D entre le Disappear et le Destroy : peut-etre le changement d'animation passe par l'animation défaut
    ====> il s'agit du changement d'animation lorsque le state passe à Destroy, le nom d'animation est vide
    =====> 24/08/2018 : solution provisoire appliquée = GOC_Animator2D::ApplySimpleAnimations() skip si nom vide

- 18/04/2018 : Modifier les Trigger dans animatedSprite pour éviter de régénérer des StringHash dans l'updateTiggers

- 18/04/2018 : en bordure visuelle de entre 2 maps, les chunks de la seconde map ne sont pas affichés
=> voire comment les visiblechunks sont selectionnés

- 04/04/2018 : pb de draworder avec AnimatedSprite2D en MultiTexture (charactermap eredot)
=> recouvrement des parties d'une animatedSprite par d'autre animatedSprite en multitexture
==> analyser le code d'animatedSprite2D et notamment des drawOrder

- 07/02/2018 : la modification apportée à Renderer2D::UpdateGeometry pour ScrollingShape semble poser des sacades après quelques minutes de jeu
=> étudier une nouvelle solution pour la gestion d'indexBuffer en mode mutli-primitive (Triangle+Quad) (note: à la base Rendered2D ne se base que sur des quads)
===> déversement des sourcebatches dans View et Renderer
    Chaine Update:
    Engine::Update()=>E_RENDERUPDATE
        =>Renderer->Update()=>Renderer->UpdateQueuedViewport()
            =>view->Update()
                =>E_BEGINVIEWUPDATE
                    => renderer2D->HandleBeginViewUpdate()
                        => Renderer2D->UpdateViewBatchInfo()
                            =>AddViewBatch() => creation viewBatchInfo.geometries_ et assocation de l'indexbuffer et du vertexbuffer avec celles-ci.
                            =>Update des Drawable::batches_ alimenté par viewBatchInfo
                =>View::GetBatches()=>GetBaseBatches=>pour chaque drawable copie les sourcebatches dans la queue=>AddBatchToQueue
    Chaine render:
    Engine::Render()=>BEGINFRAME
        =>Renderer->Render()
            =>view->Render()
                =>view->UpdateGeometries()
                    =>drawable->UpdateGeometry(frame_)
                        => renderer2D->UpdateGeometry()=>update de l'indexbuffer et du vertexbuffer
                =>view->ExecuteRenderPathCommands()
                    => command SCENEPASS
                        => view::BatchQueue->Draw
                            => BatchQueue::BatchGroup->Draw
                            => BatchQueue::Batch->Draw
                                => envoie les vertexbuffers et indexbuffers des Batch::geometry_ vers Graphics::Draw
                =>view->BlitFramebuffer()
===> solution : creer 2 indexbuffers et 2 vertexbuffers dans renderer2D, un par primitive (QUAD/TRIANGLE)
====> la methode ne change pas le probleme de sacades : ces sacades disparaissent une fois pris un teleporteur, bizarre ...
======> apres quelques tests sans scrollingshape, pas de sacades detectees.
======> voir si une map specifique declenche les sacades (peut-etre un pb de vertex du a la generation de polytri pour scrollingshape)
======> il s'agit peut-etre des erreurs de precisions de calcul en float qui entrainent ces saccades !

- fluidBatches : Ameliorer le Rendu
-> 14/09/2017 : analyse des cellules voisines => generation du FluidPattern (MESH4)
=> logique dans UpdateDrawPattern() à completer :
 -> cas de raccordement non satisfaisants ... cf image capture 2017-09-14 12-19-59 && 2017-09-14 12-20-11

- MESH4 : FluidBatches incomplets à finaliser (ou changement de méthodes) :
-> cas de l'alignement des waterfalls est problématique :
 - les waterfalls apparaissent aussi en resurgence qd la cellule du dessous est une waterfall
  -> ce qui implique un alignement centré obligatoire puisque pas la cellule du dessus est de l'air ou un bloc généralement, ce qui donne une remontée en waterfall non souhaitée. (09/10/2017)
  ==> règles d'alignement pour les waterfall, waterwave à modifier ! (09/10/2017)
-> essai en cours d'un triflows par cell : pour le moment buggué (13/10/2017)
==> NOTE : pour reactiver les fluids : engineconfig => fluidEnabled_ = true ou bien GameCommand "fluidenable" et "fluidpull" pour vider les fluids
===> NOTE : si aucun visuel pour les fluids => verifier si Urho3D::Drawable::GetWorldBoundingBox() est bien virtual (nécessaire pour ObjectTiled)

- pb d'index pour l'affichage des animatedsprite2D en réseau

- 25/05/2018 : Le BodyExploder avec le CharacterMapping de NewSkeleton éclate en 3 cranes ...
- 03/05/2018 : Multi-Entities et ObjectPool => pb lors du crumble, toujours les mêmes cranes : le GOC_BodyExploder2D prepare les nodes avec Simple1 uniquement
==> pour ces 2 problemes qui n'en sont qu'un pour le moment, garder toujours le meme crane
===> il s'agit de mettre à jour BodyExploder2D pour supprimer les parts superflues dans l'anim Dead des lors que l'affectation de l'entité et du charactermapping sont faites
===> utilisation de GameHelpers::SetEntityVariation() dans ObjectPoolCategory::Resize() (des l'initialisation) pour afficher qu'un seul crane (application d'un mapping par defaut)

*/

/* DONE
------

- 21/03/2023 : les maskview n'ont plus l'air de fonctionner correctement : les tiles du background qui doivent etre masquées par les tiles du frontview sont qd meme rendu.
=> en desactivant ACTIVE_DUNGEONROOFS et en remettant les anciennes MapFeatureType, cela ne pose plus de pb.
==>  OK : cela provenait du decalage de MapFeatureType::NoDecal impactant surement ObjectFeatured::UpdateMaskViews et ObjectFeatured::IsTotallyMasked qui l'utilisait (remplacer maintenant par MapFeatureType::Threshold)

- 21/03/2023 : certains tiles en frontview sont en dessous des actors alors que leur decals au dessus
=> en desactivant RENDER_ROOFS, les tiles sont bien au dessus
==> un chunk initialise le draworder de son batch avec le premier tile qui lui est ajouté.
===> dans le cas rare ou en OUTERVIEW on a un tile Roof comme premier tile d'un chunk alors le chunkBatch en FRONTVIEW prendra en draworder la valeur de ce tile (qui est inferieur au bon draworder pour les tiles de front)
====> pour que cela fonctionne il faut mettre les Roofs sur un autre indexM pour pouvoir avoir un autre chunkBatch
=====> OK : modification de ObjectTiled::GetMaterialIndex et ajout de indexMRoof=1 dans ObjectTiled::UpdateTiledBatches().

- 21/03/2023 : le loup et les arbres ont des problemes de scale scml
=> verifier les svg export avec les sprites utilisé dans les scmls
==> le scml du loup est créé avec des sprites 96dpi, le script d'export est en 90dpi (les sprites de la spritesheet seront en 90dpi)
===> modification du script ExportSVG pour en tenir compte de la base dpi des sprites dans inskcape/spriter qui peuvent etre 90dpi ou 96dpi.
====> OK : modification du nom d'export du svg => loup-export_lo.svg devient loup-export96_lo.svg
====> les plantes posent plus de probleme car n'apparaissent pas avoir un dpi commun à chaque sprite ... pour bien faire il faudrait reexporter les sprites et modifier le scml
=====> OK : rescaling des troncs et branches dans le svg

- 06/12/2022 : certains animatedsprites n'appliquent pas le fx unlit pour les feux (mort de la sorciere ou les yeux et flammes de darkren)
=> OK : correctif Urho3D::AnimatedSprite2D : il s'agit de la fonction Batch utilisé pour le character mapping (notamment Fire, No_Fire utilisé justement par les entity utilisant du feu) qui n'appliquait pas le fx unlit.

- 18/11/2022 : EliegorGolem n'affiche pas toujours son corps :
=> les deux AnimatedSprites sont bien presents
==> le premier n'a pas la bonne entité attribuée (flore est attribuée 2x ...).
===> pb dans les set attributes de AnimatedSprite2D ?
====> 26/11/2022 : correctif sur le nom de l'entity qui doit etre "rockgolem_flore" et non pas "rockgolem-flore"
====> le pb apparait toujours : verifier que le setentityvariation ne soit pas utilisé pour rockgolem (qui a plusieurs entités pour la construction du visuel avec plusieurs animatedsprites)
====> par défaut lors du chargement des GOTs entityVariation est bien à false.
====> il peut y avoir confusion entre changement de charactermapping et changement d'entity.
=====> OK 04/12/2022 : il faut etre plus explicite : scinder en 2 la fonction GameHelpers::SetEntityVariation()

- 25/11/2022 : Implementer le WallFlipping pour les Trigger dans AnimatedSprite2D
=> Ok modification de Urho3D::AnimatedSprite2D::UpdateTriggers() avec ajout d'une transformation local comme pour les sprite.

- 18/11/2022 : en Gl (avec les rendertarget) le petit fantome ne s'affiche pas à partir de certains avatars de départ comme Petit.
=> Mais fonctionne à partir de Lizard.
==> la diff avec les logs, ce sont les layer et viewmask qui ne sont pas bien attribué lorsque l'on passe de Petit vers Fantomette.
===> 23/11/2022 OK : dans GOC_Destroyer::SetViewZ(), l'utilisation de GOC_Animator2D::GetDrawables() était commentée.
====> cette fonction sert effectivement dans le cas des rendertargets.
====> Rechercher dans l'historique pourquoi cela a été désactivée (surement pour resoudre un autre bug).

- 18/11/2022 : apres recharge d'une partie à coté d'un coffre qui a été vidé, l'animation du coffre est l'animation du coffre rempli.
=> 23/11/2022 Ok : ajout dans GOC_Inventory::OnSetEnabled() d'un CheckEmpty.

- 18/11/2022 : rain ne s'affiche plus.
=> pb avec World2D::IsVisibleRectInFullBackGround().
==> le state visibleRectInFullBackground_  a été setté dans World2D::UpdateVisibleLists() depuis la derniere modif. cette fonction peut etre appelée avant qu'une map ne soit chargée (donc que la topography ne soit pas encore totalement faite).
==> il faut déplacer le set de visibleRectInFullBackground_ (voir aussi pour isUnderground_)
===> 23/11/2022 OK ajout de World2D::UpdateVisibleRectInfos.

- 18/11/2022 : pb avec les renderCollider (sous GL ou Vulkan) en bordure : edgeOffset ?
=> 23/11/2022 OK : apres resolution du pb avec la pluie. Le phenomene n'apparait plus... Bizarre. A surveiller.

=> 19/10/2022 : l'affichage des fluidcell d'arriere plan est chaotique. Seulement certains watertiles s'affichent.
==> surement un pb de z depth
===> les vertices de watertiles qui ne sont pas affichés ont un inZ=1
====> correctif WaterLayerData::UpdateTiledBatch
=====> autre probleme majeure : la texture unit doit etre 1 et non pas 0 : le Shader utilisé est ShaderGrounds si textureId=0 alors il applique un effet BackShape.
======> 21/10/2022 : OK correctif dans la material WaterTile.xml et dans WaterLayer::UpdateTiledBatch

- 5/10/2022 : les waterline deformations ne sont pas toujours effectuées en bordure de waterline lorsque la waterline est grande avec un angle important
=> cf Waterline::Update
==> OK : correctif dans la section Add Point Deformations.

- 29/09/2022 : finir l'implementation du WaterLayer
=> ajout d'un smoothing entre les watersurface d'un waterline pour eviter d'avoir des marches du au changement de tile en Y : cf WaterLine::Update()
=> déplacer les fluidSourceBatches de ObjectTiled vers WaterLayer et établir les waterline avant de generer le batch pour les watertiles (cela permettra de supprimer la difference entre les watertiles de surface et les waterlines.
==> OK : passage de la simulation et de la gestion des batches dans WaterLayer
===> réorganisation des batches qui sont eparpillés dans les structure ViewportRenderData (pour les WaterTile) et WaterLayer (pour les WaterLine)
====> OK : mis dans WaterLayer.
===> 03/10/2022 OK : désormais les Waterlines peuvent mettre à jour les vertices du waterTileBatch lorsque les waterlines se superposent aux watertiles (le cas pour les fall head, fall part et fall surface mais uniquement avec numquads=1).

=> 30/05/2022 : ajouter les lignes d'eau de surface :
=> Utilisation define WATERLINE_TEST pour tester dans ObjectTiled les waterlines de façon rapide.
==> plutot un bon debut. Il faut maintenant generer les waterlines avec plus de vertex et ajouter la deformation par ondulation en cas de contact avec des entités.
==> pouvoir separer le fluidbatch en WaterFallBatch, WaterBassinBatch, et WaterLineBatch
===> le WaterBassinBatch = FPT_Surface + FPT_Swirl + FPT_FullWater
===> revoir les conditions pour l'obtention de WaterFall. cf FluidCell::FindPatternType_PassBottomToTop et FluidCell::FindPatternType_PassTopToBottom().
====> OK : cf ObjectTiled::UpdateFluidBatch pour Mesh4 : RAF Swirl à supprimer. Bon algo.
====> ajout du #define VALIDATE_BASSIN pour bien separer les surfaces des waterfall : utilise une detection simple de bassin par ligne.
=====> cela permet de ne pas utiliser les FPT_FullWater dans les WaterFalls. Cependant ne permet pas d'obtenir un bon rendu sur des grosses vagues si on continue d'utiliser un seul batch.
====> on genere le waterLineBatch et le WaterBassinBatch à partir des WaterLines
====> les WaterLines s'appuient sur les WaterPoints provenant des points milieux de chaque WaterTiles de types FPT_Surface et FPT_Swirl
====> la deformation par ondulation de chaque Waterline doit etre persistante : chaque WaterLine est liée à un FluidCell et testé à chaque modification du fluidcell ?
==> Interaction avec les WaterLines : voire pour commencer GOC_Move2D::UpdateAreaStates() : routine utilisée pour savoir si l'entity est dans le liquide.
===> 06/07/2022 : ajout de WaterSurface et WaterLine et pour l'interaction ajout d'une CollisionBox2D dans WaterLine
====> 24/07/2022 : ajout des extremités de la WaterLine et calcul de l'angle à appliquer à la CollisionBox2D
=====> 14/08/2022 : suppression de WaterLine::surfaceDepth_.
====> 14/08/2022 : en extremité de waterline ne pas deformer
=====> modification de WaterLine::AddDeformations.
=====> modification de WaterLine::Update
====> 14/08/2022 : ne pas déformer plus que la profondeur d'eau disponible.
=====> modification de WaterLine::Update : ajout de clamp
====> 14/08/2022 : pb avec la persistance des deformations malgré l'utilisation d'un mapping des waterlines => du au reset des watersurfaces à chaque frame.
=====> 20/08/2022 : ajout du check de la startcell au voisinage.
====> 21/08/2022 : certaines waterline n'interagissent pas toujours, Map::HandleBeginFluidContact est bien déclenché => vérifier si il y a bien ajout dans WaterLine::AddDeformations
=====> verifier WaterLine::boundingRect_ => la boundingRect peut avoir une hauteur de 1pixel => ajout d'un seuil de déclenchement pour la hauteur dans WaterLine::AddDeformations.
====> 21/08/2022 : ajout debug waterline color
====> lorsqu'un waterline est décomposé en 2 à cause de l'ajout d'un tile par exemple, les déformations ne suivent pas sur le nouveau waterline ajouté.
====> pour la persistance des waterDeformationPoints_ entre waterlines et entre maps, il faut plutot que les deformations soient calculées en static pour chaque waterpoint et que les waterlines viennent prendre les waterpoints qui sont dans leur boundingbox
    et reprennent ces calculs pour les integrer afin d'obtenir le batch.
=====> lors d'une interaction avec le water2d, enregistrer un waterpoint et trouver le fluidcell associer.
=====> puis à chaque frame, vérifier si le waterpoint est toujours actif et verifier le changement de fluidcell (update du y du waterpoint si nécessaire) et calcul de la deformation centrée sur ce waterpoint.
=====> puis pour chaque waterline générée, trouver les waterpoints inclus dans la boundingbox, effectuer le calcul final des deformations pour cette waterline et batcher.
=====> pour le moment, il n'y a pas de continuité de deformation entre maps.
=====> la recherche des waterlines doit se faire à chaque frame pour chaque currentviewz de chaque viewport.
======> pour l'instant les WaterLines sont formés dans chaque FluidData à partir de WaterSurface empilées par ObjectTiled lors du FluidBatch.
=======> il faudrait déplacer les WaterSurfaces dans une classe de rendu pour le viewport qui ne soit pas associer à une map.
=======> cette structure sera appelée dans chaque ObjectTiled::UpdateFluidBatch()
=======> Refactoring : creation de WaterLayer qui est un composant créé par world2D et qui cree waterlines et batch à partir des watersurfaces transmises par objecttiled.
========> ce composant doit remplir les batches apres objecttile => modification de Renderer2D::UpdateViewBatchInfo et ajout de Drawable2D::isSourceBatchedAtEnd_
========> 08/09/2022 : OK pour les waterlines. le CheckConnectedNeighborsAt() est corrigé (avant ne pouvait pas continuer la waterline sur un tile au dessus ou en dessous).
=========> RAF : 2 pbs sur les deformations par endroit : decalage en x et deformation saccadée. (voir WaterLine::Update() partie add deformation point)
===========> correctif ok pour le decalage en x
=========> 12/09/2022 : OK : les splashs doivent etre fonction de la velocité des acteurs en contact.
=> 12/09/2022 : corriger la simulation des fluid lorsque en fin de chute d'eau il y a une fullWater et au dessus une isolatedWater => il faut alors que la fullwater soit une SurfaceWater.
==> OK : Patch dans la pass2 de ObjectTiled::UpdateFluidBatch.

=> 30/05/2022 : interaction avec les feux devant être éteints en contact avec l'eau.
==> 06/07/2022 : OK GameHelpers::SetLightActivation(), utilisation de GOA::FIRE comme attribut dans le node des feux.
                    GameHelpers::UpdateLayering(), utilisation de GOC_Animator2D::CheckFireLight()

=> l'eau n'est pas affiché au niveau des fenetres du aux z des decals
=> par ces fenetres, l'eau de l'INNERVIEW est au dessus des entités qui sont en FRONTVIEW
==> il faut une pass WATER pour l'innerview et une pour le FRONTVIEW.
==> ou bien utiliser uniquement la pass WATER pour le currentview et dans les autres view utiliser la pass ALPHA.
===> comment ? utiliser deux materials differents l'un pour les watertiles (pass ALPHA) "watertiles.xml" et l'autre pour la refraction "waterrefract.xml"
====> OK : modification des material water : watertiles.xml, waterrefract.xml avec technique et shader. et ObjectTiled::UpdateFluidBatch
=====> RAF : modification shader sous OGL 110 et 120.
==> OK 19/09/2022 : correctif pour Vulkan dans ObjectTiled::UpdateFluidBatch => SetTextureMode(TXM_UNIT, 0, texmode) : les watertiles n'avaient pas leur textureunit d'initialiser (Unit=0 dans ce cas)

- 08/09/2022 : les staticSprite du GO_Pool ne sont pas mis dans LAYERMATERIAL.
=> OK ajout dans GO_Pool::Resize

=> 30/08/2022 : OK correctif du SRGB pour le basculement en fullscreen sous VULKAN.

=> 30/08/2022 : probleme de uiscale avec la mouse en fullscreen (qui utilise le MM_WRAP mode) : le curseur ne peut pas parcourir tout l'écran.
==> OK : en supprimant le MM_WRAP mode (unique mode = MM_FREE)
==> c'est un pb dans Urho3D : voir Input::HandleSDLEvent() les positions fournies par SDL_MOUSEMOTION event ne pourront pas etre recuperés si MM_WRAP.
===> les positions avec le mode MM_WRAP sont settés dans Input::Update() ... peut-etre que le SDL_GetGlobalMouseState ne fonctionne pas bien en fullscreen...

=> 30/08/2022 : RockGolem-Flore sous l'eau n'affiche pas les flores
==> le material LayerActors n'est pas setté s'il y a plus qu'un animatedSprite dans l'entité.
===> OK : modification de GOT::PreLoadObjects pour inclure tous les animatedSprite de l'entité.

=> 30/08/2022 : probleme d'affichage des text3D : ils sont sous le layer water.
==> OK : dans TextMessage::Set ajout du material LayerFrontText3D.xml utilisant une technique qui spécifie la pass "front"
==> OK : modification pour les dialogues avec utilisation du LayerFrontShapes et LayerFrontText3D.

- 15/06/2022 : l'AnimatedSprited "RenderTarget" de fantommette ne s'affiche plus.
=> l'exemple 52 dans Urho3D fonctionne bien.
==> l'exemple 52 avait était modifié.
=> le debug de la scene rtt s'affiche bien. Ce n'est pas un probleme de rendu de la scene rtt vers la scene main.
==> l'animatedSprite ne s'affiche pas dans le viewport overlay "DebugRttScene"
===> OK : correctif d'un probleme de parametre NearClip FarClip pour la camera rtt dans GameStatus::Initialize()
==> probleme avec GOC_Destroyer::SetViewZ() : lorsque Petit est en INNERVIEW et changement vers Fantomette puis Fantomette va en FRONTVIEW alors Fantomette n'a pas changer de ViewZ
===> dans GOC_Animator2D::CheckAnimatedSprite() ajouter les 2 AnimatedSprite (main et target), faire un update GOC_Destroyer::SetViewZ().
====> ainsi les deux AnimatedSprite auront le meme viewMask. ViewManager::SwitchToViewIndex() change le viewMask de la camera de rttScene.
=====> pourquoi ne pas laisser tout simplement les animations rendertarget avec toujours le meme viewmask et ne pas changer le viewmask de la camera rttScene ?
=====> RAF: cela ne fonctionne pas pourquoi ? laisser l'update du viewmask dans le rtt pour l'instant.

- 03/06/2022 : pb sous OGL lorsqu'il n'y a plus de light et que le "ShaderLit" doit être bien actif (donc pénombre), c'est du "ShaderUnlit" qui prende le relai générant la lumière ambiente non voulue.
=> OK : modification du shaderGrounds : vVertexLight doit toujours prend au minimum la valeur de la zone Ambient si VERTEXLIGHT.

- 30/05/2022 : retour sur les watereffects
=> s'appuit sur le WaterEffect d'Urho3D avec suppression de la reflection. la Refraction de l'arriere-plan est
    réalisée par le shader Water2D en pass refract, celui-ci utilise en texture d'entrée la texture viewport générée en pass alpha.
=> modification du renderpath => voir RenderPaths/ForwardUrho2D.xml
=> on utilise le depthbuffer pour l'affichage de l'eau. (le draworder 2D ne sert à rien dans ce cas)
=> les tiles de ground doivent donc avoir leur position z settée. (rappel les z positifs sont vers l'interieur de l'écran)
=> RAF : portage VULKAN : Shader Water2D et position Z à rajouter au Vertex2D.
==> seules les vertex utilisant la texture des groundtiles ont leur position z utilisé (cf shaderGrounds)
==> technique TechGrounds : activation depthwrite=true pour l'écriture des position z des tiles dans le DepthBuffer.
==> technique Water2D : activation depthtest=less : seuls les vertex dont z sont inferieurs (donc vers l'exterieur de l'écran) à ceux du depthbuffer passent.
==> modification de ObjectTiled pour ecrire les z dans ObjectTiled::UpdateTiledBatches et ObjectTiled::UpdateFluidBatch
===> les decals et les sewings ne seront pas pris en compte.
====> si on ajoute les z pour les decals l'effet n'ira pas sur les bordures et il y a aura un vide d'eau entre les vertex de bordure et la texture de bordure.
===> RAF PB en SwitchViewZ=FRONTVIEW on ne peut plus voir les watertiles de l'INNERVIEW.
====> il faut modifier les positions z des watertiles INNERVIEW visibles.
=====> OK modification logique dans ObjectTiled::UpdateFluidBatch.
=> utiliser le depthwrite augmente le nombre de batch : autant créer un batch separer pour les tiles.
=> pb lors de l'affichage initial de la scene : les groundtiles (dont les z sont desormais negatives) ne sont pas affichées.
==> on pourrait eviter d'utiliser les z negatifs.
==> OK : mettre en z=1.0 tous les shaders sauf ground et water. et utilise la valeur 1.0-zf dans ObjectTiled::UpdateTiledBatches et ObjectTiled::UpdateFluidBatch
===> les decals en front et les nuages doivent etre rendu dans le LayerRenderShapes ... Apres les WaterTiles
====> creer une nouvelle passe ? pass front
=====> OK, il y a un pb pour le Lit. cf Renderer::LoadPassShaders et Technique::BeginLoad
======> OK : dans la technique LayerFrontShapes ajouter dans la pass "front" l'attribut lighting="pervertex"
====> modification de ObjectTiled::UpdateDecalBatches pour utiliser le bon material LayerFrontShapes pour les Decals en front.
====> RAF : il faudrait mettre les Decals Platform dans un autre batch, pour pouvoir utilise la meme technique dans l'INNERVIEW
=====> à modifier ObjectTiled::UpdateDecalBatches, notamment mettre material = GameStatus::layerMaterials_[viewIds.Back() == viewID ? LAYERFRONTSHAPES : LAYERGROUNDS];

- 24/05/2022 : probleme avec les luminaries du portal
=> suite à la modification de GOC_Animator2D introduisant la gestion de plusieurs animatedSprite (pour SteleRip), GOC_Animator2D::SetEnabled() a été modifié pour setter sur le meme layer tout les animatesprites.
 il faut desormais utiliser l'attribut AnimateSprite2D::"Layer Modifier" ou bien specifier AnimatedSprite2D::SetOrderInLayer
==> attention GOC_Destroyer::SetViewZ respecifiait le order in layer => desactivation de la ligne. (voir ce que ca donne)
==> OK : attention de bien ecrire l'attibut "Order in Layer" ("in" sans i majuscule)

- 22/05/2022 : difference de colorimetrie entre Desktop OGL3 et Android GLES2,
=> solution 1 : dans Urho3D::Graphics.h ajout #define DISABLE_SRGB, pour mettre les plateformes à la meme colorimetrie
=> solution 2 : gerer la colorimetrie dans FromBones
==> ajout de la correction de gamma dans les shaders GL120. (GLES2)
==> OK : dans DefsViews.h modification des valeurs des RS_ALPHA en GLES2

- 17/05/2022 : probleme avec Vulkan lors du redimensionnement de la fenetre durant le Splash initial (qui utilisent l'UI) => ecran noir. (pas de pb avec le SplashScreen tete de mort)
=> pas de probleme avec Ogl
==> 25/05/2022 OK : correctif dans GraphicsImpl::CleanUpSwapChain() : reset des states.

- 3/12/2021 : apres passage dans Portal, Fantomette 'RenderTarget' ne reapparait pas
=> probleme d'affichage de la texture rendertarget
=> ca fonctionne pourtant correctement en changeant d'avatar.
==> voir Urho3D::AnimatedSprite2D::OnSetEnabled()
===> OK : correctif sur la visibilité

- 3/12/2021 : les effets de lumiere de Portal ne fonctionnent plus en LAYERMATERIALS
=> cf GOT::PreLoadObjects()
==> OK : declarer l'effet haloportal comme furniture egalement (GOT_Furniture) dans Effects.json
==> on pourrait également modifier le code dans GOT::PreLoadObjects() et aussi ajouter un champ layermaterial dans les .json pour permettre cette déclaration explicitement.

- 17/11/2021 : les modifications apportées sous la variation Tex2D ne sont pas compatibles OpenGL2
=> pour cibler RPI, il faut modifier les shaders pour enlever les operators bit & et pas de keyword flat pour la non interpolation des varying et pas de switch case
==> Ajout de Round() pour regler la non interpolation entre le VertexShader et le FragmentShader : Ok pour TextureId mais pas pour TextureFX.
=> Pour les BackShapes, il faut reintegrer le shader BackShapeAtlas2D.
=> Correctif Urho3D/SDL permettant l'utilisation du KMSDRM backend.
==> 24/11/2021 : Ok sous RPI3 PiOS
===> en 640x480, la version Tex2D (13 batches=>20fps) est beaucoup plus lente que la precedente version (25batches=>45fps)
====> surement le fait de binder plusieurs textures pour un batch.
==> Permettre d'etre lancer en RPI legacy (Raspbian precedents Buster avec /opt/include/vc) avec RPIVIDEO (et fenetrage X11).
===> en RPI legacy, la version Tex2D a de gros probleme de lenteur (1fps) et d'affichage : probleme combiner des bind et des shaders...
==> 29/11/2021 : creation de plusieurs dossiers shader en fonction des versions de GLSL, selection du dossier GLSL au demarrage en fonction de la version OpenGL.
==> 29/11/2021 : modification des shaders GLSL110 (OpenGL2) pour etre plus rapide (suppression de ExtractBits, remplacement par les differentes valeurs possibles pour un type d'effet)
===> sous RPI4 bullseye, la version Tex2D arrive à 35fps en 640x480
====> refaire un essai en RPI Legacy.
====> faire un essai en modifiant le MASK_VERTEX2D pour avoir plus de float (surement plus couteux en bande passante) permettant de s'affranchir de calcul couteux dans les fragment shaders
=====> utiliser MASK_TANGENT qui est vec4 ald MASK_TEXCOORD2 (vec2)
======> ca n'ameliore pas grand chose.
=> commenter ACTIVE_LAYERMATERIALS dans GameOptions.h pour remettre le bind que d'une texture en meme temps
==> cela solutionne le probleme sous RPI et permet de conserver le travail fait sous la version Tex2D : le principe des LayerMaterials (plusieurs textures par batch) n'est pas performant sur RPI, voir sur mobile
==> rebalayer le physique de tous les objets : avec le resizing/repacking des monstres dans des spritesheets, il faut revoir les colliders.
===> 3/12/2021 : OK
==> sous RPI à priori pas de RenderTarget (OpenGL2 ?), il faut pouvoir mettre la version classique de fantomette.
===> 3/12/2021 : Ajout de ACTIVE_RENDERTARGET, permet de desactiver le RenderTarget (cf GameStatus::Initialize(), Urho3D::AnimatedSprite2D::SetRenderTargetContext(), Urho3D::AnimatedSprite2D::SetRenderTargetAttr())

- 05/11/2021 : grosse modification graphics dans Urho3D
=> modification du shader URHO2D.glsl pour permettre l'utilisation de plusieurs spritesheets dans un drawcall (inspiration Hazel).
==> modification de OGLShaderProgram ShaderProgram::Link() pour ajouter sUrho2DTextures[]
==> il faut maintenant reunir dans le material LayerActors.xml toutes les spritesheets des entities
==> de meme pour tout les layers : regrouper les backgrounds dans LayerBackgrounds.xml et les Tiles dans LayerTiles.xml
=> le shader URHO2D.glsl englobera tous les effects necessaire pour le 2D (lit/unlit/alpha/vegetation etc...)
==> modification des attributs de Vertex2D => ajout de Vector2(TextureID, TextureFX)
===> modification des UpdateSourceBatches dans StaticSprite2D et AnimatedSprite2D.
====> faire de meme pour ParticuleEmitter2D
=> ajout du rendering target dans AnimatedSprite2D qui permet de rendre dans une view intermediaire (buffer) : utile pour appliquer des effets comme l'alpha global sur animatedsprite. (Fantomette ok)
==> Gain en Batches
===> en Arena : le jeu s'execute avec RenderShapes et UI compris en 10 batches en frontview et 14 batches en innerview avec 1 seul acteur (petit)
====> OK : RainEffect integrer au material LAYERGROUNDS.
====> OK : AnimatedSprite2D en MultiMaterials => verifier si les RenderedAnimations sont bien retirés lors du changement d'avatar.
=====> Ca a l'air ok, en dumpant le nodeattr et dans AnimatedSprite2D::UpdateSourceBatchesSpriter_RenderAnimations mais le nombre de batches augmenter lorsque l'on utilise l'epee de feu (qui a un effet flame en RenderedAnimation en plus de l'epee)
======> en dumpant le nombre de batches pour l'AnimatedSprite2D, le nombre est bien de un. bizarre !
=======> apres visualisation dans QRenderdoc, il apparait que l'effet flamme est affiché une premiere fois dans le layer background engendrant un batch supplementaire et ensuite dans le batch actor.
========> correctif dans AnimatedSprite2D::AddRenderedAnimation() -> toujours setter l'animation incluse à SetRenderEnable(false).
====> OK : ParticleEmitter2D modification pour utiliser des spritesheets.
=====> Les Particules avec un blendmode different du BLENDALPHA ne seront pas bien affichés si l'on utilise le material LayerActors.xml pour reduire le nombre de batches.
======> 09/11/2021 : soit n'utiliser que des particules en blendapha, soit permettre l'ajout de batches avec d'autre mode de blend tel que blendadd (necessaire pour lifeflame)
=> la texture RenderTarget doit etre debinder si pas d'utilisation. Les mipmaps pour elle sont constamment generes car c'est une rendertarget (pourquoi ? pas trouver de reponse dans Urho3D)
==> 10/11/2021 : OK realiser dans GOC_Animator2D::OnComponentChanged()
=> 10/11/2021 : Optimisation des textures pour l'ui : regler l'Opacity à 0.9 pour forcer le blend alpha.
==> 10/11/2021 : modification de Urho3D::Cursor pour eviter un batch pour le cursor : ajout de Urho3D::Cursor::DefineShape(CursorShape, const CursorShapeInfo&) pour passer la texture existante.
=> 15/11/2021 OK : generer toutes les textures Actors à intégrer au material LAYERACTORS.
=> generer toutes les textures Collectables à intégrer au material LAYERACTORS et modifier GOC_BodyExploder2D, GOC_Inventory, GOC_Collectable, ScrapsEmitter, GameHelpers::SetCollectableProperties(), GameHelpers::SpawnScraps() pour specifier le material si necessaire
==> OK : mettre les Scraps dans collectable1.png intégré au LAYERACTORS, et les Parts (bone, elsarionmeat) => permet de corriger la creation des Collectable Parts via la texture UI game_equipment.
==> RAF : modifier GameHelpers::SetCollectableProperties()
=> Resultats (Renderdoc):
==> en Frontview (10 batches)
===> 1 batch LAYERBACKGROUNDS (backscrollers + sun,moon,cloud)
===> 1 batch LAYERGROUNDS (background + vegetation)
===> 1 batch RenderShape (sur background)
===> 1 batch LAYERGROUNDS (backview)
===> 1 batch LAYERACTORS (innerview tous les entities, objects + vegetation + Particules forcées en blend alpha)
===> 1 batch LAYERGROUNDS (outerview) + Rain + Vegetation + cloud
===> 1 batch LAYERACTORS (tous les entities, objects + vegetation)
===> 1 batch LAYEREFFECTS (tous les particules en blend addapha)
===> 1 batch LAYERGROUNDS (Frontview) + Rain + Vegetation + cloud
===> 1 batch UI (tous les panels + cursor)
==> en Innerview (13 batches)
===> 1 batch LAYERBACKGROUNDS (0-5)(backscrollers + sun, moon, cloud)
===> 1 batch LAYERGROUNDS (BACKBIOME=10 to BACKGROUND=20) (background + vegetation)
===> 1 batch LAYERACTORS  (BACKACTORVIEW=21) (backactorview tous les entities, objects + vegetation en color BLACK provenant du frontview + Particules forcées en blend alpha)
===> 1 batch RenderShape  (BACKGROUND+LAYER_RENDERSHAPE=23) (sur background)
===> 1 batch LAYERGROUNDS (BACKVIEW=40)
===> 1 batch RenderShape  (BACKVIEW+LAYER_RENDERSHAPE=43)
===> 1 batch LAYERGROUNDS (BACKINNERBIOME=50 to INNERVIEW+LAYER_PLATEFORMS=63) (innerview back) + mobiliers + vegetation
===> 1 batch RenderShape  (INNERVIEW+LAYER_PLATEFORMS+LAYER_RENDERSHAPE=66 innerview back pour les plateforms)
===> 1 batch LAYERACTORS  (INNERVIEW+LAYER_ACTOR=67) (tous les entities, objects + vegetation + particule en blend alpha)
===> 1 batch LAYEREFFECTS (INNERVIEW+LAYER_ACTOR=67+ORDER1000ou2000) (tous les particules en blend addapha)
===> 1 batch LAYERGROUNDS (INNERVIEW=70 to INNERVIEW+1(for SteleRip)=71)(innerview front pour les walls +frontfurnitures)
===> 1 batch RenderShape  (INNERVIEW+LAYER_RENDERSHAPE=73)(sur wall innerview)
===> 1 batch UI (tous les panels + cursor)
==> Attention au resultat en utilisant le debugHUD F2, cela va rajouter 2 batches (1 pour l'ui Urho3D + 1 pour le cursor du jeu).
=> MUSTHAVE : la derniere amélioration serait de transformer tous les Batch Quads en Batch Triangles (Mesh2D). Ce qui permettra de n'avoir que des batchs Triangles pour le Renderer2D. l'UI peut rester en Quad.
==> suppression de l'indexBuffer ?
=> Fusion des RenderShape avec LAYERGROUNDS :
==> Frontview = 7 batches - Innerview = 7 batches
==> tous les drawable2D à reprendre (StaticSprite2D, AnimatedSprite2D, ParticleEmitter, ObjectTiled, DrawableScroller, RenderShape (deja fait en partie)).

- 01/10/2021 : la pluie au demarrage est trop droite.
=> 05/10/2021 OK : Patch dans Droplet::Reset() pour avoir un peu plus de dispersion.

- 06/04/2021 : les montagnes ne s'affichent plus en mode Arena apres avoir été en underworld.
=> pb de reinitialisation des DrawableScroller ? bloquer en underworld ?
==> DrawableScroller::SetDrawableObjects() utilise DrawableScroller::boundcurve_ défini dés le passage en AnlWorldModel. Il faut le remettre à 0 lors du passage en FlatMode.
===> OK !

- 11/12/2020 : en innerview, les entities frontview sont affichés alors qu'elles doivent etre masquées
=> faut-il revenir en arriere et remettre le viewmask ne permettant pas d'afficher les entities frontview lorsque l'on se trouve en innerview ?
==> attention, il faut tenir compte des differents viewports : depuis le passage en multiviews le GameHelpers::ApplyLuminosity() a été enlevé de ViewManager::SwitchToViewIndex().
    Il permettait justement de mettre les entities sur le bon layer en plus de regler la luminosité.
==> en Multiviews, il ne faut surtout pas les changer de layer via Drawable2D::SetLayer() ce qui aurait un impact sur les autres viewports qui ne sont pas forcemenent sur le meme viewZ
==> le probleme etant GameHelpers::ApplyLuminosity() qui n'est pas multiviews et qui met en BACKACTORVIEW les nodes si le currentviewZ est INNERVIEW et les nodes FRONTVIEW.
===> le currentviewZ devant etre dépendant du viewport
===> faut-il introduire un layermodifier dans Drawable2D comme ObjectTiled::SetLayerModifier() qui sera pris directement dans le UpdateSourceBatches() ?
====> dans un premier temps, si le multiviews n'est pas actif continuer d'utiliser les anciennes procédures GameHelpers::ApplyLuminosity().
=====> RAF : Si multiviews utiliser les anciens viewmask comme pour les furnitures frontview qui ne sont pas affichées si player en innerview.
======> 02/03/2021 : Desactivation complet des Luminosity via VIEWZ_LUMINOSITY_EFFECT
======> il faudrait que le Drawable2D::GetSourceBatches() se fasse en fonction du viewport avec modification de la couleur des vertices en fonction du layer du viewport et celui du drawable ?
=====> OK : 25/03/2021 : Modification de Urho3D::Drawable2D et classes filles pour ajouter un sourcebatche dédié au BACKACTORVIEW. GameHelpers::ApplyLuminosity() devient GameHelpers::UpdateLayering()
======> la color du BACKACTORVIEW est géré dans Urho3D::StaticSprite2D : color2_ par défaut Color::BLACK.
======> l'astuce pour le changement de sourcebatch se fait dans Drawable2D::GetSourceBatchesToRender(), le premier set de sourcebatches est pour INNERVIEW/FRONTVIEW, le second pour BACKACTORVIEW
======> suppression de VIEWZ_LUMINOSITY_EFFECT et du code associé
=====> voir pour l'integration de Drawable2D::SetLayer avec les classes filles autre que StaticSprite2D et AnimatedSprite2D.
======> OK : pour ParticleEmitter modification de Drawable2D::GetSourceBatchesToRender() pour ne pas afficher les particules en BACKACTORVIEW.

- 11/03/2021 : apres chargement d'une sauvegarde avec epee enflammée, une épée enflammée reste statique à l'endroit du pop du porteur.
=> ne pose pas de probleme si seulement utilisation du LoadStuff (F5), uniquement si jeu->charger.
=> cf Player::LoadAvatar(), AnimatedSprite2D avec RenderAnimation.
==> OK : quelques correctifs dans AnimatedSprite2D
==> OK : correctifs dans Player::LoadAvatar(), le node etait enabled alors qu'il faut que le node soit enabled seulement dans PlayState::HandleAppearPlayer().
    Egalement Ajout de Equipment->SetDirty() permettant d'esquiver Equipment->Update() dans Player::UpdateComponents() avant que l'equipment soit loader. (evite d'avoir 2 Equipment->Update rapprochés).
===> 13/03/2021 : apres teleportation, l'arme et l'effet ne s'affiche pas.
====> OK : modification de AnimatedSprite2D::OnSetEnabled()

- 12/03/2021 : probleme lors du chargement d'une partie avec un Portal dans la zone visible. Lors du splashscreen le portal s'affiche.
=> les portals sont desormais des usable furniture chargé avec Map::SetEntities_Load
==> OK : modification de Map::SetEntities_Load pour ajouter le SetEnabled aussi pour les usable furnitures.

- 02/03/2021 : pendant la teleportation de GOC_Portal, les ObjectTiled disparaissent parfois : il faut pouvoir les garder jusqu'à la teleportation effective.
=> voir si encore actif apres modification la grosse modification BEHAVIOR sur GOC_Portal et MapStorage du 05/03/2021.
==> 10/03/2021 : les ObjectTiled dont les maps sont visibles ne doivent pas avoir d'update de leur batches juste avant la teleportation effective car sinon les chunk rendus sont ceux de la nouvelle position
===> OK : ajout de ObjectTiled::SetRenderPaused() utiliser dans World2D::SetKeepedVisibleMaps().

- 02/03/2021 : toujours probleme de visibilité avec les StaticSprite2D
=> en bordure d'écran affichage soudain
=> parfois n'apparaissent pas du tout
==> OK : forcer l'update des batches lors du MapBase::SetFurnitures()

- 09/12/2020 : les feudecamp et les bougie ne sont pas sur le bon layer.
=> n'ayant pas de GOC_Destroyer comme les autres furnitures, le layer n'est pas setté correctement
=> voir Map::AddFurniture() et Map::SetFurnitures()
==> Appel ObjectPool::CreateChildIn() => Appel GameHelpers::SetDrawableLayerView()
===> OK : correctif dans GameHelpers::SetDrawableLayerView()

- 20/11/2020 : l'Halo du Portal n'apparait plus.
=> voir les dernieres modifications sur GOC_Destroyer. il s'agit du portalluminaries.scml
==> OK : Modification de GOC_Destroyer::SetViewZ() : le Portal a deux Drawables qu'il faut prendre en compte dans le layering et ordering

- 02/07/2020 : les effets des entités (tel que la morsure du vampire, flamme sur epée etc...) doivent toujours etre eclairés (ne doivent pas utiliser un material lightmap ou diffmap => toujours utiliser Urho2D)
=> tel quel, cela va avoir une incidence significative sur le nombre de batch
==> il faut rassembler tous les effets sur une meme texture et les spawner sur le layer effect
==> pas mal de travailler sur les scml notamment, les effets comme morsure deviendront des entités animation à spawner
=> pour les armes avec effets (epee de flame), qui utilisent les RenderAnimations, il faut pouvoir rajouter le material pour les effets (Urho2D)
==> ajout de la possibilité d'utiliser un customMaterial dans les RenderAnimations : modification de GOC_Inventory::EquipSlotOn() et AnimatedSprite2D::UpdateSourceBatches_MultiMaterials()
===> ajout de Materials/Effects.xml qui sera le CustomMaterial à ajouter pour les effets qui ne doivent pas utiliser de l'enlightment.
====> cela risque d'etre couteux en Batchs : il faudrait mieux resortir l'effet (tant pis pour le draworder du scml) et le mettre avec les autres sur le layer effect dédié.
=> reglé en intégrant une nouvelle data TextureEffect aux shaders !

- 01/07/2020 : Pb a corriger dans DrawableScroller / Map => DrawableScroller::HandleUpdateEllipseMode
[Wed Jul  1 22:03:34 2020] ERROR: DrawableScroller() - SetDrawableObjects : !dinfo on currentMapPoint=4 15 !
[Wed Jul  1 22:03:34 2020] ERROR: DrawableScroller() - HandleUpdateEllipseMode : SetDrawableObjects NOK this=318860928 !
==> pb apparait lors de DrawableScroller::HandleCameraPositionChanged
===> les map concernées sont celles qui n'ont pas besoin de scroller (sous terre)
===> fausse erreur => à désactiver => OK

- 14/05/2020 : en Fullscreen avec une resolution qui est plus petite que la resolution du bureau, la souris peut déplacer l'écran en cas de déplacement sur les bord droite et bas
=> voire pour restreindre le déplacement de la souris au dimension de la resolution choisie
==> si FullScreen passer la souris en MM_WRAP
===> cela regle le pb mais les fonctions de conversion de position entre UI et World ne fonctionnent pas correctement
====> il faut utiliser la position de GameStatus::cursor_ au lieu de celle de la souris
=> OK remplacement des occurences de input->GetMousePosition() par GameStatus::cursor_->GetPosition()

- 07/04/2020 : verifier les differences de visibleWorldRect_ entre Dektop et RPI => l'utilisation de ObjectTiled::viewRangeMode_ = ViewRange_WorldVisibleRect en mode debug reduit les fps sur RPI
=> le probleme vient du zoom de la camera qui est le ratio de la hauteur fenetre par 1080.f appliqué apres le World2D::SetCamera
=> appliquer le zoom avant + modification World2D::SetCamera
==> OK, meme visiblerect entre Desktop et RPI

- 08/04/2020 : TileSheet2D, le tilespanning est desormais declaré dans GameConfig. Utilisation du tilespanning + edgeoffset. TileSpanning de 0.1 sur desktop est bien voir sur RPI

- 07/04/2020 : Ajout de l'attribut "Custom SpriteSheet" dans Urho3D::AnimatedSprite2D permettant l'utilisation d'un fichier spritesheet XML commun à plusieurs SCML (utiliser pour les fournitures => furnituresdung01.xml)

- 06/04/2020 : Limitation de Urho3D::MAX_VERTEX_LIGHTS à 3 pour RPI (cf Urho3D::Drawable)

- 06/04/2020 : Garder toujours la light du player allumée
=> pour cela il faut fixer le Urho3D::Drawable::sortValue_ à -M_LARGE_VALUE (ajout dans cf Player::UpdateComponents())
==> ajout de Light::useFixedSortValue_ et Modification de Urho3D::Light::SetIntensitySortValue() et ajout Light::SetFixedSortValue()

- 05/04/2020 : ajout de GOC_EntityAdder permettant l'ajout d'entity ObjectPool via un composant dans le node du composant
=> utiliser pour les furnitures : pour ajouter un objet sur une table par exemple.

- 29/03/2020 : sur RPI on ameliore les fps, en augmentant le nombre de chunk à 8x8 (soit 8tilesX8tiles pour une map de 64X64tiles) au lieu de 4x4 (soit 16tilesX16tiles pour une map de 64X64tiles).
=> passer en 8x8

- 14/02/2020 : reduire le nombre de batch
=> analyser les textures pouvant etre mise ensemble en fonction du layering
==> pour les arriere plans, mettre sur une à deux textures
===> 23/03/2020 OK : modification de World2D::SetMapAddImageLayerAttr et de Map::AddBackGroundLayers en s'appuyant sur les modifications faite pour GEF_Scrolling => ScrollingLayer::Set() permettant l'utilisation de textureAtlas
==> pour les tiles, mettre sur une à deux textures
===> 19/03/2020 : mis sur une texture en 1024 => tile_terrains1024.png
===> mettre sur une autre texture 1024 les textures des rendershapes
====> 19/03/2020 : ok creation du nouveau shader BackShape2DAtlas et utilisation pour Materials/backinnerlayer.xml, Materials/backviewlayer.xml, Materials/backgroundlayer.xml
==> pour les entités et objets
===> 10/03/2020 : en cours : reunir les entités portant de l'equipment et cet equipment dans une meme spritesheet (petit, lizard, skeleton + armures + armes + torche + bullet + casques + bombe + grapin ...)
====> ok ca tient dans une 1024 => 2D/Textures/spritesheet1.png
=====> pb epaule armure petit : modification de armurepetit2.scml => GOT::PreLoadObjects() cree les refresourcelist des wearables (armes,armures) à partir de leurs fichiers scml.
======> Il faut que ces SCML contiennent bien l'ensemble des fichiers indispensables à l'affichage du type de wearable et ce dans l'ordre etabli dans le characterMapping SCML.
======> ainsi l'armurepetit2.scml doit intégrer des empty pour ne pas afficher les element d'armure (ceinture1, ceinture2 ...)
=======> RAF : ajouter au newskel2.scml un empty dans les animations à l'endroit de la ceinture2 (ce qui permettra d'afficher completement l'armure lizard sur le skel)
==> pour les weathereffets :
===> rain coute 5 batches
====> la rain serait le mieux placer avec les batch de tiles
=====> réduction de la taille des sprite et mis dans tile_terrains1024.png
=====> réduction à 1 batch
===> cloud coute 6 batches
===> creer une texture avec les nuages+astres+autres effets à venir
====> modifier le code des nuages afin d'utiliser une spritesheet ald d'une image par layer de nuage => ScrollingShape::AddQuadScrolling ou GEF_Scrolling::AddTextureLayer
=====> en utilisant ScrollingShape::AddQuadScrolling, creation d'une texture atlas nuages.png contenant les 3 textures de nuages et utilisation du shader BackShape2DAtlas
======> modification des Materials/nuageX.xml
======> creation de Scenes/Textures/nuages.xml permettant de definir la texture sans mipmapping et avec le filtermode en NEAREST pour eviter les Edge Bleeding.
    (cf. https://gamedev.stackexchange.com/questions/46963/how-to-avoid-texture-bleeding-in-a-texture-atlas)
======> modification de GEF_Scrolling::AddTextureLayer() et ScrollingLayer::Set() pour utiliser des materials plutot que des textures directement.
=======> permet d'utiliser les memes materials que ScrollingShape. Le code genere un sprite s'appuyant sur la material.
========> en filtermode NEAREST, les nuages sont trop pixelisés : utilisation du filtermode BILINEAR et ajout de sprite->SetTextureEdgeOffset(1.f) pour eviter les Edge Bleeding du à l'ajout du filtre.
======> pour ScrollingShape : pour le moment laisser en filtermode NEAREST car le mode de déplacement par TextureOffset (cf. ScrollingShape::UpdateSourceBatches()) avec le filtre BILINEAR crée des Edge Bleeding
=======> RAF1 voir pour trouver une solution dans le code (il faudrait decouper en x quad en fonction de la valeur d'uv > 1 pour pouvoir supprimer les edges ...)
=======> Donc, utiliser plutot GEF_Scrolling pour les nuages (ACTIVE_WEATHEREFFECTS_SCROLLINGSHAPE remplacer par ACTIVE_CLOUDEFFECTS_SCROLLINGSHAPE à laisser par défaut)
=======> Correctif du parallax effect dans GEF_Scrolling => RAF dans ScrollingShape
=====> pour diminuer le nombre de batch, il faut commonaliser le material et pas seulement la texture.
======> changement de methode => utiliser les spritesheets (ne plus utiliser les material avec shader BackShape2DAtlas qui necessite des parametres et donc mutliplie le nombre de materials necessaire (4 material pour une textureatlas de 4 images))
=======> les clouds ne coutent plus que 2 batches (utiliser T en PlayState pour activer/desactiver)
=======> les montagnes (DrawableScroller) ne coutent plus que 2 batches (utiliser U en PlayState pour activer/desactiver)
=======> RAF2 : pour les ScrollingShape et les RenderShape (concernées toutes les backshapes), utiliser des spritesheets ald des materials afin de réduire le nombre de batchs.
========> 26/03/2020 : A priori, sans passer par un paramshader (donc multiplie le nombre de material), ce n'est pas realisable simplement du à l'incompatibilité des TexturesAtlas avec le TextureRepeat et le TextureOffset
=========> il faudrait decouper en x quad comme evoqué ci-dessus dans le RAF1 donc augmenter le nombre de vertex pour simuler le textureRepeat et textureOffset.
=> clot le 26/03/2020 : nombre de batches divisé par 2 (ref en arena 35 batches version du 09 mars contre 17 batches version du 26 mars)

- 23/02/2020 : en enlightment, le changement d'alpha des torches et epee arete ne sont pas operantes du au material "DiffLitParticleAlpha"
=> OK : utiliser le material "DiffLitParticleAlpha2" qui utilise VERTEXCOLOR

- 02/01/2020 : en Innerview, les lames et les grapins peuvent apparaitre en noir
-> verifier le spawn dans ABI_Shooter et ABI_Grapin
--> renvoi à GOC_Destroyer::SetViewZ() => les entités n'ayant pas de GOC_Controller ne peuvent pas avoir leur couleur changée.
---> voir pourquoi cette limitation/simplification
----> en supprimant cette limitation ca a l'air OK. voire si ca n'alourdit pas trop les processus notamment avec les biomes.

- 14/02/2020 : lors d'un respawn ou bien de l'utilisation d'un Portail, les DrawableScroller de BackGround (montagnes etc...) ne se placent pas bien
=> vu en mode arena (cf DrawableScroller::HandleUpdateFlatMode())
=> voir si pb en mode world (cf DrawableScroller::HandleUpdateEllipseMode())
==> Les Events WORLD_SETCAMERA et CAMERA_POSITIONCHANGED fusionnent en WORLD_CAMERACHANGED
==> utilisation de l'event dans World2D::UpdateInstant() et World2D::UpdateAll()
====> OK : modification de DrawableScroller::HandleCameraPositionChanged.
==> cf pour GOC_Portal : pb les DrawableScroller sont deplacés avant que le teleporte soit effectuer. cf World2D::GetWorld()->GoToMap et World2D::GetWorld()->GoCameraToDestinationMap()
===> il ne faut pas que les DrawableScroller se mettent à jour entre GOC_Portal::HandleBeginContact() et GOC_Portal::HandleTransferBodies() à cause du deplacement du DrawableScroller::nodeToFollow_
====> creation de DrawableScroller::Pause() à utiliser dans ces 2 méthodes.
====> RAF : terme supprimer DrawableScroller::Pause() et simplement desactiver le suivi des nodes comme dans ViewManager ?

- 11/02/2020 : Il est genant d'avoir le coffre ou les bombes qui rajoutent de la lumiere alors qu'il fait plein jour.
-> Toutes les Light (hormis WeatherManager::sunlight_) doivent suivre la meme regle : activer/desactiver en fonction d'un seuil de luminosité
--> le coffre utilise GOC_Animator2D pour allumer ou eteindre son composant Light via AAction_LightOn
--> les bombes sont directement allumées par l'activation SetEnabled() du node, leur template AnimatorTemplate_Usable_Tick5 peut etre modifier pour ajouter AAction_LightOn pour le State_Use
---> OK : modification de GOC_Animator2D::LightOn() pour checker GameStatus::luminosity_
----> RAF : pour les bombes avec le changement de viewZ, il faut egalement checker.

- 11/02/2020 : WeatherManager::sunlight_ avec les plantes semble etre decaler bien que centrer sur GameStatus::cameraNode_
=> pour le moment, creer un decentrage pour contre-balancer ce decalage
==> meme probleme avec toutes les lights, mettre un decentrage sur un avatar pour tester.
==> le material n'était pas DiffLitParticleAlpha mais DiffLightMapAlpha qui doit créer un décalage sur x
===> OK : utilisation de DiffLitParticleAlpha
===> RAF : verifier DiffLightMapAlpha

- 11/02/2020 : lors de l'utilisation de la potion, l'animation ne se passe pas correctement
-> pb de layer ou dans l'animationtemplate ?
=> correctif du nom d'animation dans PreLoader.xml "get" devient "get_" suite au correctif pour les animations multiples "auto switchable" (cf commentaire dans GOC_Animator2D_Template::AddAnimationSet)
==> spawner l'objet utilisé dans un layer au dessus du player. cf UISlotPanel::HandleSlotDragEnd
===> dans GOC_Collectable::DropSlotFrom, ajout du SceneEntityInfo::zindex_=1000 pour le changement de orderinlayer via Map::AddEntity()
=> ok le 13/02/2020

- 30/12/2019 : RenderCollider ne fonctionnent plus dans la version du 28/12
=> OK : modification dans Map::GenerateColliders() => ajout return false; ald continue;

- 14/12/2019 : voir pour afficher les entités des autres viewZ en teinte sombre plutot que de les masquer
-> supprimer le Mask : desactivation dans GOC_Destroyer::SetViewZ(), voir s'il est possible d'utiliser le mask lorsque le joueur en exterieur et des entités en underground
-> routine qui attribue à chaque entité visible, la teinte en fonction de leur viewZ et du ViewZ courant.
--> Obtenir la liste de toutes les entités visibles et appliquer la bonne teinte => World2D::GetVisibleEntities()
---> OK : Modification de GOC_Destroyer::SetViewZ() et ViewManager::SwitchToViewIndex()
----> Ajout du layer THRESHOLDVIEW pour les portes qui ne doivent pas changer de couleurs lors du changement de viewZ
----> Modifier Map::SetVisibleEntities pour appliquer la bonne teinte également. --> OK
-----> le player en INNERVIEW, les entities qui sont en FRONTVIEW doivent etre masquer par le decors
------> si switch vers le Innerview changer de layer les Entities vers le BACKACTORVIEW
------> 27/12/2019 - OK : Modification de GameHelpers::ApplyViewZColor()
-------> 31/03/2020 : GameHelpers::ApplyViewZColor() devient GameHelpers::ApplyLuminosity

- 10/04/2018 : creer un gestionnaire WeatherManager comprenant tous les effects (rain, cloud, camerashaker, brouillard, fumée ...)
-> 20/12/2019 : Ok ajout WeatherManager avec rain et cloud

- 09/02/2018 : Rain dans innerview sur le background mode test(AnlWorld)
=> supprimer la pluie en zone cave sans aucun visuel vers l'exterieur.
==> chaque map doit stocker son état : backState_ (le background est complétement rempli ou bien si une surface existe)
===> si une surface existe, tester si les droplets apparaissent sur des tiles backgrounds, dans ce cas ne pas les faire apparaitre
===> si le background est complétement rempli alors, skip l'update de la pluie
=> 20/12/2019 OK

- 18/12/2019 : Pb de décalage de la pluie en mode World
-> OK Correctif : GEF_Rain => Droplet::Reset() remplacement de Tan(angle) par une dispersion

- 17/04/2018 : ajout de scrolling parallax de background exterieur tel que des montagnes etc...
=> comment s'assurer de la ligne d'horizon ?
=> comment faire la transition entre les differents backgrounds
=> les backgrounds changent suivant la zone
==> utilisation du scrollingshape en screenmode comme pour les nuages
===> 1 layer en fond pour commencer BACKSCROLL_1 ou BACKSCROLL_2
===> adapter scrollingshape pour permettre du multi-texturing directionel avec des seuils de déclenchement pour le changement de texture ?
==> 28/08/2018 : premier essai avec DrawableScroller pour les bordures conjuguer avec ScrollingShape (shape=world ellipse) pour les zones du dessous
===> à corriger : pour la meme valeur de parallax, l'effet parallax de ScrollingShape est beaucoup plus rapide que celui DrawableScroller et en sens opposé
====> la valeur du repeat offset a l'effet d'un scale sur le parallax lui-meme
=====> correctif appliqué pour les ScrollingShape avec shape (pas pour le cas des screenshape)
======> pour le Material défini récuperation de la taille de la texture en UNIT URHO3D (texture*PIXELSIZE) pour TextureSize, TextureRepeat=1,1
==> la shape world ellipse n'est pas assez destructurée.
===> Pour chaque map, définir une shape s'appuyant sur les points maximum du contour. en cas de défaut de contour, s'appuyer sur le world ellipse.
--> 07/11/2019 : reprise de DrawableScroller avec changement du code pour PARALLAX.
---> une valeur de parallax_ de 1 entraine aucun mouvement par rapport à la camera (cas des Background éloignés)
---> une valeur de parallax_ proche de 0 : cas des foreground.
----> A corriger : plus la valeur de parallax_ est faible, les objets étant liés à un mpoint, lorsque la camera affiche une nouvelle map, les objets visibles en background sont des map precedement parcourues.
    1. Lorsque les maps precedentes ne sont plus visibles, les objets sont retirés de la liste des objets à afficher alors qu'ils doivent etre visibles (cf DrawableScroller::HandleVisibleAreaUpdated)
    2. Lorsque les maps precedentes sont libérées, ces objets sont effacés alors qu'ils doivent etre visibles (cf Map::Clear, DrawableScroller::RemoveAllObjectsOnMap)
    3. Lorsque les objets, appartenant à des map non visibles ou dechargées, ne sont plus visibles, ils sont retirés du Vector DrawableScroller::drawableObjects_ et aucun code ne permet de les reafficher
        cf. DrawableScroller::HandleVisibleAreaUpdated => ce qui est insuffisant dans le cas des objets à faible parallax (faible mouvement / camera)
-----> 14/11/2019 : drawablescroller a desormais son propre node. le deplacement des drawableobjets est simplifié puisqu'il suffit de deplacer le node en fonction de la valeur de parallax_.
------> en mode World, les drawablescrollers ne peuvent pas suivre les Y de l'ellipse : plus le parallax est faible et plus il y aura un decalage entre la map des drawableobjects visible et la map visible
------> pour permettre le changement de zone, il faut chercher un nouveau drawableobject des qu'un drawableobject sort du visibleRect,
        remplacer le drawableobject sortant par le nouveau et le repositionner à droite de l'ecran si sorti à gauche et vise versa. (principe de GEF_Scrolling).
        le nouveau drawableobject aura la zone de la map courante.
-------> DrawableScroller::HandleVisibleAreaUpdated() devient obscolete.
------> pour permettre le suivi des Y, il faut modifier cette coordonnée à chaque déplacement.
-------> 19/11/2019 : Ok modification de DrawableScroller::HandleUpdate() qui est scindé en deux Handles spécifiques => DrawableScroller::HandleUpdateFlatMode() et DrawableScroller::HandleUpdateEllipseMode().
--------> DrawableScroller::HandleUpdateEllipseMode() met à jour à chaque update la position Y en fonction de X sur l'ellipse ou bien sur le Floor (cf. MapTopography::GetY(float x) ).
--------> 05/12/2019 : Ok Lorsque la map est sous l'ellipse, completer par des drawableobjects fixes (foreground 2) de l'ellipse jusqu'au floor de map.
--------> 05/12/2019 : le mode ellipse est fonctionnel hormis sur les bords de l'ellipse : faire un clamp des X dans la plage de l'ellipse.

- 19/09/2018 : ajouter RenderShape (ScrollingShape sans parallax)
=> OK !

- 18/09/2018 : faire des test pour desactiver les Objecttiled et les remplacer par les ScrollingShape de Map
=> desactivation des ObjectTiled avec la directive USE_TILERENDERING (les directives RENDER_OBJECTTILED et RENDER_VIEWBATCHES peuvent etre utilisees si USE_TILERENDERING est actif)
==> permet de desactiver completement les ObjectTiled (remplacement dans Map::Resize() de l'ObjectTiled par l'ObjectSkinned uniquement)
==> les ObjectTiled sont alors remplacer par des RenderShapes
==> MapCollider est scindé en PhysicCollider utilisé pour générer les collisionShapes et RenderCollider utilisé pour générer les RenderShape
==> le remplacement du render d'ObjectTiled par les RenderShapes imposent de se separer du decoupage par chunk des maps
=> RenderShape Shader terrain : Mixer plusieurs textures
    s'inspirer du Sample 23-Water pour mixer le terrain (voir Shaders/GLSL/TerrainBlend.glsl + Materials/Terrain.xml + Techniques/TerrainBlend.xml)
    le shader utilise une texture RGB (3 composants) pour mixer 3 textures (soit 3 type de terrain maximum).
    on peut encore mixer avec le 4eme composant (alpha), et inclure une quatrieme texture.
==> creation de Urho2DBlend.glsl
===> Utilisation d'une texture atlas plutot que de plusieurs textures
====> probleme d'edge bleeding ou seam : utilisation de GLSL::texelFetch ald GLSL::texture pour eviter ce probleme
=====> probleme avec les mipmaps en changeant de zview
======> remplacement dans le fragment shader de GLSL::texelFetch par GLSL::textureGrad qui permet de s'affranchir de la gestion des lod
===> Urho2DBlend scinder en 2 shaders : Terrain2D et Terrain2DAtlas
====> Terrain2D utilise la technique du Blend de 3 textures Terrain => material terrain.xml
====> Terrain2DAtlas reuni 4 textures de terrain dans une seule     => material terrainA.xml
=====> utiliser USE_RENDERSHAPE_WITH_TERRAINATLAS pour la version Terrain2DAtlas
====> ces 2 shaders utilisent une WeightMap pour les variations de terrain
=====> la texture WeightMap est ajustée aux dimensions d'une Map du World2D par le parametre MapWorldSize (doit être mis à jour en fonction du scale ou de la dimension de carte)
===> Intégration des Decals (BorderTile) dans RenderShape.
====> Option1 : Réaliser un fragment shader unique pour tile de terrain et tiles de bordures : comment switcher de tile en fonction du vertex ? Abandon
====> Option2 : Réaliser un fragment shader spécifique Terrain2DAtlasBorder pour les bordures + ajout d'un batch
=====> les Tiles de Bordures sont spécifiés par la tilesheet "Levels/tileset_borderA.xml" qui est intégré au terrainatlas "atlas_arena.xml" (terrainid=4) ...
       l'ajout de Batch dans RenderShape se fait à l'aide de ShapeBatchInfo(material, borderterrainid=4 (version RenderShapeAtlas) ou =0 (version Blend sans Atlas)
       cf RenderCollider::CreateRenderShape()
======> OK le 03/10 pour OpenGL 3.0 et 3.0 ES (Desktop et Mobiles)
=> Gestion des bordures de map
==> 11/10/2018 : AddBorderOnMapBorder() utilise directement les featuredMap et non les contours ou bien les ConnectedMaps
=> Skipper les Plateforms pour les RenderCollider en Innerview (pas d'effet complementaire sur les plateforms) => OK
=> Les Plateforms interieures doivent être rendu dans le layer FURNITUREINNER_LAYER.
==> pour cela, ne pas intégrées les plateforms au RenderCollider des Murs.
===> créer un RenderCollider indépendant pour les Plateforms avec le mode PlateformMode
====> OK le 12/10/2018 !
=> Crash dans le MapStorage en activant les LoadingLists ald des Vector (option USE_LOADINGLISTS), lors de l'usage d'un GOC_Portal
==> comprendre pourquoi et y palier si possible : les loadinglist permettent la gestion conforme du load/unload maps (PushFront/PopFront).
===> ok probleme de boucle sans fin dans MapStorage::UpdateMapsInMemory résolue. USE_LOADINGLISTS peut être déployée.
====> OK le 15/10/2018 !

- 15/09/2018 : modification de AnimatedSprite2D::UpdateTriggers() permettant de cacher les physicTriggers iso SPRITER.

- 10/09/2018 : suite à l'ajout du bodycollider, les lames sont bloquées lors d'un tir vers le haut
=> modification de ABI_Shooter::Use => utilisation de Drawable::GetWorldBoundingBox()

- 10/09/2018 : Collectable => lors de spawn de Collectable staticSprite, le collider est positionné sur le hotspot.
=> prendre comme hotspot le centre du sprite
==> ajout de StaticSprite2D::GetDrawRectangle() & StaticSprite2D::GetWorldDrawRectangle()
===> modification de GameHelpers::SetCollectableProperties()

- 10/09/2018 : BodyExploder => le centre des colliders des parts sont situés au niveau du hotspot; si le hotspot vaut (0.5,0.5) alors le colliders est bien centré sur le sprite
=> autrement il y a un décalage
==> voir pour décaler en prenant compte du hotspot dans AnimatedSprite2D::GetLocalPositions()
===> modification de la fonction permettant de récupérer le centre du sprite comme position
====> desactiver pour le moment
===> changement de nom AnimatedSprite2D::GetLocalPositions() devient AnimatedSprite2D::GetLocalSpritePositions()
===> sinon mettre les hotspots dans SPRITER toujours à (0.5,0.5)

- 10/09/2018 : Suite aux modifs BEHAVIOR du 06/09 pour le spawn des bombes, le Vampire cast ses pouvoirs dans la mauvaise direction => probleme de flippingX
=> dans GOC_Animator2D::SpawnEntity() => ajout de l'orientation par défaut pour la rotation + modification de GameHelpers::SetPhysicProperties()
==> OK le 10/09

- 05/06/2018 : une seconde WEAPON en slot WEAPON2 ne peut plus être équipée
=> voir Preloader.xml
==> apparement la category de base "weapons" ne suffit pas : il faut spécifier aussi "swords"
===> la weapon n'est pas active en mapping avec newskel2. a la place c'est le pistolet qui apparait
====> importance de l'ordre dans le fichier SPRITER dans le charactermap WEAPON2 l'arme doit être en premier
===> correctif également apporté à AnimatedSprite2D::SwapSprite();
===> dans SPRITER ne pas oublier de regler le hotspot par defaut pour l'arme
====> OK le 06/06/2018</>

- 25/05/2018 : retour sur les elements d'armures => skeleton avec armure petit affiche 2 torses (1 sur la ceinture centrale)
=> 28/05/2018 : OK modification de armurepetit2.scml => suppression du second folder et réduction à 3 items uniquement

- 22/05/2018 : les casques lizard ne correspondent pas bien avec la tete de newskel2
=> adaptation des casques
=> Ne pas oublier après modification des Sprites dans Inkscape puis creation de la SpriteSheet via ShoeBox de modifier la feuille.xml avec les hotspots (FrameX,FrameY)
==> OK !

- 22/05/2018 : Modifier le nombre d'elements d'armure :
=> pour petit torse + 2epaules + 2epaules differentes en fonction de l'animation
=> pour lizard torse + 2epaules + 2ceintures gauche+droite
=> pour skel torse + 2epaules + 1ceinture centrale
==> le probleme : l'attribution est statique => la ceinture centrale de skel va se retrouver sur lizard aligner sur la ceinture droite
==> l'attribution statique se fait à partir du character map "Armor" (dans l'animatedsprite) ce qui implique une modification du fichier scml pour mettre dans le bon ordre les elements d'armure
===> Solution 1 : il faudrait plutot creer un schéma de montage avec slot
     l'animation "profil" pourrait servir de schéma comme c'est déjà le cas avec AnimationEquipment (UIC_EquipmentPanel)
     à cela pret qu'il faut associer chaque element (armure01 sprite2d) à un slot (torse, ...)
===> Solution 2 : ajouter un nouvel element "armurebassin" dans le charactermap "armor" (vide pour "petit" et "lizard", rempli avec armureskel02)
====> OK 22/05/2018 solution temporaire appliquée !

- 17/05/2018 : Le changement de pivot sur Lizard (sur la ceinture gauche) (pssage de pivot 0.5, 0.5 à un quelconque) => génére un décalage
=> probleme avec le characterMaps et le changement d'animationSet dans animatedSprite.
==> pas de probleme dans Sample::Urho2DSpriterAnimation avec ce set
===> vérifier dans Frombones lors du changement d'avatar, le bon reset du charactermapping notamment le spriteinfomapping qui garde pour un meme sprite les positions precedement utilisées
sur un autre animationset.
===> en desactivant les deltahotspot dans animatedSprite, lizard a de nouveau son armure bien positionnée mais les autres animationset sont décalés (petit avec casque).
====> les deltahostspot sont donc nécessaires
====> les Sprite2D* ne sont pas les même entre la version Slot Collectable et le Sprite2D de l'AnimationSet de l'avatar.
=====> En changeant le hotspot de ceinture_01 dans armorlizard.scml pour qu'il soit le meme que dans lizard.scml, tout rentre dans l'ordre pour ce sprite
==> OK le 22/05/2018

- 24/04/2018 : générer des entités avec des tailles, des charactermaps differentes, voir des teintes differentes
=> commencer par une variation de taille de 0.8f à 1.2f
==> introduction de scaleVariation dans GOTInfo et ObjectCategory
=> RAF : utilisation de teintes
==> créer des charactermaps standard (Head1, Head2, Head3, etc...) pour l'ensemble des monstres
===> OK le 03/05/2018 pour skeleton
=> pb avec les nouveaux set de skeleton avec l'enregistrement dans GOC_Animator2D des AnimInfoTable en Multi-Entities
==> il faut lors de l'enregistrement dans Spriter mettre les animations dans le même ordre pour chaque entity et mettre les animations spécifiques en fin de liste
===> OK le 03/05/2018 : modification de GOC_Animator2D_Template::AddAnimationSet() + ajout GOC_Animator2D::UpdateEntity

- 10/04/2018 : ajouter les tremblements de terre
=> GameHelpers::ShakeNode(camera, duration, amplitude)
==> 25/04/2018 : premier test sur la CAMERA non concluant car la camera ne suit plus l'avatar pendant le quake
===> ne pas utiliser l'objectanimation mais un handler sur scene => reprendre et modifier la position de la camera à chaque step
====> ok creation du component GEF_NodeShaker

- 22/04/2018 : Crash en TestMode en Map(13,-16) AddBackScroller->PolyTriangulate
-> analyser la map sans backScroller
==> Gestion des erreurs dans fastpoly2tri.h => MPE_EdgeEventPoints et MPE_PolyTriangulate
===> plus de crash atm

- 15/04/2018 : Le Grapin collectable ne s'affiche plus. il suffit de le dropper de son inventaire pour reproduire le bug
=> Pb de BoundingBox AnimatedSprite2D
=> remplacement par StaticSprite => OK !
==> la rotation exprimé en Quaternion et donnée dans Object\weapons-grapin.xml n'est pas pris en compte
===> 17/04/2018 OK : dans Map::AddEntity => GameHelpers::SetPhysicProperties() => desactivation de la rotation par défaut de 0° provenant du PhysicEntityInfo
=> voir pourquoi les collectable AnimatedSprite pose pb

- 07/04/2018 : decalage des griffes chez chapanze
=> apparu avec le changement de scale (texture plus petite) avec spriter => il doit falloir revoir au niveau d'animatedSprite2d mais d'abord vérifier dans spriter
==> OK 16/04/2018 : juste à resize demi les griffes (ct un oubli)

- 13/04/2018 : pour les furnitures : pouvoir selectionner au hasard une entité de base
=> ok, correctif dans AnimatedSprite2D => l'animation etant reseté automatiquement, modification de SetSpriterEntity pour mettre l'animation courant par défaut.

- 23/03/2018 : dans spriter, après avoir sauvegarder un projet à une autre taille, les tags pivot_x et pivot_y dans les animations disparaissent
=> ce qui entraine des decalages dans certaines animations (par exemple les flammes arriere de redlord)
==> garder bien l'original pour permettre la recopie de ces tags au besoin sur le nouveau projet (les pivots sont normalisés donc on peut recopier)
=> voir si une option existe pour éviter ces problèmes

- 23/03/2018 : ajout dans Urho3d de format de SpriteSheet pour Spriter (json a renommer sjson en sortie de Spriter).
=> Ce format utilise la rotation à 90° pour gagner en place .attention en utilisant ce format de bien modifier la metadata image en fin de fichier sjson avec le bon repertoire au fichier en l'occurence "Textures/image.png"
==> dans Urho3d le code n'est pas optimale pour les rotations. mais le taf est fait.
==> ne pas oublier de mettre à jour material et objet

- 20/03/2018 : probleme de "blackedge" qui flip et qui se déplace sur l'écran
=> voir si il s'agit des nuages
=> remplacer les GEF_Scrolling par des scrollingShape
==> OK 21/03/2018 : Ajout du ScreenShape Mode dans ScrollingShape : Test en cours
===> 10/04/2018 : aucun probleme de blackedge avec les nouveau ScrollingShape

- 19/03/2018 : lors de l'ajout/suppression de tiles mettre à jour les backscrollers
=> OK le 19/03/2018

- 06/02/2018 : Ajout de ScrollingShape : utile en INNERVIEW pour avoir un background scrollant à l'infini

- enlightment : en donjon avec lumiere ON, non prise en compte de la couleur des tiles appliquées dans les batches
=> OK (04/08/2017) : remplacement de technique DiffLitParticleAlpha2 dans les materials, prenant en compte le VERTEXCOLOR

- Resize Windows : probleme de recentrage vers 0,0,0
==> OK (03/08/2017) : Correctif de Game::ResetScreen, recentrage uniquement dans Game::Start

- pb layer GEF_Rain : en InnerView les gouttes sont à l'intérieur des murs si Droplet setlayer Droplet != layer-9
-> vérifier les layers & viewmask
==> OK, refactoring ViewManager :  la camera utilise les viewMasks, les objets utilisent des layerMasks (1 layer == layermask) et les effects (rain,cloud) utilisent des effectmasks.

- ajouter des effets lors du changement d'avatar
=> OK

- pb griffe chapanze ne se supprime plus (goc_animator, goc_destroyer)
=> OK : propriété non déclarée GOT_Effect

- pb character mapping avec GOT_Lizard :
-> casque ne s'affiche pas directement, seulement apres le changement d'avatar GOT_Petit
-> armure affiche mal celle du GOT_Petit
=> Correction dans AnimatedSprite2D : swapSprites + hotspot => ajout du deltahotSpot dans SpriteInfo, correction des hotspots des armures à (0.5 0.5),
    pour les casques hotspot sur les yeux. pour les armures penser à bien modifier les SCML des collectables


*/



/** ======= **/
/** SOUNDS  **/
/** ======= **/

/* TODO
------

- 06/06/2018 : les sons sont long à poper (décalage entre l'action et le son d'1/2sec environ) (exemple le feet)
=> vérifier la cascade de code

- 24/04/2018 : changement dynamique des musiques d'ambiance en fonction de la zone (cave,dungeon,exterieurs) et du climat (weather ...), des actions (combat, marchand, exploration)

*/

/* DONE
------

- 23/08/2018 : Correction crash Object::Sounds
=> Clear les Sound Templates avec les SharedPtr(Sound> avant de quitter

- 18/04/2018 : modification de GOC_SoundEmitter pour enregistrer les sounds
=> utiliser les Waves et non plus les OGG (qui utilisent trop de ressources)
==> reactivation des sons des monstres

*/



/** === **/
/** UI  **/
/** ==== **/

/* TODO
------

- 10/11/2023 : Permettre le deplacement de l'avatar durant la selection dans l'UI
=> pour cela, il faut utiliser le Joystick Hat uniquement pour l'UI avec Joystick Reset
==> OK : creation de static void UIPanel::SetAllowSceneInteraction(bool enable)

- 10/11/2023 : Parametrer 2 nouvelles touches Prev/Next pour le deplacement dans les panneaux UI.

- 08/11/2023 : AbilityPanel
=> en multiplayer sans multiview, pb de position de l'abilitypanel pour chaque joueur car centré en haut et trop gros. il faudrait trouver un autre systeme comme pour la selection des personnages.
==> en mode un joueur garder l'abilityPanel tel quel.
==> en multijoueur la remplacer par une version petite qui poppera au besoin à coté du Panneau de Status. Touche à définir.
===> OK : remplacement de Actor::Vector<WeakPtr UIPanel /> panels_ par un HashMap plus facile d'utilisation pour l'enregistrement nommé de panels
===> dans Player::CreateUI positionner AbilityPanel en fonction. Ajout de la propriété UIC_AbilityPanel::popup_ qui permet d'afficher en mode popup en mode multiplayer.
===> 10/11/2023 : OK en mode multijoueurs, le panel est affiché en popup à coté du Panneau de Status.

- 08/11/2023 : ajouter une dropdownlist pour l'activation du multiview dans Options/Joueur
=> ne pas activer en API Vulkan pour le moment
=> OK

- 08/11/2023 : probleme de font pour l'affichage des Touches lors de la configuration des touches clavier dans les Options
=> ajout de OptionText16_NoL10 qui utilise BlueHighway.ttf qui dispose de tous les caracteres necessaires.
=> RAF : attention ça rajoute beaucoup de batch ... à terme mieux modifier les polices "aby32,22.xml..." mais bon le menu Options est lancé en pause ... pas d'impact directe sur les performances en jeu.

- 07/11/2023 : ajout de la gestion des UIPanel avec le joystick
=> OK : UISlotPanel::OnKey prend en charge cette gestion avec UIPanel::GetKeyFromEvent(), UIPanel::GainFocus() et Urho3D::UI::SetHandleJoystickEnable
==> pour CraftPanel, ajout de UISlotPanel::endSlotIndex2_ et modification UISlotPanel::OnKey et UISlotPanel::UpdateSlotSelector pour gerer les deux sections differente "Material" et "Tool"
==> Modification de PlayerCraft.xml autrement le slotSelector se met dans l'entete (passage en Layout Free pour la fenetre principal à l'instar de PlayerInventory.xml)
=> RAF : les dérivés UIPanel restants JournalPanel et MissionPanel : Modifier Start et ajouter un handle OnKey.

- 30/01/2023 : lorsque l'avatar meurt et apparition de la messagebox "recommencer", si l'on ouvre les options et que l'on quitte, le jeu ne quitte pas et pas possibilité de revenir en arriere : bloquage du jeu.

- 11/11/2022 : les cursors sur UI_WorldMap sous Android ne sont pas affiché => ce qui est normalement puisque pas de curseur lorsque touchEnable_
=> utiliser E_TOUCHMOVE pour afficher le curseur si sur un element UI. et E_TOUCHEND pour cacher le curseur.

- 10/11/2022 : Les dialogue du marchand ainsi que le point d'exclamation de s'affiche pas sans fluidenable.
=> le LAYERFRONTSHAPES fonctionne en pass "front" qui n'existe pas dans le renderpath utiliser sans fluidenable.
==> mettre les dialogues et les textes associés dans de nouveaux LAYERMATERIAL : LAYERDIALOG et LAYERDIALOGTEXT qui seront en pass "alpha"
==> RAF : Text3D utilise le shader Text, sous vulkan il faudrait utiliser un autre shader qui ecrit sur fragColor2 pour eviter de surcharger Text.
==> lorsque fluidenable, les dialogues sont maintenant sous l'eau (OK) mais aussi sous les decals de la pass "Front" (NOK).
===> ne pas mettre les decals de premier plan en "front" => modification ObjectTiled
==> Au final, les Dialog seront definitivement au premier plan.
===> OK : Creer une pass "Dialog" apres le "Front" modification des 2 RenderPaths et annulation des modifications precedentes.

- 09/11/2022 : le double-clic sur potions ne fonctionne pas sous RPI4 ?
=> nonreproductible sous ubuntu avec une resolution plus basse et pleine ecran.
==> voir le double-clic sous RPI si operationel.
=> fonctionne sous RPI4 CrossCompile. Refaire un essai de compilation sous RPI4 natif.
==> verifier la taille des elements UI qui pourrait se mettre dessus apres resize en "640x480".

- 05/11/2022 : ajouter la position des Actors dans la MiniMap.
=> OK : ajouter GO_AI_None dans GO_Entity utilisé dans UIC_MiniMap::PopulatePoints()

- 19/02/2020 : Ajouter le double-clic dans l'inventaire et dans l'equipement permettant d'utiliser un objet
=> chaque objet possède une valeur d'usabilité soit une valeur finie (1-255) ou bien infinie (0)
==> à chaque utilisation la valeur (charge) est décrémentée
==> definir les conditions d'activation d'une charge :
    -> Stock : activable par double-clic dans le BagPanel (utilisation d'une potion),
    -> Equip : activable par double-clic dans l'EquipmentPanel (torche à enflammer)
    -> DropIn : activable par drop sur item du BagPanel ou de l'EquipmentPanel (ex: torche enflammée sur item)
    -> DropOut : activable par drop sur entité de la scene
==> definir les effets d'une charge :
    -> Type : Vie, Mort, Feu, Eau, Matiere, Vide, Temps
    -> Quantité, Durée (cf EffectType et EffectCount ?)
    ex : Potion Soin(type=Vie), Potion Poison(type=Mort), Torche(type=Feu)
==> definir les categories et/ou les types d'objets sur lesquels s'applique l'objet/l'effet
==> ne pas regrouper dans l'inventaire les memes items mais de charges differentes
===> voir pour modifier Slot, GOC_Inventory et GOC_Collectable
=> 26/05/2022 OK : ajout de UIC_BagPanel::HandleDoubleClic pour les items utilisable du BagPanel.

- 04/12/2021 : les armures et epees ne se groupent plus dans l'inventaire. Est-ce un comportement voulu ?

- 12/03/2021 : lorsque ECHAP, il ne faut pas que cela ferme le StatusPanel sans pouvoir le rouvrir autrement qu'en appuyant sur A.
=> en sortant du Menu en mode PlayState retablir les panneaux qui étaient précédement ouverts.
==> cf UIC_StatusPanel::OnEscapePanel
===> voir pour enregistrer les panneaux precedemment ouverts => modifier UIC_StatusPanel::OnRelease()

- 18/12/2020 : revoir le mainmenu
=> remplacer world par "adventure", mettre en deuxieme pierre juste en dessous arena
=> lorsque "adventure" est cliquée si une sauvegarde existe, afficher le choix entre "continue" et "new" sur les pierres du dessous autrement lancer directement en new.

- 16/07/2020 : ajout des enemies dans la minimap
=> pouvoir ajouter les furnitures tel que les portal ou les outils
=> permettre l'update de la minimap lorsque des tiles sont modifiées
==> ajout de Map::SetMiniMapAt(int x, int y) et de l'event MAP_UPDATE

- 08/07/2020 : modification de UISlotPanel et de tout ses classes filles
=> creation de GetFocusSlotId et de OnDragSlotIn à tester
==> lors du drop dans inventaire il faut pouvoir automatiquement regrouper les items de meme category dans le meme slot si la quantity maxi du template le permet.
===> ct le cas dans la précédente iteration.
===> dans UISlotPanel::OnDragSlotIn, utiliser AddCollectableFromSlot avec strictmode=false pour permettre le test des quantity dans le template quelque soit le type enregistré dans le template

- 11/05/2020 : les panels doivent se repositionner en cas de redimensionnement de la fenetre de jeu
=> pour le positionnement : Ajout de PlayState::HandleScreenResized() Player::ResizeUI() et GameHelpers::ClampPositionUIElementToScreen()
==> RAF

- 25/04/2018 : Checker pour les marchands si assez d'argent pour acheter les objets du Player

- 10/04/2018 : Simplifier l'UISlotPanel::HandleSlotDragEnd() : le code semble lourd mais fonctionne.
==> Modifier "int GOC_Inventory::AddCollectableFromSlot()" pour retourner un tableau des slots remplit ce qui permet de ne pas faire un UpdateSlots mais plutot un sendevent ciblé.


*/

/* DONE
------

- 25/05/2022 : le ScissorTest pour les listviews, console et dropdownlist ne fonctionne pas encore sous VULKAN
=> voir pour implementer le ScissorTest.
==> 25/05/2022 : OK.

- 22/03/2021 : UIElement::SetEnableDpiScale() n'est pas nécessaire. A supprimer. la feuille Game_Equipment.xml sera à générer pour chaque resolution dpi. pour le moment mdpi et hdpi sont faites.
=> les feuille d'UI ont été revue pour s'adapter correctement en hdpi
==> les resultats sont correctes sur mobile 6.52inches.
=> Game_Equipment.xml est maintenant stocké dans le sous repertoire UI pour chaque résolution dpi.

- 13/03/2020 : generer la texture et les fichier .xml (fontes et spritesheets) pour le game_ui
=> y integrer toutes les fontes necessaires
=> les frames pour windows et boutons, le separator, les etiquettes monstres, les boutons abilities, la barre de vie, l'icone life et money et bouton equip, map, les collectables
==> la dimension des textures sera de base en 1024x1024 pour l'mdpi (160dpi)

    ldpi 	Resources for low-density (ldpi) screens (~120dpi).
    mdpi 	Resources for medium-density (mdpi) screens (~160dpi). (This is the baseline density.)
    hdpi 	Resources for high-density (hdpi) screens (~240dpi).
    xhdpi 	Resources for extra-high-density (xhdpi) screens (~320dpi).
    xxhdpi 	Resources for extra-extra-high-density (xxhdpi) screens (~480dpi).
    xxxhdpi Resources for extra-extra-extra-high-density (xxxhdpi) uses (~640dpi).

      768x768 (0.75x) for low-density (ldpi)
    1024x1024 (1.0x baseline) for medium-density (mdpi)
    1536x1536 (1.5x) for high-density (hdpi)
    2048x2048 (2.0x) for extra-high-density (xhdpi)
    3072x3072 (3.0x) for extra-extra-high-density (xxhdpi)
    4096x4096 (4.0x) for extra-extra-extra-high-density (xxxhdpi)
===> OK pour ldpi et mdpi
====> 13/04/2021 : pour game_equipment il faut pouvoir indiquer à l'UI le scaling de tous les elements des panneaux qui sont suivant la resolution mdpi.
=====> ne fonctionne qu'uniquement pour les SCML.
======> essai d'un UI scaling avec UIElement::SetEnableDpiScale()

- 11/03/2021 : l'UIC_ShopPanel ne peut être déplacé. Les slots draggés se trouvent derriere ce panel.
=> OK : Remplacement de panel->SetVisible() par panel->ToggleVisible()

- 05/12/2020 : pour les devices TouchScreen augmenter de taille le StatusPanel.
=> Ok : ajout du factor GameStatus::uiTouchScale_ ajouté à GameStatus::uiScale_ lorsque GameStatus::gameConfig_.touchEnabled_ est activé.
=> OK sur Tablette.
==> A voir sur Mobile.

- 11/06/2020 : voir dans URHO3D pour gerer le scissor de façon a en profiter seulement lorsque c'est nécessaire (pas de perte inutile de batch)
=> utiliser UIElement::SetClipChildren(false) pour skipper le scissor lorsque non nécessaire
==> tous les UIElements derivés de Window, ScrollView et LineEdit ont le clipchildren_= true par défaut
===> mettre tous les panels en false
====> OK 12/06/2020 : Creation de GameHelpers::SetEnableScissor(UIElement* elt, bool enable)

- 09/06/2020 : Modification de Urho3D::DropDownList::OnShowPopup() permettant de ne pas automatiquement redimensionner en hauteur selon le contenu. Permet d'avoir un slider. (utile pour les resolutions)
=> OK : reactivation du scissor (qui avait été bypasser pour gagner en ui batch)

- 18/10/2017 : Créer UI Options (Controls/Sound) / Devel Options(DrawDebug/CreateMode)
-> 02/01/2020 : cf. SpaceMatch pour reprendre les options
--> ajouter option graphique Rendershape
--> ajouter option controller ScreenTouch Enable/Disable
-> 21/05/2020 : creation de OptionState avec UI fonctionnelle pour les langues
==> parametres à revoir
===> voir pour le nombre de joueur et les controles en priorité
====> ok quelques tests avec plusieurs joueurs local dont des CPU
=====> il reste beaucoup de choses à améliorer sur le controle des CPU (ordres à passer etc ...) cf Behavior
====> ensuite voire pour l'audio => OK
====> ensuite voire pour graphics
=====> voir pourquoi le changement dans Texture Quality et Texture Filter ne fonctionne pas correctement => OK
=====> finir le choix des controller, keyboard, joystick etc...
====> ajout aux resolutions d'une barre de défilement vertical avec un maximum de 5 resolutions affichables

- 07/05/2020 : ajouter une ui pour le switch rapide de characters
=> modification de la zone player status
==> ajouter l'image character au centre de la zone
==> creer une interface qui s'affiche avec les autres characters disponibles.
==> OK le 11/05/2020
===> retransferer le code dans UIC_StatusPanel
====> OK creation de UIC_StatusPanel
====> OK le 15/05/2020 transfert du code pour Life, Money et CharacterSlot

- 04/03/2020 : afin de reduire le nombre de batches coté UI, tous les collectables doivent être reunis dans une/deux textures au demarrage du jeu
=> Ajout de GameStatus::uiTextures_ et modification de GameHelpers::SetUIElementFrom() permettant de specifier une texture UI preloadée
=> Modification dans Urho3D::UI::GetBatches() afin de bypasser le scissor adjust
=> Modification dans Urho3D::UIBatch::Merge() permettant le Dump en continu pour debugguer les batches => il faut specifier UIBatch::dumpBatchMerging_ = true;
-> l'inventaire et l'equipement coutent bcp de batches, modifier game_ui.png pour regrouper les cadres, les slots, les croix, les titres de l'inventaire et equipment
--> l'inventaire vide coute 5 batches => reduire à 1
==> OK : inventaire vide = 0 batch OK => iso texture UIMAIN
--> l'equipment vide coute 5 egalement batches => reduire à 1
==> OK : equipment vide = 0 batch OK => iso texture UIMAIN
-> la minimap coute 6 batches, la reduire à 3 Batch maxi (1 batch pour le fond, 1 batch pour les layer, 1 batch pour les points)
==> OK : reduit à 2 batches en mettant le cadre et le point dans UIMAIN + en composant dans une seule texture toutes les images (une par viewid) generees par les Maps.
==> les collectables sont reunies dans la texture UIEQUIPMENT reduisant ainsi le nombre de batch, hormis le texte
===> pour le texte (il ne s'agit que de digit), voir pour mettre dans la meme texture UIEQUIPMENT ces 10 digits
====> OK le 09/03/2020: utilisation de l'appli bmfont pour generer le .png puis recoupe dans gimp pour en faire un sprite inserable dans ShoeBox => la fonte digit22 est integrée à game_equipment.png permettant de reduire les batchs
====> modification de Uho3D::Font et Urho3D::FontFace pour ajouter une texture Custom
====> la font generée par bmfont est composée d'un fichier .fnt et d'un .png : le .fnt est un xml. Changement d'extension .FNT=>.XML et ajout dans ce fichier du tag textureloadingmode qui permet de ne pas generer de TEXTURE
    puis ajout en manuel de la texture via Font::AddCustomTexture
====> ajout de Slot::UpdateUISprite() qui va prendre le bon sprite dans game_equipment.png (si pb de nom de sprite (pb correlation SCML et UI), utiliser alors le nom de l'objet comme nom de sprite)
====> RAF : ajouter plusieurs taille de cette fonte.
====> RAF : mettre à jour UIC_MissionPanel et UIC_ShopPanel et leur panel associé

- 05/03/2020 : lors du drop d'items, il arrive parfois que les items soient inclinés voir qu'ils passent meme à travers les murs et disparaissent (alors qu'ils apparaissent bien en dehors des murs...)
=> analyser ObjectPoolCategory::Resize, ObjectPool::CreateChildIn, Map::AddEntity, GameHelpers::SetPhysicProperties()
==> modification de GameHelpers::SetPhysicProperties() permettant de setter rotation=0
==> OK : correctif de PhysicEntityInfo()
===> Verifier si toujours des chutes/disparitions d'items droppés

- 04/03/2020 : la potion regen n'affiche pas le bon icone item. cf Slot => GameHelpers::GetSpriteForType() =>
=> Urho3D::AnimatedSprite2D::SetEntity() ne set pas le sprite, uniquement utiliser dans Urho3D::AnimatedSprite2D::SetAnimationSet()
==> Verifier Slot::Set(), GameHelpers::GetSpriteForType, GOC_Collectable::DropSlotFrom, GameHelpers::SetCollectableProperties(),
===> VOIR pour Reactivation de l'attribut "Sprite" dans AnimatedSprite2D permettant dans les attributs XML de setter le Sprite
====> en reactivant l'Attribut "Sprite", il faut obligatoirement l'ajouter dans tout les Objets Collectable.
====> pb : tout les animatedSprite meme non collectable (hors certains avatars tel que petit, eredot, champanze, lizard, skel) n'apparaissent plus meme en ajoutant l'attribut "Sprite"
=====> l'attribut "Sprite" est géré par StaticSprite2D et setté par la suite par StaticSprite2D::SetSprite().
    le code est spécifique pour StaticSprite2D => notamment utilisation de UpdateMaterial et de sourceBatchDirty_ = true qui pouuraient etre à risque pour AnimatedSprite2D.
======> creation de Setter et Getter pour l'attribut "Sprite" specifiques à AnimatedSprite2D
=======> resoud les problemes sauf pour les avatars tel que burros, vampire, rockgolem ... ceux qui n'ont pas d'equipment à priori.
========> tous ces avatars utilisent AnimatedSprite2D::UpdateSourceBatchesSpriter_OneMaterial()
=========> OK : correctif dans AnimatedSprite2D::UpdateSourceBatchesSpriter_OneMaterial() pour setter le material si vide à partir de l'AnimationSet

- 31/10/2019 : lors de la prise d'objet dans l'inventaire ou autre, il n'est pas evident de dropper certains objets dans une case (ex: katana, pistolet)
=> OK 28/12/2019 : modification UISlotPanel::HandleSlotDragBegin() : ajout SetPivot(0.5f,0.5f)

- 28/12/2019 : dans l'inventaire (bagpanel), lors du deplacement d'un objet bone sur une part differente de meme type, l'objet disparait au lieu d'etre remis dans son slot d'origine.
=> OK : modification UISlotPanel::HandleSlotDragEnd() : if (Slot::HaveSameTypes(slot, focusSlot) && slot.sprite_ == focusSlot.sprite_) ald if (Slot::HaveSameTypes(slot, focusSlot)) permettant de tester la part via le sprite

- 24/08/2018 : l'UIC_MiniMap devient un composant du cameraNode
=> le player l'active par l'UI
=> modification majeure du composant permettant un meilleur déplacement (plus de saccades) et ajout des entités

- 21/08/2018 : bug dans le mainmenu : pb de detection de la zone pour Arena ou Solo
=> utilisation de MarkDirty() si WorldBoundingBox est NaN

- 18/07/2018 : réduire le nombre de textures (cursor, icone vie ... à mettre dans gameui.png)
=> ok, ajout GameHelpers::SetUIElementFrom()

- 23/04/2018 : vérifier si les valuesToPopulate sont bien tous remplis même si l'inventaire n'est pas complétement vide
=> OK => création du GOC_Inventory::SetAutoPopulatedSlots() pour les marchands et les coffres

- 19/04/2018 : les marchands lorsqu'ils meurent perdent leur inventaire. Les ObjectPool doivent régénérer leur inventaire si vide.
=> correctif dans Player::OnTalkShowResponses() => player n'ayant pas de OnTalkBegin l'actorid n'est pas setté
==>> creer un handle pour le player TalkBegin
=> correctif dans Actor::OnDead() => ajout du Actor::RemoveActor
==> OK le 21/04/2018

- 15/04/2018 : UIC_MiniMap ne genere pas la bonne map à l'apparition dans le mode test.
=> voir s'il s'agit d'un pb de synchro avec les events ?
==> OK correctif dans UIC_MiniMap et Player::UpdateComponents() => ajout d'un GOC_Destroyer::UpdatePositions()

- 14/04/2018 : suite aux modifications Player/Actor => l'equipment du player pose probleme apres changement de scene (d'arena vers test par exemple)
=> Modification de la logique UIPanel::Set et du UIPanel::Start
=> OK !

- 10/04/2018 : avec 2 marchands avec dialoguemarkers actifs, si le joueur ouvrir un dialogue chez un marchand => desactiver le dialoguemarker des autres interactors potentiels
=> ok player est desormais bien verouiller avec dialogInteractor affecter des qu'un clic sur un marker
==> autre solution : gerer des listes de marker mais plus lourds et ne permet un bon affichage des markers en mutli-player local

- 08/04/2018 : Le dialogue n'est plus maintenu lorsque le player change d'avatar
=> surement les collider2D qui poussent à un TalkEnd.
=> pb également avec plusieurs marchands
==> le dialogActor_ est un ptr et non pas un ID
===> voir pour remplacer ce ptr par un ptr vers actor plutot que vers node (qui peut changer)
===> OK le 10/04/2018

- 18/10/2017 : Créer UI pour Marchand
=> 4/04/2018 : creation de PlayerShop
==> ajouter deux slotzones "shop et basket" drag&drop les items entre celles-ci => OK!
====> tagger dans basket comme achat ... => OK !
==> desactiver le drag&drop to scene => OK !
==> drag&drop d'inventaire ou equipement vers basket uniquement
====> tagger dans basket comme vente ... => OK !
==> calculer si la transaction est accepter par le vendeur
=> money(vente)+money(player) >= money(achat) dans un premier temps => OK !
=> on pourrait imaginer que le vendeur fait des efforts et baisse le prix de ces objets de quelques pourcents pour faire la transaction dans le cas ou affinité avec le player
==> 7/04/2018 OK pour le premier jet.

- 25/10/2017 : Créer le dialogue actor en mode sceneReplicationMode
=> 25/03/2018 : Creation de DialogueFrame (UI Actor) et de DialogueData (stockage et gestionnaire de dialogues)
==> ajouter l'interface pour modifier les messages lorsqu'une interaction se produit
===> lier à une IA qui dispose de l'acces au dictionnaire de messages
====> DialogueFrame communique avec la classe Actor par Events
==> installation de Wren (language de script) pour interpreter les commandes ou bien voir pour LUAJIT a la place
===> comment compiler et stocker les bytecodes pour utiliser le code compilé plutot que de reinterpreter/compiler le source à chaque commande ?
====> 03/04/2018 : premiers essais sans compile

- 18/10/2017 : Vérifier l'activation/desactivation du missionmanager lors du changement de gamemode (level->arena | test->level)
=> OK, modification logic de creation des panels dans Player::CreateUI()

- 27/03/2018 : les rigidbodies static ne suivent pas le déplacement de leur node
=> modification de RigidBody2D::ApplyWorldTransform() pour que le body prend la position du node.

*/

/** === **/
/** AI  **/
/** === **/

/* TODO
------

- 04/10/2021 : il arrive que certaines entités ne bougent pas meme lorsqu'elles se font taper dessus. Il faut alors changer de Map et revenir pour les reveiller.
=> AIManager surchargé ?

- 13/07/2020 : avoir la possibilité de changer de viewZ quand c'est possible (lorsque non bloqué par un mur) pour suivre un chemin ou une cible

- 08/06/2020 : modification de GOC_AIController pour permettre l'update en continue des player CPU
=> voir pour le double jump.

- 25/04/2020 : Pb Raignee GOB_FollowAttack
=> Raignee reste coincé dans les coins.
==> OK decomposer TOUCHWALL et TOUCHROOF sans else if
=> Raignee reste en FALL lorsque accroché à son fil et au plafond si la target en dans les pieces au dessus
==> OK pour le FALL continue lorsque sur le plafond : ne pas sauté si vel est nulle.
=> il faut appliquer ce code "Climber" dans GOB_Patrol pour que les Raignee ne restent pas bloquer apres le passage en GOB_Patrol

- 23/04/2020 : permettre le changement de behavior en suivant des conditions d'activation à définir.
=> modifier GOC_AIController : ajouter GOC_AIController_Template (commme GOC_Animator2D_Template)
==> 24/04/2020 : solution simplificatrice : ajout dans GOC_AIController de l'attribut XML  "Behavior Target" specifiant quel comportement utilisé lorsqu'une target est détéctée.
et de l'attribut XML "Detects Target" pour permettre la detection de target dans la boucle principale d'update (hors des scripts Behavior)

- 23/04/2020 : le detector renvoit tout objet détécté. Dans le cas de GOB_FollowAttack, il faut pouvoir filtrer et supprimer par exemple les BodyPart et les Items.
=> ajout de GOC_Detector::SetDetectedCategoriesAttr() attribute XML "Detected Categories"

- 22/04/2020 : le vol (vampire / Bat) n'est pas maitrisé (trop aleatoire)
=> l'order STATE_JUMP avec le WaitCallBack (attente de l'event GO_CHANGESTATE=STATE_JUMP ou STATE_FLYDOWN ou STATE_FLYUP) ne permet pas un deplacement fluide vers la target
    en effet, le GOB_FollowAttack::Update() est skipper et donc l'execution du code permettant le suivi du target (update des buttons CTRL_RIGHT_CTRL_LEFT et maintien du CTRL_JUMP) n'est pas réalisé.
==> dans un premier temps l'on peut reduire MAX_AIWAITCALLBACKDELAY qui est le delay max d'attente avant reset
===> il faut pouvoir executé le code de suivi sans attendre le changement de state.
====> OK : ne pas utiliser l'updateNeed et modification du code de GOB_FollowAttack::Update() pour permettre l'update du suivi en meme temps que l'attente de la realisation d'un order.

- 05/06/2018 : voir la possibilité d'intégrer des scripts Lua pour les AI Behaviors des mobs
=> ajouter un attribut "Behavior Script" dans GOC_Controller

- 11/05/2018 : ajouter le PathFinder pour les AI

- 08/11/2017 : GOB_Patrol doit anticiper si une chute se présente devant et rebrousser chemin

=> 10/04/2018 : Dialogue System
==> cf Dialogue utilisé pour le marchand

=> 10/04/2018 : Quest System
==> notamment des quetes pour debloquer des nouveaux avatars
===> conjuguer Dialogue avec le Systeme de Missions (cf. UIC_MissionPanel)
===> les missions doivent être proposées par des actors.
====> difficulté principale : généré des quetes cohérentes avec l'environnement généré MapWorld, placer les Actors en fonction de cet environnement
=====> Créer un Generator de Quetes et un Manager + UI Panel des quetes acceptées/en cours/finies etc...

=> 10/04/2018 : Cinematics System

=> 10/04/2018 : Commands System

*/

/* DONE 
------

- 21/04/2020 : mauvaise gestion de la logique pour la detection et maintien de la target
=> ajout pour GOB_FollowAttack de AInodeInfos::updateAggressivity gerer dans GOC_AIController::Update()

- 01/02/2020 : correctif Behavior GOB_Patrol : si blessé se retourne et attaque, ne parvenait pas à attaquer
car le subscribe à l'event CHANGEDIRECTION ne pouvait etre realisé car l'update control etait fait avant (donc l'envoi de ChangeDirection aussi via GOC_MOVE2D)

- 23/12/2019 : le troll saute continuellement
=> cf GOC_Destroyer::HasWallInFront => la position du troll est toujours dans le sol. son RigidBody2D n'avait pas de mass center setté.
==> OK le 07/01/2020 : ajout dans Objects/Bitroll.xml de <attribute name="Mass Center" value="0.0 0.8" />
==> il est nécessaire de reverifier que tous les objets ont bien un mass center setté

- 09/05/2018 : modifier les AI Behavior pour permettre l'utilisation des attaques power et shoot
===> utiliser ability. Chaque entity doit avoir une liste d'ability. l'AI change d'ability selon besoin (compteur, accumulation de puissance ...)
====> creer un component porteur des abilities => GOC_Abilities => utilisable directement sur le node par des mob qui n'ont pas d'actor.
=====> le 2/06/2018 ajout GOC_Abilities OK ! ajout du mode conditionnel d'activation des abilities ("avoir un pistolet pour pouvoir tirer") + modification GOB_Patrol

- 10/04/2018 : deallocation Actor => ajout static Actor::RemoveActors()
=> ne dealloue que les Actors non les Players
==> utilisation dans PlayState::EndScene()

*/



/** ========= **/
/** BEHAVIOR  **/
/** ========= **/

/* TODO
------

- 06/11/2023 : pb avec la vache pour tirer en continue avec le joystick

- 06/11/2023 : le button JUMP pour les joystick n'est pas toujours bien mapper malgré ce qui est afficher. il faut simplement cliquer sur l'ecran pour debloquer. Pkoi ?
=> le pb c'est que UI::HandleJoystick provoque JoystickState::Reset().
==> il y a focus sur l'ui : suppression du focus initial
===> il y aura encore le meme probleme des que focus sur un autre uielement.
===> pour le deplacement dans l'ui avec le joystick, il est necessaire de garder JoystickState::Reset()
====> il faudrait un bouton pour activer/desactiver le focus sur l'ui
====> ajout dans Urho3D::UI de SetHandleJoystickEnable qui permet de desactiver la gestion des joysticks par l'UI lorsque l'on utilise UIPanel et ses derivés.

- 06/11/2023 : en mode 2 joueurs multiview=false, le changement d'Avatar ne set pas correctement la ViewZ du joueur2
-> correctif dans Actor::ResetAvatar(), ajout de Actor::SetStaticViewZ

- 07/10/2023 : creer objets de jeu :
-> "poudre de pluie" : declenche la pluie
-> "une potion d'eau" : change le pouvoir de feu de la sorciere en pouvoir d'eau, et rend plus puissant les entités de type "eau"

- 11/04/2023 : ajout de la teleportation à partir de la worldMap en appuyant sur le bouton souris milieu.
=> Correctif apporté au GEF_Scrolling et DrawableScroller pour le recentrage sur la position de repop.
=> Correctif d'une boucle infinie dans MapStorage::UpdateMapsInMemory() et World2D::UpdateInstant()
==> RAF : ajouter l'abilité Teleportation. Lorsque l'ability est activée, le curseur sur la WorldMap changera : par clic sur un point de cette map.
===> ajout du curseur "cursorTP" et utilisation du Qual CTRL pour activation
=> RAF : pour la teleportation "instant", il faut aussi chargée les cartes dans la zone de visibilité au repop => cf GOC_Portal.

- 06/04/2023 : pouvoir planter les eliegor seed
=> passer par le CRAFTPANEL, ajout de la recette EliegorSeed + Potion, lorsque l'on jette l'EliegorSeed modifié alors elle doit se planter.
==> OK : ajouter une entité EliegorSeedPlus, modification de GOC_Collectable (ajout attribut wallcollide), modification des EventActions de GOC_Animator2D et ajout SpawnFurniture
==> pouvoir specifier le model à utiliser pour ltree => ajouter des attributs supplementaires pour les furnitures à planter via SpawnFurniture.
==> ajouter un symbol UI special pour le slot EliegorSeedPlus (un peu comme les épées avec effet) => ajout GOA::EFFECTID1 dans EliegorSeedPlus.xml et modification de UIC_CraftPanel::HandleMake pour permettre l'ajout d'effet au slot.
===> RAF : le plus ce serait de façon générale de pouvoir fabriquer de nouveaux types d'entités.
=> RAF : possibilité à l'eliegor seed de se planter toute seule, générant une nouvelle plante soit aggressive ou non.

- 06/04/2023 : ajouter le pouvoir "possession" à fantomette => il pourra controler un squelette en prenant forme d'ectoplasme dans le corps.
=> il faut que le pouvoir soit temporaire.
==> lorque le pouvoir est trop utilisé, de mauvais esprits pourraient venir avaler fantomette, le rendant inutilisable pendant un certain temps ?

- 31/03/2023 : en GameMod "KillAllMonster", il faut que les monstres "inoffensif/pacifique" ne soit pas à tuer.
=> Ok : EliegorSeed est mis en GO_AI_None(0x08) via les attributs.

- 31/03/2023 : la barre de vie du boss peut etre genante lorsque l'avatar est en dessous.

- 30/03/2023 : pouvoir interagir avec des monstres si l'avatar est d'une espece compatible ou bien à une faculté spéciale.
=> la transformation d'une espece vers une autre devra repondre à un schema : il ne sera possible de se transformer que dans certaines conditions (un peu comme une recette pour le craft)

- 18/01/2023 : encore des pb avec GOC_Portal ? dans certains portails, le transfer de la Camera n'est pas instantané : la camera se déplace d'une map vers une autre.
=> perte du focus ? verifier ViewManager::SetFocusEnable()
==> 19/01/2023 : quelques correctifs ainsi que dans MapStorage et MapWorld
- 21/03/2023 : Portal encore à corriger ; teleportement aborté avec défilement de l'écran et retour au premier portail sans possibilité de réativation de celui-ci

- 22/03/2023 : quand on a popper un boss et que l'on sort et rerentre dans la zone, il faut que la zone soit de nouveau active
=> OK : correctif dans BossZone::OnFinished()

- 07/03/2023 : ajout de livache
=> RAF : le power1 doit pouvoir arroser en continue tant que la touche est pressée : il faudrait deux animations power1 et power1continue qui prend le relai sur la seconde
==> voir pour l'interruption en cas de hurt.
==> modification de GOC_Animator2D::Dispatch, ajout de l'event GOC_CONTROLACTION2HOLD et essai avec nouveau Template AnimatorTemplate_PoweredWalkAttackerContinue
===> il faut créer un nouvel effet pour le lait et le dissocié de livache : comme pour bouledefeu explosion sur mur.
====> seulement il faut que ce soit un jet : il s'etire jusqu'à la distance maxi ou jusqu'à un mur et dans ce cas créé un splash.
=====> 26/08/2023 : Creation d'un nouveau composant SequencedSprite2D dérivé de StaticSprite2D
======> etirable en suivant un node avec l'attribut "Follow Owner" et retricissement avec l'attribut "Shrink"
======> RAF : integration à finir dans GOC_Animator2D pour permettre l'utilisation d'un SequencedSprite2D sans avoir besoin d'un AnimatedSprite2D
=======> GOC_Animator2D::CheckAnimatedSprites() devient GOC_Animator2D::PlugDrawables() et n'est plus la cause d'une non-initialisation du composant.
=======> modifications des GOC_Animator2D Actions, probleme de passage des parametres ?
========> OK 30/08/2023 : dans GOC_Animator2D::ApplyCurrentStateEventActions, le parametre principale à utiliser s'il existe sera action.param et non celui passer en parametre de fonction. ce qui
    evite l'utilisation des parametres d'Anim_Event transmis par AnimatedSprite2D quand l'action à dejà des parametres tel que ActionTo_Disappear ou bien Action_SpawnParticule (qui utilise directement EventTriggerInfo)

- 22/02/2023 : lorsqu'un boss est tué hors zone, il faut mettre fin à la zone effect (EffectAction) autrement des que l'on rentre dans la zone le boss reapparait.
=> une fois le boss tué, il n'y a pas le declenchement de BossZone::HandleBossDead, car dans BossZone::HandleUpdate() la sortie de la zone provoque un MarkFinished qui annule la souscription aux events, voir delete BossZone
==> OK : replacement de BossZone::HandleBossDead par static BossZone::RemoveBoss() qui est desormais utiliser dans GOC_Life quand le boss meurt.

- 13/02/2023 : reverifier la descente des plateformes par les AIs
=> il semble que cela ne fonctionne plus de nouveau
==> cf commentaire 20/12/2022.

- 30/01/2023 : corriger le drop des collectables de l'inventaire pour etre sur qu'ils ne rentre pas en collision avec l'avatar
=> modifier GOC_Collectable::DropSlotFrom et GameHelpers::GetDropPoint
==> OK 13/02/2023 : utiliser GOC_Destroyer::GetWorldShapesRect()

- 30/01/2023 : les potions verte apparaissent avec la mauvaise entité potion rose
=> cf GameHelpers::SetEntityVariation()
==> OK : ne pas setter l'entité si pas d'entityVariation (ce qui est le cas pour Potion)

- 29/01/2023 : en mode arena, si dans zone de boss et appui sur G pour gagner, la barre de boss reapparait dans le level suivant.
=> OK : mettre GOC_Life::SetLifeBar(false) dans GOC_Life::OnSetEnabled().
=> 22/01/2023 : meme probleme en world, si l'on quitte le playstate : cette fois-ci la barre s'affiche dans le mainmenu.
==> OK : ajout de GOC_Life::SetLifeBar(false) dans ~GOC_Life, le boss devait etre creer hors NodePool !

- 28/01/2023 : quelque rare cas d'erreur de mapping avec le skel avec l'epee flame et le pistolet.
=> difficile à reproduire. l'epee s'affiche mais n'est pas lié à la main et le pistolet ne s'affiche pas.

- 24/01/2023 : le unstuck peut detruire des entités directement visible devant le joueur. Il est tres bizarre de voir un monstre ne plus etre la l'instant d'apres ...
=> Il faut dans ce cas faire mourir le monstre plutot que de le destruire apres le stuck. Il faut bien differencier le Spawn de l'Update des positions : dans le premier cas => destroy, dans le second => dead.

- 20/01/2023 : en world, le decrochage des ponts ne fonctionne pas toujours.
=> Cela arrive car GOC_PhysicRope s'appuit sur des CollisionShape2D qui peuvent etre modifiées ou detruites
==> OK : Modification de GOC_PhysicRope pour ne plus utiliser les CollisionShape2D pour le SubscribeToEvent(MAPTILEREMOVED) : a la place utiliser le tileindex et le mappoint

- 18/01/2023 : Encore des problemes de Stuck dans les murs au pop (vu avec Bitroll, Mirubil, Lizard, Darkren)
=> OK : modification de Map::SetEntities_Add() pour eviter le adjustposition si spawn dans wall, de la meme façon que dans Map::AddEntity().

- 15/01/2023 : ne plus permettre d'action du joueur des que l'avatar est mort : evite le probleme de changement d'avatar au moment de la mort et de son repop...
=> OK : modification de Player::ChangeAvatar

- 26/11/2022 : pb avec la potion : elle ne peut etre utilisée lorsque l'avatar est trop proche d'un mur.
=> UISlotPanel::UseSlotItem
==> 15/01/2023 - OK : ajout de GOC_Destroyer::allowWallSpawning_ et modification de Map::AddEntity()

- 24/05/2022 : verifier les Lifes des mob avant et apres sauvegarde. Il semble qu'apres rechargement, les mobs meurent plus vite.
=> 13/01/2023 : probleme au niveau des attributs GOC_Life : test fait => non
==> probleme au niveau de l'equipement : test fait => non
==> ajout d'une tempo dans EffectsManager::SetEffectsOn via l'invulnerabilité : en effet les coups donnés provoqué trop de contacts et donc de dps dans un meme coup porté.
==> ajout de commands "life" "equipment" pour verifier en cours de jeu les status.

- 29/12/2022 : eviter que les grosses entités (tel que rockgolem, redlord, mirubil) dépassent des murs.
=> ajouter des shapes qui ne reagissent qu'aux murs. Faire attention à GOC_Destroyer::UpdateFilterBits() : utiliser CM_DEADINSIDEENTITY et CM_DEADOUTSIDEENTITY.
==> OK pour RockGolem
===> non suffisant pour Mirubil lors des attaques on voit depasser la trompe ou les bras sans parler des effets magiques et puis il parait desormais trop loin des murs
===> il ne doit plus effectuer une attaque si un mur est trop proche.
====> modification de GOB_FollowAttack::Update.

- 20/12/2022 : probleme pour effectuer GOC_Move2D::GoDownPlateform() avec les monstres, la liste de contacts est beaucoup plus important qu'avec l'avatar d'un player.
=> ajout d'un filtre pour INNERVIEW et FRONTVIEW mais insuffisant car en INNERVIEW (70) beaucoup de contacts sont egalement detectés qui ne sont pas des plateformes ce qui ne permet pas le GoDownPlateform.
==> pourquoi y a t-il tous ces contacts en Release pour les monstres ?
=> Changer l'algo qui pour le moment compte les contacts et active le GO DOWN si ce sont des contacts avec des shapes (Plateform) dont le viewZ est inferieur à celui de l'entity qui souhaite aller en bas.
==> OK 24/12/2022 : si il y a au moins un contact avec une shape Plateform alors aller en bas => desactiver aussi tous les autres contacts quel qu'il soit.
==> 14/01/2023 : il faut interdire de descendre d'une plateforme si l'entité a au moins un contact avec le ground.
===> OK 14/01/2023 : ajout condition dans GOC_Move2D::GoDownPlateform()
====> RAF 17/01/2023 : verifier avec RockGolem avec des plateformes car ca a l'air de poser encore des pbs.

- 18/12/2020 : ajouter des ponts en corde, passerelles, plateformes mouvantes.
=> 29/12/2022 : ajout escalier
==> les escaliers doivent etre orienter utilement pour pouvoir atteindre des plateformes ou des passages.
===> plusieurs configurations doivent etre possible : escalier simple, escalier double directe, escaliers multiples avec plateformes intermediaires ... escaliers en colimasson
==> il faudrait biensur avoir une routine permettant de monter les escaliers plutot que de sauter de marche en marche.
===> OK : simplement ajout de CONTACT_STAIRS et modification GOC_Collide2D::AddWallContact2D.
====> ajout d'animations UpStairs et DownStairs pour les entités marchantes ?
=> 05/01/2023 : ajout de pont (passerelle) utilisant GOC_PhysicRope
==> le positionnement est à revoir cf MapGeneratorDungeon::GenerateFurnitures et MapGeneratorDungeon::GetPositionFor()
===> le pont est positionné sur le bas de la tile vide (entrée dans chambre). Il faudrait le positionner sur la tile du dessous aligné en bas pour que le pont soit decrochable si l'on casse la tile.
====> 09/01/2023 : OK.
==> la longueur de la passerelle doit etre definie en s'appuyant sur la map : compter le nombre de tiles vides jusqu'au prochain mur selon la direction indiquée.
===> 09/01/2023 : OK, modification de AttachOnWalls()
=> 09/01/2023 : Trouver une solution pour activer/desactiver les ponts. GOC_PhysicRope::OnSetEnabled() doit bien desactiver sans recreer. Les contraintes semblent s'effondrer.
==> 10/01/2023 : solution pour l'effondrement des contraintes => mise à jour des positions des node et des jointAnchor => GOC_PhysicRope::UpdateLinkPositions()
===> faire la meme chose pour les modeles RM_ThrowableRope (le grapin s'effondre egalement si SetEnabled) et RM_FixedRope.
=> verifier que tout se passe bien avec SaveWorld
==> correctif pour les Lustres dont la chaine n'apparait plus apres un ObjectPool::FreePoolNode
===> 12/01/2023 : PhysicRope::CleanDependences ne peut etre appelé par ObjectPool car PhysicRope est dans un enfant du node FUR_Lustre.
====> déplacement de PhysicRope dans le node FUR_Lustre et modification dans le composant PhysicRope.
=====> modification de Urho3D::Variant pour les StringHash : il est desormais possible d'utiliser les StringHash dans les attributs à partir de String (cf Lustre.xml : <attribute name="AttachedNode" value="Lustre" />)
======> il n'y aura pas de reverse StringHash vers String par contre : ce qui va etre plus lourd pour lire un fichier XML sauvegardé mais plus rapide pour l'execution que de passer par des String dans les composants.
=> rajouter des frottements dans la corde du lustre pour que le mouvement s'arrete à un moment.
=> 12/01/2023 : En detruisant au niveau des tiles d'accroche, le pont est soit détruit directement (comportement normal pour les furnitures, mais non voulu pour les ponts), soit ne s'ecroule pas du tout.
==> Il faut que dans tout les cas le pont s'écroule.
===> le fait de detruire les tiles d'accroche c'est d'utiliser GameHelpers::SetTile -> World2D::DestroyFurnituresAt() -> World2D::DestroyEntity()
====> voir pour modifier World2D::DestroyFurnituresAt() : pour le moment skipper la destruction et laisser le pont s'écrouler.
=====> reste certains ponts à identifier qui ne s'ecroule pas => drawdebug à faire pour afficher les tileindex d'accroche des ponts
======> il s'agit de pont dont l'accroche est sur une plateforme (collisionBox)
=======> cf World2D::GetCollisionShapesAt qui ne doit pas renvoyer les collisionBoxes : ajout des plateforms
========> OK : modification de MapBase::UpdatePlateformBoxes pour envoi de l'event MAPTILEREMOVED
=> 12/01/2023 : pbs apparus sur les cheminees qui apparaissent en partie dans le sol. alignement changer ?
==> il s'agit d'une cheminee située dans une salle ovale ... le sol est situé entre les coordy=47 et 48
[Thu Jan 12 18:22:05 2023] ERROR: MapGeneratorDungeon() - GenerateFurnitures : room (type=Refectory rect=40 42 51 49) : try to put a FUR_Cheminee objectRange=3 2 at startcoord=41 48 endcoord.y=48 ...
[Thu Jan 12 18:22:05 2023] INFO: -> place a FUR_Cheminee in room=40 42 51 49 at start=41 48 coord=45 48 tileindex=3117 !
===> il s'agit donc d'une approximation de l'ovale generé par GameHelpers::GetPixelShape().
====> OK : ajout d'un patch dans MapGeneratorDungeon::GetPositionFor().
=> 12/01/2023 : certains escaliers se trouvent derriere des elements tel que les tentures ou des portails : on peut du coup y monter mais il devrait etre en avant plan par rapport aux autres elements.
==> les escaliers se trouve pour certains en BACKINNERBIOME (50) il faudrait alors que les tentures et les portails y soient aussi
===> suppression des escalier en BiomeCave. le probleme perdure avec Tronc1 et Tronc2 qui sont des elements Biome mais plateforme. les biome plateforme et les dungeon plateforme ne doivent jamais se masquer
====> actuellement, un Tronc peut se retrouver sous une tenture (qui est aussi une plateforme) ou bien sous un portal (qui n'est pas une plateforme)
=====> ce ne doit pas etre le cas : si un collider plateforme se trouve sous un drawable, il faut alors desactiver la plateforme. Mais si il est partiellement recouvert que faire ? il faudrait pouvoir modifier la longueur de la plateforme à la partie qui est visible.
======> le probleme n'est pas simple à régler : en paliatif, les tentures doivent toujours etre en arriere plan; les plateformes doivent etre sur un LAYERPLATEFORM et plus en BACKINNERBIOME
======> identifier les procedures qui mettent à jour les layers des drawables et le physic pour les plateformes
=======> cf GameHelpers::SetDrawableLayerView
=======> cf GOC_Destroyer::SetViewZ
=======> cf MapBase::AnchorEntityOnTileAt
======> à modifier MapGenerator::GenerateBiomeFurnitures() : si la furniture template a une plateforme alors modifier le layerZ en VIEWZ + LAYER_PLATEFORMS.
=======> OK
======> ensuite ca passe par MapBase::SetFurnitures() qui prend le layerZ de chaque EntityData pour le transmettre en tant que viewZ à ObjectPool.
=======> Il faudra ensuite modifier chaque attribut "GOA_LayerAlignement" dans les furnitures XML pour trier chaque furniture.
=======> RAF : dans l'ordre ascendant de layer : Tenture(-2), Cheminee(-1), Armoire(-1), Stele(-1), Table(-1), Tronc(0), Pont(0), Escalier(0), Marmite(1), Enclume(1), Lustre(1)

- 30/12/2022 : GOC_PhysicsGrapin renommmer GOC_PhysicRope

- 25/11/2022 : ajout de Spectii et Podomorphe
=> RAF : pouvoirs et animation dead.
==> voir pour que Spectii utilise un PhysicGrapin.

- prevoir des zones avec Boss : routine de fermeture de zone + AI Boss
=> Reprise 26/11/2022
==> voir dans Generator Dungeon pour identifier les zones de boss
===> choisir un boss correspondant à la zone/region.
===> identifier les zones de boss sur minimap et worldmap.
====> possibilité d'avoir un actor qui propose un defis avec choix du boss à affronter ?
===> fermer les acces.
===> commencer par un simple rockgolem flore pour tester les zones boss. il sera en Behavior Attack.
===> puis faire un boss "uber" rockgolem destructible : castle type avec decoration rockgolem + routine d'ajout de blocktile et pieges en interieur
===> à la fin de l'affrontement, ajouter le coffre recompense et ajouter le levier pour rouvrir les acces ?
===> les acces pourront toujours etre franchir si l'on detruit les blocktiles.
====> mais si franchissement de la zone boss definie alors fin du defi.
=> Ou mettre les datas pour les zones de boss. Dans Map ? Dans World2D ?
==> Ces Datas peuvent etre créées pendant le MapBase::PopulateEntities() et doivent pouvoir etre serializés
===> Creer une nouvelle structure BossZoneInfo à serializer dans MapData
===> il faudra aussi lié le Node Boss avec cette info avec un attribut, tenter GOA:BOSSZONEID qui sera un IntVector3 x=mapx,y=mapy,z=zoneid)
====> Attention : le MapData::AddEntityData() n'est plus utilisé pour les Entities (seulement pour les Furnitures cf commentaire 18/01/2021 categorie Editor)
=====> donc le node boss ne sera sauvé que par les nodeattributes ce qui devrait etre suffisant si le nodeattribute GOA::BOSSZONEID est bien spécifié.
=====> si le Boss meurt hors de sa zone et que la map de cette zone n'est pas chargée alors le BossZoneInfo ne pourra etre modifié donc pas de récompense etc... et il faudra de nouveau affronter ce boss.
=====> Cela laisse la possibilité de le tuer hors zone et si la map est chargée BossZoneInfo sera sauvegardé et la récompense pourra etre récupérée. Bien pour les joueurs malins qui ont tendu un piege au boss par exemple.
==> Dans Player::OnPostUpdate(), on checkera si le Player entre ou sort d'une zone de Boss. Ce qui déclenchera pour l'entrée une cinematique Camera et fermeture de Zone.
===> pour certains boss, la sortie de zone signifiera la disparition du boss et l'echec du défi.
==> 01/12/2022 : Premiers Resultats satisfaisants. Creation de la class EffectAction et class fille BossZone ou se situe la logique pour l'apparition du boss et la recompense quand il est mort.
===> OK : pop de Super coffre
===> OK : afficher les zones Effect en debug world
===> RAF : choix du boss, critere de selection en fonction de la zone et du niveau des joueurs ?
====> pour le moment, creer un random entre 4 boss (eliegorgolem / redlord / mirubil / darkren)
===> fermeture de la zone
====> ajout dans une liste, les blocs à ajouter pour les spawner progressivement.
=====> essai avec l'ajout de GameHelpers::SetTiles et MapBase::SetTiles.
======> tente de regenerer les MapColliders un minimum de fois : a lieu de le faire tile par tile.
=======> l'update des PhysicColliders ne se lance pas ? si on relance en specifiant un tileindex, cela fonctionne ... trouver la solution pb avec sLastContourId_ qu'il faut sauvegarder
======> changement de methode : au lieu de mettre à jour les MapColliders et de creer une zone fermée donc un hole mais qui n'est pas detecté comme un hole (pb à corriger), on va creer des Tiles independantes.
=======> on pourra ainsi ajouter des Blocks dynamiques si on le souhaite.
========> creation de MapBase::SetTileEntity().
====> lorsque l'on meurt et que l'on retourne au boss et qu'on le tue, les murs ne sont pas detruits.
=====> OK, ne pas stocker de Vector<unsigned/> blocksToAdd_ ou blocksToRemove_ dans BossZone mais les recalculer lorsque nécessaire.
=====> lorsque les boss apparaissent dans des room non rectangulaire, les murs pour fermer la zone ne sont pas adapter : il faut adapter MapBase::FindTileIndexesOnShape pour les autres PixelShape.
======> OK le 17/12/2022.
===> ajout d'une jauge de vie du boss
====> OK le 26/12/2022 : ajout de GOC_Life::SetLifeBar() : 2 mode possible UI ou Node (follow)
=> le dezoom initial avant fermeture de zone doit bien mettre à jour l'affichage. voir World2D et ObjectTiled World2D::cameraRect_
==> OK le 27/12/2022 : ajout de la directive ACTIVE_WORLD2D_DYNAMICZOOM
=> RAF : effet destruction des murs de background.
==>  voir pour changer le fond rock : il faut ajouter des DrawableScroller de fond qui soient interessant (fond noir avec cristal, cave avec stalactite ...)
=> 16/01/2023 : lors du repop de l'avatar, si repop en zone de boss il faut reactiver la zone.
==> OK : il faut reset Player::zone_ à la mort de l'avatar => ajout zone_.z_ = -1 à Player::Start()
=> RAF : 23/01/2023 : lors de l'entrée dans la zone les joueurs ne doivent pas se trouver sur les blocks de fermeture.
==> attendre que les avatars soient tous hors de ces blocks avant de déclencher la fermeture.

- 22/11/2022 : correctif dans Actor::ResetAvatar()
=> on s'assure du set des positions initial.
==> mais ne fait pas d'unstuck, à voir si valable : GOC_Destroyer le fait dejà mais il peut arriver que le unstuck n'y arrive pas et dans ce cas destruction du node.
=> resoud peut-etre le crash du 05/11/2022... A verifier .

- 05/11/2022 : Il y a eu un crash dans Player::UpdateAvatar() => dernier log en release :
[Sat Nov  5 18:41:55 2022] INFO: Player() - OnFire3 : change avatar ... index=7 numavailableavatars=24
[Sat Nov  5 18:41:55 2022] ERROR: Player() - UpdateAvatar : avatarIndex_=7 => change to avatar type=GOT_Avatar_Skeleton(3050507584) ... ensuite crash

- Modifier le vol pour que le player puisse diriger son vol via les touches déplacements, la touche saut sera utilisee pour donner une impulsion supplémentaire (04/08/2017)
=> 06/03/2022 reprise : ...

- 22/05/2021 : la couronne de pic d'EliegorGolem entre en collision avec les plateform. EliegorGolem est porté par la plateforme ...
cf les collisionCircle2D qui doivent être déclaré en ContactTopOnly.

- 24/05/2022 : pouvoir avec Buros casser les Furnitures (Pieges, table) et Infliger de plus gros degats sur RockGolem.

- 11/10/2021 : Permettre de collecter les monstres
=> rendre dynamique GOT::controllables_

- 06/10/2021 : lors de la mort d'un avatar en multi-joueur
=> soit permettre le respawn à coté d'un avatar vivant
=> soit mettre une tombe sur laquelle le fantome est lié.
==> Un avatar vivant peut venir recuperer le fantome et le squelette du mort et l'emmener dans un sanctuaire pour lui permettre de reprendre corps.
==> faire une stele RIP, faire un icone squelette, voir pour une animation de fantome (faire des essais de transparence cutoff sous spriter)
==> Stele ok
==> 17/11/2021 : fantome cutoff alpha ok (à nécessiter une refonte graphique et notamment l'ajout des RenderTargets dans AnimatedSprite2D).
===> ajout de Urho3D::Drawable2D()::SetLayerModifier() pour permettre l'affichage de la stele comme une furniture + devant les tiles de sol.
===> ajout de GOTypeProperties::GOT_Flippable : la stele ne sera pas flippable (a cause du texte rip)
===> modification GOC_Animator2D pour pouvoir gerer plusieurs AnimatedSprite pour le changement de states de la stele.
====> GOC_Animator2D teste toujours uniquement le changement de state à partir du premier animatedSprite. les AnimInfo sont celles du premier AnimatedSprite. Il faut bien prevoir et ordonner les autres animations des autres animatedSprites via Spriter
==> ajouté le fantome, le lier à la stele.
===> voir pour l'interaction avec le fantome pour le lier à l'avatar qui clic dessus ? voire pour la recuperation du skel dans l'inventaire.
===> ne plus dropper l'inventaire à la mort de l'avatar mais le conserver.

- 04/10/2021 : il y a un pb lors du changement d'epee avec effet (flamesword vers epeearete par ex) : l'epee n'est pas changée visuellement.
=> cf GOC_Inventory::LocalEquipSlotOn()
==> OK ajout de animatedSprite->RemoveRenderedAnimation(slotname) pour retirer l'animation avant de la remplacer.
===> RAF : voir a modifier AnimatedSprite2D.

- 31/05/2021 : Ajout de Petite et DarkPetite
=> Ajout de GOC_Animator2D::eventActions_ et de l'attribut "Add Event Actions" permettant d'effectuer une action si un event se produit.
==> utilisation pour le ChangeEntity de Petite en DarkPetite si la nuit tombe

- 21/05/2021 : GOC_Move2D::GoDownPlateform() sur RockGolem ne fonctionne pas
=> dans Urho3D::AnimatedSprite2D::UpdateTriggers(), reutilisation de CollisionBox2D::UpdateBox qui ne recree pas les fixtures et evite la destruction sauvage de contact comme tel est le cas avec CollisionBox2D::SetBox
==> les differentes modifications dans le code de GOC_Move2D et GOC_Collide2D semblent permettre desormais l'utilisation de cette fonction.
===> TO TEST

- 25/04/2021 : ajout de mirubil, oeufmirubil
=> voir pour la taille
=> ajout de AnimatorTemplate_PoweredWalkAttacker
==> OK utilisation du power2 (spawn oeuf) si double-clic
==> voir pour l'utilisation des powers par l'AI
===> OK utiliser aussi les STATE_POWER1 et STATE_POWER2.
====> pour le moment tous les powers sont ranged
====> RAF : intégrer dans Ability, un attribut range_ donnant les distances (min,max) d'utilisation d'une ability.
=====> utiliser cet attribut dans GOB_FollowAttack. Changer d'une abilité en fonction de la distance avec la target

- 08/12/2020 : apres la mort de l'avatar et drop de l'inventaire, il faut verifier que les stats d'equipement soient bien resetées et les effets y compris
=> faire le test avec une arme à effet (flamme).

- 08/12/2020 : il arrive que les entities entrent en fall alors qu'ils sont en contact normalement avec le sol => peut-etre des collectables sur le sol ?
=> le probleme se produit en poussant un collectable.
==> activer le debug de GOC_Collide2D et GOC_Move2D
===> OK : pb corrigé dans GOC_Collide2D::HandleBeginContact partie "Entity Collider" => RAF : verifier la normal de contact.
=> pour les collectables : modification de GOC_Collide2D::HandleBeginContact pour permettre le contact Ground pour tout shape taggé CONTACT_ISSTABLE
==> RAF : il faut aussi modifier toutes les shapes qui sont CONTACT_TOP pour eviter la possibilité que ces shapes entrent en contact (sur leurs faces de dessous) avec des autres shapes qui sont sur le sol ce qui mettrait l'entité en animation FALL

- 07/04/2018 : modifier les controles, pour qu'ils puissent être fait avec le joystick intégralement
=> pouvoir avoir acces aux differents panels UI, Status, Bag, Equipment ...
==> appuyer sur button "Menu" pour mettre le focus sur l'UI Status Panel.
===> 26/11/2020 : ajout la gestion de la selection des buttons Bag, Equipment, Minimap, Craft via keyboard et joystick => UIC_StatusPanel::OnKeyDown
===> 02/12/2020 : focus sur panel via la touche ACTION_STATUS puis ajout du selecteur de slot (SelectHalo_) + UISlotPanel::OnKeyDown pour simuler le drag'n'drop de slot
====> attention avec la souris le drag'n'drop utilise UISlotPanel::HandleSlotDragBegin et UISlotPanel::HandleSlotDragEnd toujours sur le panel de départ => pour le clavier il faut bien sauvegarder l'element draggé
     et pas seulement dans dragElement_ car celui-ci peut etre reseté par Urho3D lors du changement de focus => beginDragElementByKey_
=====> InventoryPanel, EquipmentPanel OK
====> le focus sur le status panel avec le highlight automatique sur l'icone bag ne doit etre fait que si le controller est clavier.
=====> Prendre en compte les touches de la manette et utiliser les ACTION_UP, ACTION_DOWN, ACTION_LEFT, ACTION_RIGHT avec une touche/bouton QUALIFIER pour se déplacer dans les panels.
======> voir pour CraftPanel, AbilityPanel et ShopPanel.

=> pouvoir interagir avec les entities (avoir acces au clic sur entities)
==> appuyer sur button "Action" pour actionner l'entity actionnable la plus proche dans le perimetre de proximité.
=> voir pour identifier les joystick ids et leur attribution aux players
==> cf Game::SetupControllers() et Player::UpdateComponents()
===> 20/11/2020 : premiers correctifs : ajout de GameStatus::joystickIds_ pour garder uniquement les GameControllers qui ne sont pas des sensors (skip les playstations4 sensors)
==> pouvoir changer de control à la volée, hotplug (en passant par les options)
===> 20/11/2020 : OK Ajout de Player::Updatecontrollers() et utilisation dans OptionState::HandleControlP1Changed() ...
    ajout de Game::HandleJoystickChange() et GameStatus::InitJoysticks() et GameStatus::ValidateJoysticks() et GameStatus::buttonsMap_ pour le mapping des boutons de manettes
====> lors de la connection d'un gamecontroller, il y a un gros lag de 2-3sec => cela provient du processus amont dans SDL ou Urho3D
===> 24/11/2020 : ajout de l'UI de configuration des touches du claviers et des manettes.
====> à tester avec les joysticks
====> RAF : sauvegarde de la configuration dans GameStatus::PlayerState
===> RAF : modifier OptionState pour ne voir apparaitre uniquement que les Controls (clavier, manette etc...) disponibles (connectés).

- 16/07/2020 : pour le deplacement en mode tactile voir SDL_TouchFingerEvent si le toucher est sur la partie gauche de l'ecran (cf E_TOUCHBEGIN, E_TOUCHMOVE, E_TOUCHEND) pour remplacer le ScreenJoystick
=> utilisation de Urho3D::TouchState dans GOC_PlayerController::UpdateLocalControl_Touch()
=> activation du screenjoystick si necessaire dans engine_config.xml avec screenjoystick_=true

- 03/07/2020 : attention sur les controles des joueurs => si appuie sur FIRE (avec ou sans release) et déplacement ou saut, l'avatar attaque de nouveau
=> comportement non souhaitable si la touche Attack n'est plus appuyé.
==> toujours problématique avec elsarion lors du JUMP
===> OK : Elsarion n'avait pas d'animation FALL ou JUMP donc à la fin de l'attaque pas de changement d'Animation et il reste en attack
====> avec RockGolem qui utilise des switchables animations, le fait de rajouter une animation FALL (un simple clone de WALK) fait recommencer en debut la marche alors qu'il etait sur l'autre pied.
    cela cree une rupture dans le mouvement. Pour eviter ces 2 pb (attaque et rupture de mouvement lors du fall), creation de AnimationTemplate_Golem qui declare permet d'utilise le WALK comme FALL.
    Attention à ne pas modifier AnimationTemplate_Attacker avec cette ruse car impacte sur beaucoup d'autre entité tel que le loup qui aurait alors un WALK en fall en plus de son FALL (à cause de l'attribut switchables animations).
    RAF : Pour palier à ça il faudrait modifier l'attribut switchable animation pour permettre une restriction parametrable des switchables à certains states seulement (tel que les attaques).

- 01/07/2020 : ajout de la sorciere
=> explosion de la boule de feu sur les murs
==> la boule rebondit parfois sur des rebords de fenetre voir sur des marmites et n'explose pas ?
==> OK : la collision circle était trop grande et le trigger TA trop petit
==> reprise de GOC_BodyFaller2D qui ne sert plus à rien
===> le rendre plus generaliste pour permettre la modification des propriétés du rigidbody lors de certains evenements enregistrables
====> à renommer en GOC_BodyModifier
====> comme bullet, la bdf utilise GOC_Detector => pas mal d'incomprehension avec les attributs de ce composant => voir pour les renommer correctement
====> voir pour rajouter un composant pour les Projectiles à la place de GOC_BodyModifier et GOC_Detector ? (cf SpaceMatch BlastLogic) notamment on voudrait des boules de feu qui detecte une cible proche et fonce dessus
=> RAF : voir pour rajouter un GOC_ZoneEffect pour bruler les entités environnantes ?
=> RAF : ajouter le tir multi-directionnel à la sorciere (comme pour le pistolet et skeleton)
=> RAF : concentration du tir pour augmenter la puissance
=> RAF : changer de sort
=> RAF : ajouter l'utilisation de la mana : reduction à chaque utilisation de sort et regeneration lente (prevoir des potions de mana et regen mana)
=> OK : eviter de tirer lorsque le spawn va atterir dans un mur

- 17/02/2020 : ajouter la magie
=> specialisations de base : feu, lumiere, eau, tenebre, vent, mutation,
=> baguettes spécialisées : avoir une baguette pour lancer des sorts plus puissant lorsque la specialisation de base et celle de la baguette sont identiques

- 17/02/2020 : ajouter le craft
=> commencer avec une recette de potion simple : 1 elsarionmeat + 1 poudre d'os
==> struct Recipe aura une liste d'ingrédient à satisfaire + 1 liste d'outil à disposer
==> creer une UI pour le craft : drop des items et des outils dans l'UI ?
===> 17/06/2020 : en cours de codage dans UIC_CraftPanel avec correctif dans UISlotPanel
====> trouver le moyen de dropper sur le bon focusindex à partir d'un autre panel (le focusindex fonctionne dans un meme panel mais autrement renvoit toujours 0)
====> erreur corrigée dans UISlotPanel::HandleSlotDragEnd() - il suffisait d'ajouter pour le "To Craft", focusIndex = toInventory->GetSlotIndex(focusElement->GetName())
====> Creation de CraftRecipes et mise en place dans UIC_CraftPanel
=====> Test OK avec 2 recettes simples (Potion et PotionRegen)
=====> OK : ajout la barre de progression de craft dans le button Make
=====> RAF : creer/ajouter l'icone Craft dans le PlayerStatus
=====> RAF : ajouter les tools. ils peuvent être dans l'inventaire pour les versions portables (kit d'alchimie, pierre à aiguisser, nécessaire de couture) ou bien dans la scene pour les versions intransportables (forge, chaudron).
======> pouvoir detecter

- 20/04/2020 : GOC_StaticRope
=> decrochage du fil lors d'un nouveau fall ou bien si coupé par une autre entité (coup d'épée par exemple)

- 07/04/2020 : les particules de feu de Darkren ne disparaissent pas toujours lorsque l'on change de personnage.
=> 21/04/2020 : de meme pour le fil de l'araignee
==> le probleme se situe dans Actor::ResetAvatar => GameHelpers::CopyAttributes()
====> correctif dans GameHelpers::CopyAttributes() lors du removeUnusedComponents (suppression du test sur le nombre de components src/dest)
====> tester si reapparition du pb

- 20/02/2020 : pouvoir ajouter aux objets des slots egalement
=> ex le pistolet pour changer le type de balle (balle feu, balle poison etc...)
=> ex les epees pour ajouter un effet feu, glace ...
==> modification de Slot pour ajouter un effetid
==> modifier GameHelpers::SetCollectableProperties, GOC_Collectable::DropSlotFrom

- 02/03/2020 : pour un meilleur affichage et la standardisation des effets sur les armes (poison, flame), il vaudrait mieux utiliser des RenderAnimations.
=> une entité qui utilise une arme qui a un effet feu, devra activer le RenderAnimation de l'arme
==> creer une arme exemple SCML avec un POINT IN_Effect.
==> 03/03/2020 OK : modification de GOC_Inventory::EquipSlotOn, et de Urho3D::AnimatedSprite2D pour l'update des renderAnimations en cascade
===> RAF : probleme avec l'equipement de l'effet Urho3D::AnimatedSprite2D::AddRenderedAnimation() ne peut etre realisé la premiere fois car Urho3D::AnimatedSprite2D::UpdateSpriterAnimation() n'a pas encore été réalisé
====> 03/03/2020 OK :correctif dans Urho3D::AnimatedSprite2D::AddRenderedAnimation().

- 02/03/2020 : Modification de Urho3D::PhysicWorld2D
=> renvoi d'un simple index pour consultation du ContactInfo au lieu de redispatcher via un EventData toutes les datas du ContactInfo
==> il suffit de recuperer le ContactInfo :
===> pour un BeginContact => "const ContactInfo& cinfo = GameStatus::physicsWorld_->GetBeginContactInfo(eventData[P_CONTACTINFO].GetUInt());"
===> pour un EndContact => "const ContactInfo& cinfo = GameStatus::physicsWorld_->GetEndContactInfo(eventData[P_CONTACTINFO].GetUInt());"
====> OK : modification des composants utilisant les Events E_PHYSICSBEGINCONTACT2D et E_PHYSICSENDCONTACT2D : GOC_Collide2D, GOC_ZoneEffect, GOC_DropZone, GOC_Detector, GOC_Portal, GOC_Inventory, GOC_Collectable, GOC_PhysicsGrapin
=====> RAF : Tester chaque composant modifié

- 07/05/2018 : modifier Radius Trig_Attack et les degats suivant l'arme utilisée
=> Introduire un modificateur pour Trig_Attack ?
==> récupération de la collisionshape et modification de la taille en fonction de l'object utilisé
=> "Trig_Attack" remplacé par "TA"

- 26/02/2020 : l'ajout ou le changement des ailes posent probleme si mis en special2 : les ailes ne sont pas enlever lorsque le slot est déchargé car celui-ci n'est pas intégré à lizard.scml
=> solution temporaire dans GOC_Inventory::EquipSlotOn() : considérer le special2 comme un special1
==> RAF : creer un slot CAPE dans l'inventaire => les ailes ne seront plus un SPECIAL mais une CAPE.
===> ajouter à l'object ailedark.xml l'ability ABI_Fly

- 14/02/2020 : Pb avec GOC_ZoneEffect, parfois l'effet continue toujours apres le nombre de ticks effectué.
=> modification du container HashMap<>unsigned, EffectCount</> affectednodes => devient Vector<>EffectInstance</> instances_ EffectInstance = EffectCount + WeakPtr<>Node</>
    ce qui evite d'avoir à rechercher dans Scene les nodes.
    de plus correctif dans GOC_ZoneEffect::HandleScenePostUpdate(), lors du removenode, bien mettre à jour l'iterator pour pointer sur l'element suivant.
==> faire le tri dans les entités auxquelles peuvent s'appliquer les effets (les lames ne devraient pas subir l'effet par exemple)
===> OK : ajout de GameHelpers::IsNodeImmuneToEffect()
====> RAF : à completer/modifier pour les avatars et les got
=> 27/09/2022 : OK correctif dans GOC_ZoneEffect et EffectsManager : les effets potionRegen et Flame de Darkren fonctionnent correctement : il n'y a desormais plus de persistence au dela du nombre de tick.

- 17/02/2020 : ajouter les differents slots d'equipment restants : les speciaux (ailes, amulettes, anneaux, cape, etc...), les pieds (les bottes), les mains (les gants)
=> AnimatedSprite2D avec une RenderAnimation pour les ailes : permettre le changement d'animation pour les renderanimations
==> le changement d'animation sur les renderanimation sont piloter par l'animatedsprite pere via AnimatedSprite2D::SetSpriterAnimation() qui applique le meme nom d'animation aux fils
===> RAF : les noms d'animation ne seront pas toujours identiques à l'animation du pere : ex hurt != hitted ... de plus il y a les animations multiples notamment pour attaquer attack1, attack2
====> voir pour utiliser les index d'animation : avec un noyau d'animation de base tel que idle, move1, move2, attack, hurt placer toujours dans cet ordre placer les autres animations ensuite. ce qui implique de modifier tous les SCML
====> les objets equipés en slot tel que les ailes ou bien la torche auront egalement ce noyau
====> autre solution : gerer le changement d'animation des renderanimation dans GOC_Animator2D
===> RAF : voir pour la torche et le changement d'animation eteinte et allumée, sur petit la torche est eteinte puis s'allume des que l'on attaque, voir quel comportement choisir.

- 18/09/2019 : faire les Joysticks Bindings pour tout gamecontroller
-> pour le moment uniquement PS4. cf GOC_ControllerPlayer::UpdateLocalControls()

- 31/05/2018 : Ajouter le State Accroupi => prévoir de modifier le physic Body (desactiver le collider corps mais pas le collider pied)
=> utiliser GOC_Collide2D::SetCollidersEnable

- 10/05/2018 : les followers ne changent pas tous de viewZ

- 24/04/2018 : les Bones ne provenant pas d'un skeleton tué ne fonctionnent pas dans le sanctuaire et sont surdimensionnés
=> le slot du collectable n'a pas setté le partfromtype ni le scale
==> ok pour le partfromtype dans Slot::SetSlotAttr

- 19/10/2017 : Interdire le spawn d'entity dans les murs
=> modification de Ability::UseAtPoint(), GOC_Animator2D::SpawnEntity() -> ok pour les lames, les bombes
=> encore des pbs ex:bomb lorsque le player est collé sur le plafond, génére des bombes dans les murs
==> faire de meme avec GOC_Collectable/Player

- Mettre à jour l'ensemble des Objets Dynamic pour tenir compte du centre de Masse (nécessaire dans l'UpdatePosition de GOC_Destroyer) (10102017)
-> éviter de mettre le centre de masse en bordure de tile (entrainant une erreur de tile position)
-> si la position du node est en bordure, prendre soin de bien déclarer le centre de masse comme le centre du collider

- Ajouter/Modifier ability pour traverser les murs dans les 3 axes (et pas uniquement suivant z) (04/08/2017)

- si le personnage mounted le + haut a un moveState >= MV_WALKANDFLY alors le controlleur herite de ce comportement.

*/

/* DONE
------

- 20/01/2023 : la lance a été modifiée (recentrage du collider) pour eviter le spawn dans les murs vers la gauche (il manque en effet lors du flipping, le flipping du physic de la lance ... à voir)
=> mais le spawn ne fonctionne pas correctement avec les certains kigrat en world
==> il s'agit du scale de l'entité qui est trop petite par rapport à la lance : la lance entre en contact avec le body de l'entité et se met en stick.
===> la lance ne doit pas devenir stick s'il s'agit du lanceur.
====> OK 23/01/2023 : modification de GOC_Detector::BecomeStickOn().

- 11/12/2022 : correctif pour l'ability cassage de mur : Buros ne casse pas les mur en face mais ceux en oblique ...
=> OK : Player::OnFire2() utilise la position du node et pas le masscenter, modification de ABI_WallBreaker::Use qui utilisait lui la position du centre de masse.

- 05/11/2022 : Raignee n'a plus de fil.
=> du à la modification de GOC_EntityAdder pour les bougies dynamiques : avec l'ancien code les spiderthread fonctionnent.
==> cf GOC_EntityAdder::UpdateAttributes()
===> spiderthread est consideré comme static (pas de RigidBody) -> node ajouter au root_ défini.
====> OK : ajout d'un node->SetPosition2D() et c'est OK.

- 05/11/2022 : Corriger le shot avec pistolet de skeleton qui se déclenche en sîmple attaque avec épée.
=> se déclenche également avec lizard sans tirer lorsque le pistolet est equipé ... utilise ABI_AnimShooter des que le pistolet est équipé.
==> Log :
[Sun Nov  6 11:11:59 2022] INFO: Player() - UseWeaponAbilityAt : position=13.7044 16.6322 ... weapon1ability=0
[Sun Nov  6 11:11:59 2022] INFO: Player() - UseWeaponAbilityAt : position=13.7044 16.6322 ... weapon2ability=1506844804
[Sun Nov  6 11:11:59 2022] INFO: Ability() - UseAtPoint (static) ability=ABI_AnimShooter holder=Player_1(16777270) pos=13.70,16.63 ...
[Sun Nov  6 11:11:59 2022] INFO: ABI_AnimShooter() - Use : wpoint=13.7043867111206,16.6321830749512 ... OK !
[Sun Nov  6 11:11:59 2022] INFO: Ability() - UseAtPoint (static) ability=ABI_AnimShooter holder=Player_1(16777270) pos=13.70,16.63 ... OK !
===> probleme suite à l'ajout de la pelle qui utilise le WallBreaker, l'ability porté par l'équipement n'ayant pas besoin d'etre activé et déclenché des que contact avec un mur.
====> le probleme c'est que les autres abilités qui sont porté par un équipement tel que le pistolet et ABI_AnimShooter vont aussi etre utilisées via Player::UseWeaponAbilityAt().
====> il faut rajouté un event d'activation à la procédure Player::UseWeaponAbilityAt().
=====> OK : ajout de l'abi souhaitée.

=> 19/09/2022 : les animations type "feu" doivent etre changé si sous l'eau : cendre, fumerolles...
=> correctif pour les entités "Feu" : elles ne s'eteignaient pas automatiquement lorsque dans l'eau => ajout de GameHelpers::SetFireLights() dans GOC_Destroyer::UpdateAreaStates()
==> chaque entité "avec du feu" devra etre taggé avec GOA::FIRE et pas seulement le node avec le component Light ... voir si cela ne gene pas avec les effects.
==> les entités static avec GOC_Animator2D et GOA::FIRE doivent aussi pouvoir s'éteindre si dans l'eau (bougie seule, feu de camp seul)
===> mettre un handle dans GOC_Animator2D activé si GOA::FIRE et pas de GOC_Destroyer et si pas ajouter grace à GOC_EntityAdder.
===> pb avec FUR_Bougie : elle est une fourniture avec physic STATIC donc ne peut pas entrer en contact avec Le physic FLUID qui est aussi un STATIC.
====> mise en dynamic de FUR_Bougie, pb car son ViewZ=0 et ne dispose pas de GOC_Destroyer lui permettant de le changer (PhysicsWorld2D::BeginContact() a besoin du viewZ)
====> ajout de GOC_Animator2D::OnTouchFluid et GO_COLLIDEFLUID envoyé par WaterLayer.
====> désormais les GOC_Animator2D vont maintenir GOA::INFLUID
=====> WaterLayer::HandleBeginFluidContact() envoit GO_COLLIDEFLUID vers GOC_Animator2D seulement si l'entity est dans le fluid => Permet uniquement d'eteindre les feux (mais pas de les rallumer en automatique).
=====> il faut faire de meme pour feudecamp (mettre en dynamic) et cheminee allumée qui l'ajoute (attention cheminée allumée est static)
==> introduire un nouveau state behaviorState qui pourra prendre differentes valeurs (WETTED, FURY, FROZEN, CARBONIZED, ...)
==> et utiliser le characterMapping
===> il faudra modifier encore GOC_Animator2D::CheckFireLight() concernant les STATE_LIGHTED & STATE_UNLIGHTED, il faut egalement desormais considerer le CharacterMapping CMAP_FIRE et CMAP_NOFIRE
====> faire un essai avec la sorciere et Darkren =====> premier essai ok.
=====> WaterLayer::HandleBeginFluidContact() n'envoit GO_COLLIDEFLUID que pour les Shape Trigger (typiquement les pointlight tel que feudecamp, bougie)
======> GOC_Destroyer::UpdateAreaStates() enverra GO_COLLIDEFLUID pour les entity disposant d'un GOC_Destroyer. Il est important pour l'etat initial dans GOC_Destroyer de supprimer la var GOA::INFLUID afin
	que lors du premier updatepositions la methode UpdateAreaStates soit forcée de lancer l'event GO_COLLIDEFLUID permettant d'initialiser le bon etat GOA::INFLUID.
=======> il faudrait ajouter une animation de transition entre les etats sec et mouillé.
=> RAF : swordflame et bouledefeu appliquer le CharacterMapping CMAP_FIRE ou CMAP_NOFIRE lors du spawn et pour l'equipement
==> bouledefeu ajout du CharacterMapping et ajout de GOA::FIRE en vars dans l'object bouledefeu.xml, modification de l'attribut "World Position Update" du GOC_Destroyer => passe à true (pour avoir acces au changement d'area de GOC_Destroyer::UpdateAreaStates())
==> la flamme de LargeSwordFlame est un effet obtenu à partir d'une RenderAnimation inclus dans l'animatedsprite (node child avec animatedsprite) (cf GOC_Inventory::LocalEquipSlotOn)
===> 29/09/2022 : ajout du CharacterMapping a effects_flame.scml et ajout de l'update du characterMapping pour les RenderAnimations dans GOC_Animator2D::CheckFireLight().

- 19/09/2022 : sous l'eau pouvoir descendre des plateformes.
=> 29/09/2022 OK : ajout de GOC_Move2D::GoDownPlateform() dans GOC_Move2D::ControlUpdate_Liquid()

- 28/09/2022 : sous l'eau remplacer les particules dust par des bulles d'air
=> cf GOC_Animator2D::OnTouchGround
==> ajout des particule bulledair, utilisation du layer WaterInside.xml
===> utilisation de depthwrite=true pour le waterrefract pour permettre le masquage des bulle si sortie de l'eau
===> les particules doivent etre en zf equivalent au layer waterrefract avec depthtest=equal
====> modification de Urho3D::ParticleEmitter2D::UpdateSourceBatches() pour pouvoir utiliser un zf different de 0.f
====> OK

- 27/09/2022 : la boule de feu au centre de darkren ne disparait pas toujours lorsque darkren passe dans l'eau.
=> OK : correctif dans GOC_ZoneEffect et patch Urho3D::ParticleEmitter2D

- 27/09/2022 : il ne faut pas que dans les cascades les entités reste en suspension
=> OK : modification dans GOC_Destroyer::UpdateAreaStates()

- Pouvoir nager plus vite avec Elsarion
=> Ajouter Template comme GOC_Life
==> OK 17/09/2022 : ajout de GOC_Move2D_Template et creation FastSwim

- Integrer correctement le WaterLayer dans les Behaviors de toutes les entités avec physic dynamic :
=> il faut ajouter l'attribut de flottabilité GOC_Move2D::buoyancy_.
==> si l'entité peut flotter et est dans un fluid alors lui appliquer la gravité WATER et ajouter une force vers le haut en fonction de buoyancy_
===> c'est déja fait dans GOC_Move2D mais les parts et les objets n'ont pas ce composant.
====> soit ajouter ce composant, soit ajouter à un composant generique utilisé par toutes les entités dynamique : GOC_Destroyer ?
====> ajout dans GOC_Destroyer de l'attribut buoyancy. Deplacement de GOC_Move2D::UpdateAreaStates vers GOC_Destroyer::UpdateAreaStates()
=====> ajouter l'attribut Buoyancy dans les Composants GOC_Destroyer des entités flottantes.
=====> 19/09/2022 : essai ok avec Table et Petit

- le climb et le swim de chapanze ne sont pas bien affiché en fonction des etats movestate
=> 12/09/2022 : OK priorité au climb par rapprt au swim dans GOC_Animator2D::Update().

- Modifier la nage pour que le player puisse aller vers le bas (04/08/2017)
=> 12/09/2022 : OK modification de GOC_Move2D::Update_Swim() et GOC_Move2D::ControlUpdate_Liquid() et GOC_Move2D::UpdateAreaStates()
==> 16/09/2022 : ajout de l'event EVENT_CHANGEAREA qui permet de faire un FindNextState sans passer par l'eventTable.
===> utiliser dans GOC_Move2D::UpdateAreaStates() pour realiser un FindNextState en sortie de Fluid
===> ajout de EVENT_CHANGEAREA dans GOC_Animator2D::Start() pour etre de base pour tout animator
===> 16/09/2022 : parfois la sorciere ne disparait pas à sa mort !
===> le probleme vient de l'introduction de EVENT_CHANGEAREA qui va bypasser le state DEAD
====> test si l'entité est DEAD avant de poster l'event.

- Ajouter les animations Swim pour l'ensemble des entités pouvant nager
=> revoir GOC_Move2D::UpdateAreaStates() pour la nage : pb pour l'acces à la surface : detection de la surface alors qu'en pleine immersion
==> OK : le liquidHeight n'etait pas rescalé sur le tileheight.
==> RAF : le centre de masse de l'avatar (GOC_Destroyer::GetWorldPosition()) n'est pas forcement placer de facon à ce que la tete sorte de l'eau uniquement : il faudrait ajuster par avatar.

- 23/05/2022 : le filet sur Lizard est trop grand. Les Weapons sur Chapanze sont enormes.
=> pour le filet, le manche n'etait pas pris en compte car il ne porte pas le nom de l'objet "filet"
==> OK : renomme manche en filet, reprise du scml, modification de TexturePacker pour ajouter duplicatesprite et alias sur le filet
=> 24/05/2022 OK : pour chapanze, ajout de attribut "MappingScaleRatio" dans l'AnimatedSprite2D

- 18/05/2022 : sous mobile, le clic sur le screenjoystick Power1 va declencher un double tir : voir Player::HandleClic()
=> 24/05/2022 OK : pb de uiscale réglé dans Player::HandleClic()

- 23/05/2022 : buros detruit les murs sans s'arreter.
=> Modification de la logique d'activation pour ABI_WallBreaker::Use().
=> suite aux modifications dans GOC_Collide2D::HandleBeginContact() avec l'ajout de "Trigger Solid" pour les armes de Contact,
    Buros a par défaut ce "TA" solide dû à Player::UpdateTriggerAttacks(). Ce qui pose probleme pour la logique de collision avec les Murs.
==> 23/05/2022 OK : Remplacement du nom du Trigger Attack de Buros dans le scml par TAT ald TA

- 23/05/2022 : les weaponabilities restent actives en changeant vers un avatar non equipable.
=> 23/05/2022 OK : correctif dans Equipment::UpdateAttributes

- 23/05/2022 : crash en changeant de filet vers épée flame après changement d'avatar.
=> il faut qu'au changement d'equipment la liste GOC_Animator2D::animatedSprites soit mise à jour.
==> 23/05/2022 OK : Modification GOC_Inventory::LocalEquipSlotOn() et GOC_Inventory::NetEquipSlotOn() : ajout GOC_Animator2D::CheckAnimatedSprite()

- 19/05/2022 : ajouter l'ability "creuser" avec la Pelle.
=> lorsque le trigattack de la pelle touche un mur, utiliser l'ability WallBreaker
==> 21/05/2022 : Ajout de Player::UseWeaponAbilityAt() utiliser dans GOC_Collide2D::HandleBeginContact.

- 18/05/2022 : probleme avec l'equipement lors de la collecte d'une armure ou d'un casque. Le slot est bien rempli mais pas le slot UI et pas d'update du character.
=> OK : dans UIC_EquipmentPanel::OnSlotUpdate le contenu avait été désactivé. Pourquoi ? un correctif ? => pour le moment, reactivation.

- 05/10/2021 : ne pas appliquer d'invulnerabilité lors de la perte de vie occasionné par les EffectInstance.
=> remplacer checkinvulnerability par applyinvulnerability comme argument dans EffectsManager::AddEffectOn() EffectsManager::ApplyEffectOn() et GOC_Life::ReceiveEffectFrom()
==> dans GOC_Life::ReceiveEffectFrom() n'appliquer l'invulnerability que si argument applyinvulnerability=true.
===> Ok patch de EffectsManager::Update => dans ApplyEffectOn passer false en argument applyinvulnerability.

- 04/10/2021 : il manque les effets de feu appliqué par l'epee enflammée (les ticks)
=> voir les modifications apportées dans GOC_Life et EffectsManager
==> il s'agit de l'invulnerability dans GOC_Life::ReceiveEffectFrom() qui bloque l'application des effets suivants.
===> OK : ajout de l'attribut checkvulnerability dans les methodes impliquées.

- 19/05/2021 : sur le sol, les entités entrent parfois en fall
=> OK : correctif dans GOC_Move2D::OnWallContactEnd : ajout de la condition sur la velocity min pour fall.

- 15/05/2021 : ajout d'ours
=> OK 18/05/2021 : correctif dans GOC_Move2D et GOC_Collide2D pour le saut sur mur et dans GOC_Animator2D pour le physic flip X

- 12/05/2021 : ajout de kigrat et lance
=> voir pour unifier le tir directionel du pistolet et les lames ou bomb
==> utilisation du tir directionel via ABI_AnimShooter::Use()
===> Ajout de GOC_Animator2D::SetSpawnAngle() et modification de GOC_Animator2D::ApplyDirectionalAnimations() pour utiliser les bonnes animations directionnelles en fonction de spawnAngle_.
====> OK pour Kigrat et Skeleton

- 28/04/2021 : probleme avec le CLIMBFIRSTBOX : si Petit saute sur un mur qui n'a pas de liaison directe avec un sol en maintenant la direction vers le mur, le personnage reste suspendu au dessus du passage sous le mur.
=> dans Petit, la collisioncircle de sol doit etre legerement plus grosse que le collisionbox de tete ce qui evite d'avoir un contact Ground generer enrte le dessus du mur et le bas du collisionbox de tete.
==> corriger la collisioncircle les autres entités disposant du CLIMBFIRSTBOX (lizard, buros)
===> ne fonctionne pas avec lizard (le collisionbox est beaucoup plus grand)
====> OK le 29/04/2021 : modification de la logique dans GOC_Move2D::Update_Walk()

- 28/04/2021 : GOC_Move2D ajout de l'animation Fly_down dans les scml des entités volantes pour permettre le changement d'animation vers fly_down si chute (~TOUCHGROUND)
=> OK : ok pour le vampire, redlord, junkelspil

- 11/03/2021 : Encore des cas avec le marchand ou il n'y a pas possibilité de clicker sur les 3points (...)
=> OK 06/04/2021 : nouveau correctif dans DialogueFrame::ToggleFrame()
==> tjrs un pb : il faut verifier que le physique est bien actif => dump
===> le physique est bien actif (rigidbody et collisionshape de Interactive_NextLine)
====> vérifier que la methode pour générer le clic est bonne (verifier le subscribe)
=====> cf DialogueFrame::HandleInput
======> le probleme arrive uniquement en fullscreen
=======> impossible de prendre la position de la souris en fullscreen surement du au WrapMode
========> OK 08/04/2021 : utilisation de la position du curseur.

- 12/03/2021 : au chargement d'une sauvegarde, les bones spawnés ne peuvent être cassés : le ScrapsEmitter est-il bien créé ? activé ?
=> ScrapsEmitter a besoin d'un trigEvent pour se déclencher mais il est par default à zero => l'initialiser à GO_RECEIVEEFFECT par défaut.
==> OK : voir pour faire mieux par la suite en retravaillant les attributs pour que l'attribut "Trig Event" ne soit plus une String mais directement un StringHash ?

- 11/03/2021 : changement de direction des entities au départ du GOC_Portal
=> GOC_Controller::Stop() utilise GOC_Controller::ResetDirection
=> OK : dans GOC_Controller::ResetDirection remplacer l'event GO_CHANGEDIRECTION par GO_UPDATEDIRECTION

- 18/12/2020 : il arrive que GOC_Portal bloque encore dans la generation de map.
=> 03/03/2021 : après de multiples teleportations entre 2 GOC_Portals, les maps ne semblent pas être sauvegarder dans leur état (les entities ne sont pas serializer)
==> voir MapStorage::UnloadMapAt et Map::OnUpdateMapData()
===> OK : correctif dans Map::OnUpdateMapData => GetMapData()->SetSection(MAPDATASECTION_ENTITYATTR()
==> Apres SaveWorld, la destination du GOC_Portal est resetée : les Attributes n'ont pas été sauvegardé car Portal est une furniture.
===> cf Map::OnUpdateMapData()
===> il faut pouvoir marquer les furnitures à sauvegarder avec entityattr => utiliser le GOTypeProperties::GOT_Usable_DropOn renommer desormais GOTypeProperties::GOT_Usable.
====> OK 05/03/2021 : correctif dans GOC_Portal, MapStorage, MapWorld, MapCreator.

- 18/12/2020 : ajouter des pieges.
=> 26/02/2021 : ajout des sprites dans plantsstaticnew.png
==> voir pour implanter les pieges dans des zones interessantes en fonction de la nature de la chambre si donjon ou du denivellé si exterieur ou cave
==> premier ajouts faits.

- 08/12/2020 : lorsqu'une entité est coincé dans un mur, faire un unstuck : tester les tiles environnantes en partant par celle du dessus
=> ajout de GOC_Destroyer::Unstuck() qui test sur les tiles cardinales uniquement.
==> Attention à utiliser que dans GOC_Destroyer::UpdatePositions() pour le moment car utiliser GOC_Destroyer::currentCell_ et ne teste pas si en bordure de map.
===> RAF : cas en bordure de map.
==> les bats semblent poser probleme
===> 17/12/2020 : il s'agit du centre de masse qui n'etait pas specifier dans bat.xml => à corriger sur l'ensemble des entities

- 10/12/2020 : pb avec le Climb, que ce soit pour l'araignée ou pour chapanze.
=> pb de direction apres fin de contact
==> OK 15/12/2020 : modification de GOC_Move2D::ControlUpdate_Ground et GOC_Animator2D::UpdateDirection() : ajout de GOC_Move2D::lastDirectionX_
=> lorsque le chapanze est dans un coin superieur ouvert, le top collider (box) de l'entité en contact uniquement avec le wall border, en se déplacant vers le haut, l'entité va partir en diagonale
==> cela est du au begincontact entre le ground collider (circle) de l'entité avec le wall border qui établit un contact Roof (car abs(normal.y) > abs(normal.x))
==> solution 1 : empeche ce type de contact en modifiant les dimensions du ground collider et du top collider pour que ce dernier recouvre le premier
==> solution 2 : changer les propriétés du ground collider pour qu'il ne puisse avoir de contact de type Roof.
==> OK solution 3 : eviter la transformation du type de contact dans GOC_Collide2D::AddWallContact2D.

- 15/12/2020 : pb lorsque un climber est en contact Roof, puis changement d'avatar et chute au sol et rechangement d'avatar pour Raignée : celle-ci est flippé en Y.
=> ce pb n'apparait plus lorsque LOAD_METHOD est utilisé dans Actor::ResetAvatar
==> le pb provient de GOC_Move2D::UpdateAttributes() qui ne resetait correctement pas les flags de wall contacts.
===> OK le 17/12/2020 : ajout de GOC_Collide2D::GetNumRoofContacts() ... et modification de GOC_Move2D::UpdateAttributes().

- 15/12/2020 : pb pour les colliders shapes Ground et Top des entités : leur dimension n'est pas bien redéfinie après changement et rechangement d'avatars.
=> pb avec le define CLONE_METHOD dans Actor::ResetAvatar, surement GameHelpers::CopyAttributes(), pas de pb avec le define LOAD_METHOD (cependant LOAD_METHOD n'est pas tres bon : il va reprendre de nouveaux numeros de composants...)
==> le dump des attributes ne montrent pas de changement de valeur
===> pb avec CollisionShape2D::cachedWorldScale_
====> OK : modification de CollisionShape2D::OnSetEnabled()
==> RAF : avec le LOAD_METHOD apres changement d'avatar, l'entity ne peut plus aller sur des plateformes
===> voir les Setters/Getters de CollisionShape::SetExtraContactBits() ?

- 09/12/2020 : pb avec les lames : elles n'apparaissent pas tout le temps => pb de layer lors du spawn.
=> cf GO_Pools, ABI_Shooter, GOC_Destroyer
==> en clic sur un Trigger d'une porte ou d'une entity, le Spawn ne peut etre fait. cf Player::HandleClic()
===> OK : modification de Player::HandleClic() => déplacement en amont du code gerant l'Ability

- 08/12/2020 : si contact sur les cotés entre player et entities, il arrive souvent que le player voulant descendre d'une plateform ne puisse pas le faire
=> cf GOC_Move2D::ControlUpdate_Ground() => cf GOC_Move2D::CheckGoDownWall()
==> OK : modification de GOC_Move2D::CheckGoDownWall() pour skipper les contact qui ne sont pas avec des walls ni des plateforms

- 30/10/2020 : pb avec les entity walker, parfois l'animation FALL ne se met pas en place
=> cela provient d'un wallcontact sur une entity (ex: marché sur la tete de rockgolem)
==> verifier GOC_Collide2D::HandleEndContact(), GOC_Collide2D::HandleBreakContact()
===> il n'y a pas d'appel à GOC_Collide2D::HandleEndContact() => cf Urho3D::PhysicsWorld2D::EndContact()
====> aucun endcontact envoyé par Urho3D::PhysicsWorld2D
=====> le Pb est dans la modification des fixtures qui doivent etre recreer à chaque modification des shapes => il y a perte dans Box2D du contact qui est surement detruit sans alerte de sa destruction
======> Essai de modification dans AnimatedSprite2D::UpdateTriggers() en remplacant CollisionBox2D::SetBox() par une nouvelle fonction CollisionBox2D::UpdateBox() qui modifie directement la shape sans recreer la fixture.
=======> l'alerte est bien lancée et le box2D envoit bien le endcontact
=======> cela ne va pas avec l'implementation dans FromBones qui ne temporise pas entre les begin et end contacts et a pour resultat de mettre l'entité dans un état de flipping d'animation entre de touchground et fall.
========> la solution est de faire avec la version AnimatedSprite2D::UpdateTriggers() non modifier cad avec CollisionBox2D::SetBox() et de modifier GOC_Move2D::Update_Walk() pour que l'etat FALL
    se declenche des le seuil de velocité minimale de Fall atteinte et ce meme si le movestate est MV_TOUCHGROUND est actif.
========> 01/11/2020 OK : tester sur l'ensemble des avatars : Pour le moment ok entre petit et rockgolem.

- 30/10/2020 : pb de Climb avec Chapanze dans les angles de tile : il est bloqué surement par l'interaction des colliders, mais étant en Gravité 0, on peut le déplacer mais il part en biais et se retrouve à ne plus toucher la paroi dans le vide.
=> cf GOC_Collide2D::RemoveWallContact2D() et GOC_Move2D::HandleWallContactEnd()
==> OK le 31/10/2020 : pb de normal dans GOC_Collide2D::AddWallContact2D()
    et de passage de walltype par event entre GOC_Collide2D::RemoveWallContact2D() et GOC_Move2D::HandleWallContactEnd() => passage sans event via GOC_Move2D::OnWallContactBegin() et GOC_Move2D::OnWallContactEnd()
===> a tester la fluidité sur RPI ... sans event cela risque de flooder

- 15/06/2020 : Le GOC_Move2D Fly en avancant sur du plat ou bien en tombant ne change pas d'animation
=> OK : Correctif de la logique dans GOC_Animator2D::Update & GOC_Animator2D::FindNextState pour privilegier EVENT_FLYUP (le fly par defaut et en cas de JUMP; EVENT_FLYDOWN utiliser lors de la chute)

- 13/06/2020 : corriger le drop des elsarion parts. on doit egalement pouvoir les detruire comme les os
=> ajout de ElsarionMeat dans GOT::InitDefaultTables() à l'instar de Bone
==> OK ajout des Scraps

- 07/06/2020 : Crash en changeant d'avatar d'un Character vers Darkren.
=> Drakren a GOC_ZoneEffect en plus
=> Aucun Crash en changeant vers un autre Character puis ensuite vers Darkren
==> ByPass temporaire dans Urho3D::Node::SetEnabled()
==> RAF : Analyser Player::UpdateAvatar() et GameHelpers::CopyAttributes() et trouver une solution acceptable.
===> Le Crash se produit après GOC_ZoneEffect::OnSetEnabled() qui ne pose aucun pb à priori
===> Le Component suivant dans Node::components_ est GOC_Inventory
====> dans Urho3D::Node::SetEnabled() : Remplacement de la boucle avec iterateurs par une boucle simple avec un check de la taille maxi du Vector components_ (limitée à 50)
=====> OK : plus d'erreur.

- 25/05/2020 : plantage lorsque 2 joueurs (human,CPU) ou (human,human) lorsque l'on essaie de monter l'un joueur sur l'autre
=> beaucoup de modification effectuer dans Player
==> ajout de Player::MountOn, Player::Unmount(), modification de Player::OnEntitySelection()
===> Attention : les Players controllés par CPU utilise le Behavior GOB_MOUNTON à prendre en compte dans Player::UpdateAvatar()
====> OK le 31/05/2020
===> Probleme avec 3 joueurs, encore une disparition puis crash
====> voir pour les conditions dans Player::OnEntitySelection() et Player::HandleClic()
=====> OK le 01/06/2020 : correctif dans Player::OnEntitySelection() empechant de monter sur une entity qui est montée sur le player
 cela evite le cas ou 2 entités sont montées sur le player et que celui-ci veuille monter sur l'une d'elles, ce qui aboutit à la disparition de la seconde entité montée
=====> Autre probleme corrigé : les ConstraintWeld2D à enlever doivent bien etre celles lié le node au parent

- 14/05/2020 : avec les ailes Darkren sur le Lizard, probleme d'affichage lorsqu'il meurt, pas d'animation pour les ailes qui restent en place alors que le lizard est au sol.
=> il faut modifier les SCML du lizard et des ailes
==> OK : probleme corrigé dans AnimatedSprite2D::UpdateSourceBatchesSpriter_RenderAnimations => il faut passer par renderEnabled_ pour activer/desactiver le rendu.

- 14/05/2020 : corriger le MOVE2D_FLY : si l'on reste appuyer sur le JUMP et que l'on appuie successivement sur LEFT-RIGHT-LEFT-RIGHT, l'entity monte super vite
=> mettre un max de velocity à ne pas dépasser => GOC_Move2D::velMaxFlying
==> OK : modification de GOC_Move2D::Update_Fly() et GOC_Move2D::ControlUpdate_Air()

- 03/05/2020 : encore des crashes avec les GOC_Spawner (cf Urho3D::ParticleEmitter2D) en WorldZone lors de l'utilisation de Map::SetEntities_Load()
=> Mettre les MonsterSpawner en categorie Object ald Monsters
=> faire des tests en TestZone2 avec seulement MonsterSpawner en type autorisé.
==> Pb avec l'attribute BlendMode de ParticuleEmitter2D (enumvalues ?) qui se desinitialiser en 0 ou valeur tres grande.
===> 05/05/2020 : OK Patch appliqué à ParticleEmitter2D::UpdateMaterial() pour le moment

- 05/05/2020 : Les effects (Feu/Poison) sont appliquées sur des entités n'appartenant pas à la meme view.
=> Lors d'un contact, il faut checker si sur la meme View comme dans GOC_Detector.
==> cf GOC_Collide2D::HandleBeginContact() et GOC_ZoneEffect::HandleContact()
===> OK : Correctif dans GOC_ZoneEffect

- 03/05/2020 : Crash sur RPI
=> Correctif de GOC_Collectable
=> Correctif de GameHelpers::SetCollectableProperties()
=> Correctif de Urho3D::ParticleEmitter2D
=> Modification ObjectPool::CreateChildIn() permettant le spawn de CollectablePart (Bone)
==> OK

- 29/04/2020 : lors du Spawn d'une Raignee, elle peut etre mal flippé en Y.
=> OK : Ajout de GOC_Move2D::CleanDependences() et reset de GOC_Move2D::moveStates_

- 27/04/2020 : modifier/reactiver le GOC_Spawner et tester dans le mode ARENA.
=> Utiliser World2D::SpawnEntity() ald GameHelpers::SpawnGOtoNode()
==> OK

- 26/04/2020 : apres avoir pris le GOC_Portal, le player (skeleton) a le fil d'araignee et les ailes de Darkren d'activés.
=> GOC_Portal Teleporte avec le TimerRemover ENABLENODE DISABLE qui utilise simplement Node::SetEnabled()
==> Ajout dans GameHelpers::CopyAttributes() de dest->RemoveAllChildren()
===> Pb avec ObjectPool utilisant aussi GameHelpers::CopyAttributes
====> OK : déplacement de dest->RemoveAllChildren() dans Actor et GOC_Controller

- 25/04/2020 : GOT_Raignee => les physic Colliders lorsque en Climb Left|Right ne sont pas centrés/AnimatedSprite ce qui posent des problemes au niveau des passages etroits notamment.
=> OK : voir GOC_Animator2D::wallFlipping_ float devient Vector2 pour ajouter le recentrage vertical.

- 19/04/2020 : regler les problemes de direction des animations suite aux ajouts du 11/04/2020
=> GOC_Animator2D et GOC_Move2D utilisent ObjectControlLocal::direction_ (float) pour la direction X
=> GOC_Move2D utilise aussi le moveState MV_DIRECTION pour communiquer s'il s'agit d'un mur à gauche ou à droite du Climber.
==> lorsque le climber avec wallFlipping_ s'accroche sur un mur, il faut setter la direction en fonction de la velocity Y (si vely positif => direction == LEFT == UP)
===> OK : il reste un probleme dans les coins droits (en haut et bas)
====> OK 20/04/2020 : modification de la logique dans GOC_Animator2D::CheckDirection()  et modification GOC_Move2D::Update_Climb() + GOC_Move2D::Update_Walk() + GOC_Move2D::ControlUpdate_Ground()
=====> GOC_Animator2D::CheckDirection() est renommé GOC_Animator2D::ApplyChangeDirection() et sera utilisé à chaque changement d'animation donc plus nécessaire dans Preloader.xml AnimatorTemplate_Spider

- 11/04/2020 : ajout de l'araignee : c'est un climber
=> Ajout de l'AnimatorTemplate_Spider
==> modification de GOC_Animator2D + GOC_Move2D et Urho3D::AnimatedSprite2D::UpdateSourceBatchesSpriter_OneMaterial() pour permettre la rotation de l'animatedSprite (marche sur les murs)
===> OK à modifier GOC_Animator2D::CheckDirection() pour que les offsets transmis à Urho3D::AnimatedSprite2D::SetLocalPosition() correspondent aux dimensions des collisionShapes.
===> voire pour developper un composant (ou deriver le GOC_PhysicsGrapin ?) pour la gestion du fil de l'araignée :
=====> OK : trouver un point d'ancrage lors du fall et lors du jump,
=====> OK : si un point d'ancrage est trouvé, attache du fil entre le point d'ancrage et l'araignée
=====> OK : mise à jour du fil (thread) : longueur et angle entre le point d'ancrage et l'araignée.
======> le fil doit etre deformable en longueur => voir pour integrer Urho3D::StrechableSprite2D
=======> Urho3D::StrechableSprite2D intégré OK, néanmoins pour le fil ce ne sera pas nécessaire, un simple scale d'un staticsprite suffira
=======> le scale ne fonctionne pas, il faut pouvoir modifier le drawRect du staticsprite => integration dans Urho3D::StaticSprite2D de SetDrawRect() et UseSetDrawRect() de Urho3D-1.7
====> l'araignee doit avoir la possibité de monter ou descendre de son fil. (passer en CLIMB MV_TOUCHOBJECT)
=====> OK CTRL_JUMP pour monter
====> OK : modification du GOB_FollowAttack et GOB_Follow pour tenir compte du Climb et du fil. => OK pour le Climb
====> OK : tenir compte du node scale pour la longueur du fil.
========> OK le 16/04/2020 : Implementation fonctionnelle de GOC_StaticRope.

- 06/04/2020 : Modification de Urho3D::PhysicsWorld2D::BeginContact() pour permettre le passage en mode plateform (check one way) pour les rigidbodies qui ne sont pas des MapCollider mais qui veulent permettre ce mode
=> utilisation dans les fournitures tel que Armoire ou Table par exemple
=> il faut déclarer ces rigidbodies avec body->SetColliderInfo((void*)1)
==> tous les nodes mettant GOA_Plateform à true auront ce mode
==> OK : ajout de GOA::PLATEFORM et modification de GOC_Destroyer::UpdateFilterBits() et de GOC_Move2D::CheckGoDownWall()

- 24/03/2020 : le lizard n'inflige plus aucun dégat
=> le collider Trig_Attack s'affiche bien
==> Le Trig_Attack doit etre renommé TA depuis xx/02/2020 !
===> ok pour l'ensemble des SCML et recopie dans FromBones_Resources

- 05/03/2020 : modifier le point d'application pour les Effects avec Tick qui sont par defaut à la position ZERO sur le node recevant l'effet.
=> enregistrer le point d'impact meme si ce n'est pas une GOC_ZoneEffect
==> OK : ajout de EffectInstance::localImpact_ et modification EffectsManager::AddEffectOn et EffectsManager::Update

- 19/02/2020 : Resoudre les problemes de states d'equipment
=> finir Equipment::Dump() qui est utilisé dans Player::Dump() et log via "dumpplayer" dans la console
==> les equipments ne doivent impacter la valeur d'attaque ou de defense que si les slots d'equipements existent pour l'avatar => check AnimationEquipment::HasSlot(slothash)
===> pour le moment Equipment n'a pas acces à AnimationEquipment (qui est dans UIC_EquipmentPanel)
====> déplacement d'AnimationEquipment dans Equipment et modification Equipment::UpdateAttributes() (ajout de !AnimationEquipment.HasSlot())
=====> OK : verifier si pas de redondance dans les updates
=> les degats de feu ou autre effets doivent etre opposés à la défense de meme type et pas sur GOA::DEFENSE
==> verifier le GOC_ZoneEffect avec l'effet de Flame de Darkren
===> pour le moment tous les degats sont en GOA::ENERGY
===> GOC_Life::HandleReceiveEffect doit etre modifié pour accepter d'autre type d'effet.
====> OK ajout de GOA::FIRE et modification de GOC_Life et d'Equipment
==> RAF : renommer GOA::ATTACK et GOA::DEFENSE qui ne doivent etre que pour le CaC en GOA::LIFE, renommer egalement GOA::ENERGY en GOA::LIFE (implique de modifier dans toutes les ressources xml)
===> les Collectables pourront avoir des resistances aux differents effets de base GOA::LIFE, GOA::DEATH, GOA::FIRE, GOA::WATER, GOA::MATTER, GOA::VOID, GOA::TIME
====> une valeur positive sur l'un de ces attributs ajoute un bonus en defense sur le type d'effet correspondant
====> une valeur negative sur l'un de ces attributs ajoute un bonus en attaque sur le type d'effet correspondant
=====> OK : remplacement de GOA::ENERGY,GOA::ATTACK et GOA::DEFENSE par GOA::LIFE
======> ajout de Equipment::defenseEquipmentBonus_ et Equipment::attackEquipmentBonus_ pour remplacer Equipment::equipmentAttributes_ pour le stockage des bonus de defense et d'attack pour chaque type d'effet de base.

- 20/02/2020 : pour un collectable (ex: potion regen), avoir un GOC_ZoneEffect lorsque l'effet à plusieurs tick n'est pas approprié. Il faudrait un manager plutot qu'un composant qui serait lui reseté des que le collectable sera supprimé.
=> Ajouter un manager pour les Effets de zone : MAN_ZoneEffect.h => class ZoneEffectManager
==> ce manager reprendra la gestion de GOC_ZoneEffect mais en static, chaque GOC_ZoneEffect y sera déclaré
===> OK : 28/02/2020 ajout de EffectsManager qui prend en charge la gestion des effets applicables à des nodes. GOC_ZoneEffect y fait appel. => ajout de PotionRegen en test OK
===> RAF1 : on pourra également ajouter les effets d'une arme (tel que poison...) qui s'appliquent s'en avoir besoin d'une ZoneArea.
====> GOC_Collide2D doit faire appel à EffectsManager::AddEffectOn(0, node_, effect) GOC_Attack doit maintenir les effects qui seront transmis à EffectManager.
====> OK : 01/03/2020 modification de GOC_Collide2D, de GOC_Attack et de Equipment::UpdateAttributes() : recherche de GOA_EffectID1à3 et enregistrement dans Equipment::equipmentEffects_ accessible via GOC_Attack::GetEquipmentEffects()
    GOC_Collide2D utilise EffectsManager::SetEffectsOn()->AddEffectOn() permettant de recuperer les effets à appliquer des attacks/effets utilisés par l'attaquant.
===> RAF2 : il faut egalement penser a ajouter une propriété qui permet de supprimer un effet actif des que l'entité qui a provoquer cet effet meurt (pour certains sortileges notamment)
=> comme pour la gestion des resistances aux effets gerer par GOC_Life (cf LifeProps::defBonuses_), il faut une gestion des attaques par type d'effet qui sera mis à jour lors du changement d'equipment / avatar.
==> de plus les defense et attaque de base doivent egalement etre enregistrés par effets de base
===> OK : ajout de AttackProps et modification majeure dans GOC_Attack, utiliser GOC_Attack::GetUsedEffects() et GOC_Attack::GetDamage(effect) pour obtenir la liste des AttackProps equipés et les damages par effet.
==> commonaliser le SendEvent(GO_RECEIVEEFFECT) dans GOC_Collide2D::HandleBeginContact() et GOC_ZoneEffect::HandleScenePostUpdate()
===> remplacement de GOC_Life::HandleReceiveEffect() par GOC_Life::ReceiveEffectFrom(), envoyer qd meme l'event GO_RECEIVEEFFECT pour les subscribers comme ScrapsEmitter.

- 17/02/2020 : ajout des ailes en slot renderanimation.
=> changer le type de GOC_Move2D si equipé et effectif
==> ajouter l'ability ABI_Fly => OK
===> modifier ABI_Fly pour etre plus generique, des problemes à corriger lors de l'activation / desactivation de l'abilité
===> RAF : tester dans GOC_Move2D::UpdateAttributes() lorsque le flag MV_WALK est enclenché si l'entité touche le sol.
====> OK 21/02/2020 : Correctif GOC_Move2D
===> RAF2 : pouvoir specifier l'echelle d'un renderAnimation (les ailes de darkren paraissent trop petites sur le lizard)
====> modification de AnimatedSprite2D::AddRenderedAnimation(), ajout du scale provenant de Spriter::NodeUpdater::timekey_ qui est un Spriter::SpriteTimelineKey
=====> pb : Spriter ne sauvegarde pas les scale_x et scale_y des Point, il faut les rajouter manuellement dans le SCML.
        ex : <timeline id="41" name="IN_Special1" object_type="point">
                <key id="0" spin="0">
                    <object x="44.682365" y="30.511911" angle="281.507731" scale_x="2" scale_y="2"/>
                </key>
             </timeline>
=====> OK : le faire manuellement pour le moment

- 29/01/2020 : ajout de GOT_Darkren
=> ajout de GameHelpers::SetPhysicFlipX() permettant le flipX des collisionBox2D qui ont un angle ou un decentrage suivant x.
==> utilisation dans GOC_Animator2D::OnChangeDirection()
==> Faire des tests avec GOT_RockGolem pour voir si mauvais impacts.
===> voir pour la possibilité de filtrer le collider de pied de Darkren qui est en flamme est donc ne devrait pas entrer en collision avec les autres entités.
===> utiliser le collider mask CM_INSIDEEFFECT et CM_OUTSIDEEFFECT
===> Modifier l'attribut CollisionShape2D::ExtraContactBits pour ajouter ce bit Effect
====> ajouter aussi un trigger pour mettre en feu l'entité touchée. => utilisation de GOC_ZoneEffect.
====> les bombes ne traversent pas le collider pied
=====> CONTACT_ISEFFECT est renommé CONTACT_BODILESS, ajout des CM_INSIDEBODILESSPART et CM_OUTSIDEBODILESSPART, modification de GOC_Destroyer::UpdateFilterBits()

- 05/02/2020 : GOC_Animator2D::SpawnAnimationInside fonctionne après correctif mais utilise un trigger de SPRITER pour chaque animation ce qui est lourd à gérer.
=> préferer utiliser le CharacterMapping. Pour les entities qui n'ont pas d'Equipment, verifier le contenu de l'inventaire à la recherche d'objet Wearable
=> Etendre le CharacterMapping pour ajouter des nodes contenant des AnimatedSprite2D en plus des Sprite2D (utilisation de RenderNode de AnimatedSprite2D dans ce cas comme en utilisant GOC_Animator2D::SpawnAnimationInside)
=> cf GOC_Inventory::EquipSlotOn() et AnimatedSprite2D::SwapSprites()
==> suppression de GOC_Animator2D::SpawnAnimationInside et remplacement dans GOC_Inventory::EquipSlotOn()
==> AnimatedSprite2D::renderNodes_ devient AnimatedSprite2D::renderedAnimations_
==> dans Spriter, il suffit d'ajouter un point dans le nom commence par IN_ suivi du nom du mapping (ex:Weapon1) pour déclencher dans Urho3D l'affichage d'un RenderedAnimation (qui est un AnimatedSprite2D) dans l'AnimatedSprite2D
===> faire attention de bien setter l'angle de ce point
====> OK le 10/02/2020 avec essai sur RPI3 ok

- 23/12/2019 : lorsqu'une entité tape sur une autre qui marche, l'entité tapée reste coincée ave animation fall
=> pb de collision ? cf GOC_Collide2D
==> pb dans GOC_Move2D::Update_Walk() lorsque GOC_Life::ApplyForceEffect est utilisée, la velocity peut prendre une valeur inf à -velMinFalling qui occasionne un fall
===> verifier aussi les autres Update et rajouter la condition !(moveStates_ & (MV_TOUCHGROUND | MV_CLIMB)
=> OK !

- 05/02/2020 : en utilisant l'attribut "Auto Switch Attack", le switch s'opere pour tout type d'animation (idle, walk etc...) et donc pas uniquement pour les attaques.
=> cf dans GOC_Animator2D
==> OK : attribut remplacé par "Auto Switch Animations"

- 03/01/2020 : Déplacement non interruptible lors d'un saut ou en vol jusqu'à une collision
=> cf GOC_Move2D ou GOC_Collide2D
==> OK : Correctif dans GOC_Move2D::Update_Fly() et GOC_Move2D::Update_Walk().

- 28/12/2019 : lorsqu'une entité est morte et que la camera la rend invisible puis revisible, l'animation respawn au debut du temps de mort.
=> cf GOC_Destroyer et GOC_Animator2D, AnimatedSprite2D
==> Modification dans Urho3D::AnimatedSprite2D::UpdateAnimation() => la condition de !visibility_ ne doit pas reseter l'animation
===> impact sur les objets tel que money qui ne s'affiche plus sans interaction physique
====> OK : Modification dans Urho3D::AnimatedSprite2D::UpdateAnimation() ajout de Drawable2D::ForceUpdateBatches()

- 15/12/2019 : parfois certains collectables ne peuvent pas être ramassés. Identifier la cause de ce bloquage.
=> En Mode Server, apres avoir eté en Arena, GameStatus::AllowUpdate_ vaut false lorsque le mode World est lancé.
==> en mode server, GameNetwork attend que tous les clients soient lancés pour permettre la prise des objets.
==> verifier si des clients existent autrement activer GameStatus::allowUpdate_.
===> OK : Modification GameNetwork::HandlePlayServer_NetworkUpdate

- 15/12/2019 : Le contenu des coffres devient de plus en plus gros à mesurer du changement de map. GOC_Inventory::SetInventoryAttr() n'utilise pas de ResetSlots()
  les slots sont générés une fois lors du chargement du template node puis clonés avec ObjectPool. l'AutoPopulatedSlots permet de générer un contenu different pour chaque clone.
  mais mal utilisé dans le OnSetEnabled() aboutit tjrs au meme inventaire.
-> choix de toujours générer un contenu différent : autopopulatedslot devient obsolete.
--> le VariantVector valuesToPopulated_ est utilisé uniquement par le templatenode lors du GOC_Inventory::AddToSlotAttr()
--> les clones n'auront jamais ce variantvector d'initialisé car le Getter de l'attribut "Add To Slot" return un champ vide.
---> lorsque le template est cloné, le VariantVector est uniquement transmis par valeur le GOC_Inventory::GetInventoryAttr() -> GOC_Inventory::SetInventoryAttr()
    ce qui permet de setter un inventaire different si valuesToPopulated contient des RANDOM.
--> quand un coffre a été vidé par une entité et que la map est déchargée et donc sauvegardée, l'inventaire vide est sauvegardé via GOC_Inventory::GetInventoryAttr().
--> au retour sur cette map, le coffre sera bien vide.

- 14/12/2019 : Modification du Behavior::GOB_Patrol pour ajouter le saut.
-> GOB_Patrol fait appel à GOC_Destroyer::HasWallInFront() qui utilise le WorldMapPosition::shapeRectInTile_ defini dans GOC_Destroyer::UpdateShapesRect()
--> Tous les Controllers doivent faire appel à GOC_Destroyer::UpdateShapesRect() à leur initialisation pour pouvoir utiliser GOB_Patrol
---> OK : Déplacement du UpdateShapesRect() de Actor::Start() dans GOC_Destroyer::OnSetEnabled() et limitation aux controllers uniquement.

- 05/12/2019 : à l'apparition avec petit, le changement de viewZ par le dessus retourne dans tous les cas un bloquage dans le mur
-> verifier que GOC_Destroyer::UpdateShapesRect() soit utilisé à l'initialisation du premier avatar et pas seulement au moment du changement d'avatar
==> OK : correctif dans Actor::Start();

- 30/10/2019 : pb ce changement de viewZ dans la situation specifique suivante : en frontview se mettre sous un passage et monter => l'avatar est bloqué dans le mur en innerview.
-> GOC_Destroyer::UpdatePositions() va tester le rectangle de chaque collisionshape via Map::CheckFreeTilesAtViewZ()
--> lors du changement d'avatar ces rectangle ne sont pas mis à jour.
---> ajout de GOC_Destroyer::UpdateShapesRect() et utilisation dans Player::UpdateAvatar()
----> OK : dans GOC_Destroyer::UpdateShapesRect(), calcul du rectangle englobant des shapes, simplification de Map::CheckFreeTilesAtViewZ()

- 24/10/2019 : En changeant d'avatar en haut d'une piece, le nouvel avatar plus gros se retrouve coincé dans le plafond
-> lors du changement d'avatar, lorsqu'un wall est voisin, realigner l'avatar sur le centre du tile ou se situait l'ancien avatar.
--> cf Player::UpdateAvatar()
---> Ajout de GOC_Destroyer::AdjustPositionInTile() et Map::AdjustPositionInTile()
    + Modification GOC_Destroyer::SetWorldMapPosition() correctif centre de masse.
----> OK le 02/11/2019 : la position est ajustée pour le moment seulement quand l'actor est démarré. Actor::Start(). Actor::Start() est utilisé dans Player::UpdateAvatar()

- 07/10/2018 : certains problemes de changement de viewZ pour les avatars
=> detecter en mode world (testzone), en changeant d'avatar mais sans passer en INNERVIEW (sans prendre une porte)
=> vérifier la chaine de changement
==> ViewManager, GOC_Destroyer, Player
===> suppression de la variable currentViewZ_;
====> faire des tests
-> 23/10/2019 : avec petit pas de pb, mais lizard se retrouve souvent bloquer dans un mur en voulant passer une porte par le dessus
--> cf GOC_Destroyer::UpdatePositions()
---> les avatars etant composés de plusieurs collisionshapes, il faut s'assurer que chaque centre de ces formes ait le meme tileposition
----> dans avatar-...xml, en utilisant bien UseFixtureMass=False et changeant le MassCenter de lizard toujours le pb
----> en utilisant la Version de GOC_Destroyer::GetUpdatedWorldPosition2D version drawable, le pb n'apparait pas.
-----> 24/10/2019 : modification de GOC_Destroyer::GetUpdatedWorldPosition2D Drawable pour utiliser le MassCenter si pas de drawable
------> 02/11/2019 : repasser en GOC_Destroyer::GetUpdatedWorldPosition2D version physic centre de masse suite aux resolutions de
        tous ces pb de changement de viewZ et de stuck lors du changement d'avatar. cf  24/10/2019 et 30/10/2019 ci-dessus.

-> GOB_MountOn : poids trop important des players montés => diviser par deux le poids lorsque monté
--> OK

- 30/10/2019 : le transfer par le portail des entities montés n'est pas fonctionnel
-> les entities montées ne sont plus parentées a l'avatar
--> OK : modification de GOB_MountOn pour le SetParent + modification Player::UpdateAvatar() pour eviter le scaling au moment du changement d'avatar

- 28/10/2019 : les skeleton montés sur avatar ne changent pas de viewZ lorsque l'avatar effectue un changement de viewZ
-> OK : Ajout de l'event GO_CHANGEVIEWZ.
--> 30/10/2019 : suppression de l'event et des methodes associées et remplacement dans GOC_Destroyer::SetViewZ() par la mise à jour du viewZ des entités montées.

- 28/10/2019 : les skeleton en demontant restent ensuite en animation idle
-> OK : dans GOB_MountOn::Stop() ajout GOC_Animator2D->ResetState()

- 28/10/2019 : apres certains passages de portail, l'avatar se trouve coincé dans un mur
-> il s'agit de la position y du GOT_START (n'ayant pas de drawable ni de rigidbody)
--> OK : correctif dans GameStatus::FindMapPositionAt()

- 28/10/2019 : Crash dans Slot::SetSlotAttr quand aucun type (par exemple des Parts de Elsarion)
-> OK, a tester avec des parts d'elsarions en changeant de map pour la sauvegarde des entities et le rechargement par SetEntities_Load
--> OK

- 06/10/2018 : en arena, probleme d'accroche sur le mur droit dans la cave
=> probleme de normal de collisionchain => normal inversée !
==> meme cause que l'issue du 06/10/2018 (MAPWORLD) concernant les collisionshape de background
==> modifier le seuil d'accroche ou de rebond à 0.1f ald 0.f
===> GOC_Collide2D::AddWallContact2D ajout de ...Abs(normal.y_) > 0.1f... => OK!

- 11/09/2018 : le use object ne fonctionne plus (utilisation des potions)
=> voir UISlotPanel::HandleSlotDragEnd()
==> OK remplacement du GetBoundingBox par GetWorldBoundingBox

- 10/09/2018 : ajout de RockGolem => comment faire pour que le bodycollider épouse le sprite du corps (rotation compris) ?
=> voir pour PhysicTrigger dans AnimatedSprite2D
==> OK le 11/09/2018 : modification dans AnimatedSprite2D::UpdateTriggers + Box2D + Urho3D::CollisionBox2D ajout pivot pour la box

- 06/09/2018 : spawn des bombes dans le ground
=> analyser GOC_Animator2D::SpawnEntity() et Map::AddEntity()
==> surement encore un probleme dans le positionnement des triggers dans AnimatedSprite2D
===> probleme de flipX avec les triggers
====> OK, correctif dans AnimatedSprite2D::LocalToWorld(), (pb d'angle) + dans GOC_Animator2D::SpawnEntity() : (direction plus nécessaire puisque l'angle est bien réglé)

- 31/08/2018 : GOC_BodyExploder2D, probleme de charactermapping (des sprites n'apparaissent pas) apres changement de map et retour sur la map avec des newskeleton mappés
=> dans Map::SetEntities_Load() le entityId est setté à 0 ce qui implique l'utilisation de l'entity id 0 de l'animatedsprite
==> dans ce cas (loading attributes), l'entity ne doit pas être attribuée via GameHelpers::SetEntityVariation() mais par les attributs sauvegardés
===> ajout dans ObjectPoolCategory::GetPoolNode() de entityid=-2 permettant d'éviter le GameHelpers::SetEntityVariation() pour Map::SetEntities_Load()

- 29/08/2018 : GOC_BodyExploder2D, certains skeletons qui meurent, disparaissent sans laisser de bones.
[Wed Aug 29 23:49:37 2018] INFO: Map() - SetEntities Load : Map=13 1 Entities[1] : name=GOT_NewSkeleton2(16792199) position=1084.72 163.83 ... OK !
[Wed Aug 29 23:49:38 2018] INFO: Map() - SetEntities Load : Map=13 1 ... From Memory on nodeEntities = Map_13_1
[Wed Aug 29 23:49:38 2018] INFO: Map() - SetEntities Load : Map=13 1 ... timer =0 ms ... OK !
---- puis
[Wed Aug 29 23:50:23 2018] INFO: GOC_Life() - HandleLifeUpdate : GOT_NewSkeleton2(16792199) is Dead !
[Wed Aug 29 23:50:23 2018] INFO: GOC_BodyExploder2D() - OnTrigEvent : Node=GOT_NewSkeleton2(16792199)
[Wed Aug 29 23:50:23 2018] INFO: GOC_BodyExploder2D() - UpdatePositions node GOT_NewSkeleton2(16792199) ...
[Wed Aug 29 23:50:23 2018] INFO: GOC_BodyExploder2D() - TransferExplodedNodesPositionsTo : node=GOT_NewSkeleton2(16792199) 0 0 to 1088.51 156.183  ... OK!
[Wed Aug 29 23:50:23 2018] INFO: GOC_BodyExploder2D() - UpdatePositions node GOT_NewSkeleton2(16792199) ... position=1088.51 156.183 0 OK !
[Wed Aug 29 23:50:23 2018] INFO: GOC_Collide2D() - HandleDead : Node=GOT_NewSkeleton2(16792199) ... disable topcontact
[Wed Aug 29 23:50:23 2018] INFO: GOC_AIController() - StopBehavior Patrol
[Wed Aug 29 23:50:23 2018] INFO: PlayState() - HandleUpdateScores : Dead Entity ID=16792199, killed by ID=16803725
[Wed Aug 29 23:50:23 2018] INFO: Player() - OnDead : Avatar Node=16803725 kills node=16792199
[Wed Aug 29 23:50:23 2018] INFO: ActorStats() - DumpStat : category=3197354476, stat=GOT_NewSkeleton2, value=4
[Wed Aug 29 23:50:23 2018] INFO: GOC_BodyExploder2D() - Explode : node GOT_NewSkeleton2(16792199) ... in 14 nodes ...
[Wed Aug 29 23:50:23 2018] INFO: GOC_BodyExploder2D() - Explode !
[Wed Aug 29 23:50:28 2018] ERROR: GOC_Animator2D() - ApplySimpleAnimations : GOT_NewSkeleton2(16792199) currentStateIndex=2 no animationname !
[Wed Aug 29 23:50:28 2018] INFO: GOC_Animator2D() - ToDestroy : Node=GOT_NewSkeleton2(16792199) Send WORLD_ENTITYDESTROY
[Wed Aug 29 23:50:28 2018] INFO: GOC_Destroyer() - OnWorldEntityDestroy : GOT_NewSkeleton2(16792199) ...
[Wed Aug 29 23:50:28 2018] INFO: GOC_Abilities() - AddAbility : new Ability = 1506844804 ... OK !
[Wed Aug 29 23:50:28 2018] INFO: GOC_BodyExploder2D() - ApplyAttributes : GOT_NewSkeleton2(16792199)
[Wed Aug 29 23:50:28 2018] INFO: GOC_BodyExploder2D() - PrepareNodes node GOT_NewSkeleton2(16792199) ...
[Wed Aug 29 23:50:28 2018] INFO: GOC_BodyExploder2D() - PrepareExplodedNodes : nodeID=16792199 fromAnimation=dead wposition=0 0 usePool=true ...
[Wed Aug 29 23:50:28 2018] INFO: GOC_BodyExploder2D() - PrepareExplodedNodes nodeID=16792199 : ... numExplodedNodes=10 OK !
[Wed Aug 29 23:50:28 2018] INFO: GOC_BodyExploder2D() - PrepareNodes node GOT_NewSkeleton2(16792199) ... OK !
[Wed Aug 29 23:50:28 2018] INFO: GOC_Life() - UpdateProperties : GOT_NewSkeleton2(16792199) ... Update Props(life=1, energy=1, dpsreceived=0)
=> voir si le probleme provient du Map::SetEntities_Load()
==> il s'agit d'un probleme de scaling pour les explodes parts, celles-ci sont tres petites presque invisibles et tombent dans les murs en général
===> correctif dans GOC_BodyExploder2D::TransferExplodedNodesPositionsTo()
        Vector2 deltaScale = rootNode->GetWorldScale2D()/initialScale_;
        if (abs(deltaScale.x_) > PIXEL_SIZE)
        {
            prepareNode_->Scale2D(deltaScale);
            URHO3D_LOGINFOF("GOC_BodyExploder2D() - TransferExplodedNodesPositionsTo : node=%s(%u) scale to %s (rootNodeScale=%s/initialScale_=%s) ... OK!",
                            rootNode->GetName().CString(), rootNode->GetID(), deltaScale.ToString().CString(), rootNode->GetWorldScale2D().ToString().CString(), initialScale_.ToString().CString());
        }

- 29/08/2018 : GOC_Portal : apres franchissement d'un portail, le portail a destination ne se réactive pas
=> correctif dans GOC_Portal:OnSetEnabled() => si enabled UnsubscribeFromEvent(PORTAL_REACTIVE) si disabled & et dans le Pool UnsubscribeFromEvent(PORTAL_REACTIVE)

- 25/08/2018 : A la mort d'une entity desactiver le Collider corps (Extra Contact Bits=0). il restera le Collider pied.
=> creation de GOC_Collide2D::SetCollidersEnable
=> remplacement de CONTACT_ALLOWBOTTOM par CONTACT_BOTTOM (plus simple)
=> remplacement de extrabits (0) par (CONTACT_TOP+STABLE=3) pour l'ensemble des objects

- 07/05/2018 : ajouter les colliders boxes pour le corps des entities et voir pour modifier GOC_Collide2D et GOC_Destroyer, Impact sur Behavior Mounted ?
=> dans GOC_Destroyer modifier UpdateFilterBits pour l'ensemble des collisionshapes => OK
=> pb lors de la descente d'une plateforme : l'entité se raccroche avec le second collidershape à la plateforme
==> remplacement de l'attribut CollisionShape2D::colliderStability_ par extraContactBits_
===> Modification Urho3D::PhysicWorld2D::BeginContact pour permettre le contact seulement si (otherShape->GetExtraContactBits() & CONTACT_ALLOWBOTTOM)
===> modifications de tous les Object.xml pour remplacer cet attribut et indiquer l'extraBits les collider (le collider de "corps" doit avoir l'extrabits a 0 pour ne pas permettre la collision avec plateforme)
===> OK le 07/06/2018.

- 10/04/2018 : revoir le JUMP :
=> pb avec moins de 60 fps
=> le player monte à l'infini si en cours de saut, les seuils de montée et de descente ne sont pas atteints (basés sur la vitesse)
==> pour reproduire ce bug, essayer de se mettre sous un mob et de sauter, ou bien sauter et rester appuyer au niveau d'un plafond
===> introduction d'une hauteur maximale de saut
===> 06/06/2018 : OK pour le bloquage du saut lorsque touchroof => correctif dans GOC_Move2D
===> OK le 07/06/2018, RAF => checker à moins de 60 fps

- 02/06/2018 : la chaine du grapin ne s'affiche plus.
=> Pb avec RigidBody2D::ApplyWorldPosition suite à modification après la version du 23/04/2018 (node position2D)
==> en utilisant node_->SetWorldPosition(ToVector3(transform.p)); ald SetWorldPosition2D tout rentre dans l'ordre
===> voir dans Node pour régler ça et remettre SetWorldPosition2D
====> il faut finir de remplacer dans les derive de Drawable2D, les Matrix3x4 par des Matrix2x3, les GetWorldPosition et GetWorldTransform par leur équivalent 2D
      et modifier OnWorldBoundingBoxUpdate et GetWorldBoundingBox() de drawable à remplacer dans Drawable2D
====> point de sauvegarde 04/06/2017 avec le compromis dans RigidBody2D
=====> en cours de modification : Pb avec BodyExploder2D => corriger le StaticSprite2D::WorldBoundingBoxUpdate avec BoundingBox::Transformed(Matrix2x3)
======> il s'agit d'un probleme dans le calcul de la translation dans la Matrix2x3::Inverse() => correction ok
=======> StaticSprite2D et RigidBody2D sont désormais OK avec SetWorldPosition2D

- 31/05/2018 : pb de Drop Items dans le FrontView, les colliders ne font pas leur job => traverse les murs
=> Analyser les attributs de l'entité droppée voir pour le zview et les collider filters
=> voir UISlotPanel::HandleSlotDragEnd() && GOC_Collectable::DropSlotFrom()
==> Bug difficile à reproduire
====> bug resolu avec le pb du grapin ci-dessus

- 02/06/2018 : la bombe n'explose plus
=> correction dans GOC_Animator2D_Template::AddState() => generait 2 STATE_DISAPPEAR due à l'utilisation de GetSignedStateIndex(unsigned) à lieu de GetSignedStateIndex(StringHash)
==> Pas de Scraps
===> Urho3D::AnimatedSprite2D::UpdateTriggers() patched : SendEvent mal placer ne permettant pas d'envoyer des Events sans parametres
====> OK !

- 11/05/2018 : Ajouter à GOC_DropZone (Sanctuaire) la possibilité de spawner une entité spécifique (characterMaps) en fonction des objets ajoutés (genre épée avec bone = warrior skeleton)
=> OK le 31/05/2018 ajout de GOC_DropZone::SelectBuildableEntity && BuildableObjectInfo dans GameAttributes.

- 30/05/2018 : Les entities réapparaissent une fois mortes (sauf les entities avec BodyExploder2D)
=> pas de probleme dans version FromBones_master-WIP20180423-PatchBackScroller
=====> inversion de parametre d'entrée "nextstate" & "condition" dans GOC_Animator2D_Template::ApplyEventToStates pour AEvent_EndLoop avec "State_Disappear"
       lors du GOC_Animator2::RegisterObject()
======> OK le 30/05/2018 !

- 28/05/2018 : probleme lors du Get Item, l'item va bien dans l'inventaire cependant il n'est plus effacé de la scene
=> pas de pb avec la version FromBones_master-WIP20180423-PatchBackScroller
==> GOC_Animator2D checker les templates Avec le AAction_ToDestroy pour les 2 versions
===> version courante : l'enregistrement ne semble pas fonctionner pour l'AAction_ToDestroy
===> version FromBones_master-WIP20180423-PatchBackScroller : AAction_ToDestroy apparait bien dans les logs
====> comparer les diff dans l'enregistrement des GOC_Animator2D_Template.
=====> oubli de la prise en compte du nouveau parametre d'entrée "condition" dans GOC_Animator2D_Template::ApplyEventToStates lors du GOC_Animator2::RegisterObject()
======> OK le 30/05/2018 !

- 22/05/2018 : Bloquer l'animation shoot directionnel si pas d'arme avec ability
=> ajout du composant GOC_Abilities pouvant être utiliser meme si pas d'Actor
=> Nouvelle Ability ABI_AnimShooter
=> GOC_Animator2D : ajout de SucceedTransition testant si la condition de la transition (passage d'un state à un autre) est validée
=> Modification de l'Enregistrement de NewEvent dans Preloader.xml => ajout de condition:ActiveAbility=ABI_AnimShooter
=> PirateGun => déclaration de l'ability ABI_AnimShooter
=> NewSkeleton2 => déclaration de l'ability ABI_AnimShooter comme wearable
==> OK le 25/05/2018!
=> gestion des AI cf AI

- 03/05/2018 : ajout des animations directionnels pour le skeleton shoot
=> ajout dans GOC_Animator2D=>AnimatorState de directionalAnimations_ (bool)
==> indique si le state est directionel
===> dans ce cas l'ordre des animations directionelles est le suivant : a[0] = Center; a[1]=45°UP; a[2]=90°UP; a[3]=45°DOWN; a[4]=90°DOWN
====> Ok le 10/05/2018

- 03/05/2018 : l'ability Lame a perdu la rotation
=> Ok correctif dans Node::SetWorldRotation2D()

- 23/12/2017 : Modifier les controles pour permettre l'ajout/suppression de TILES
-> ability comme grapin (genre magie chez "petit")
==> 26/04/2018 : ajout de ABI_WallBuilder pour petit
===> ajouter la possibilité de créer des tiles en diagonales haut et bas
===> OK !

- 26/04/2018 : Ajout de ABI_WallBreaker pour Buros
-> des sewing restent parfois après un remove tile et ajout de decals en outerview non souhaité lorsqu'un bloc est ajouté en INNER
==> lors de la supression de tiledimensions les anciens sewing restent
===> OK, oubli d'ajouter les SEWING dans ObjectTiled::ClearChunkBatches et ObjectTiled::SetChunkBatchesDirty
-> dans les addtile ou removetile vérifier si des furnitures sont sur le tile et les détruire
==> OK, un tileindex spécifique aux furnitures static permet d'enregistrer le tile sur lequel s'accroche la furniture. Il est donné dans Map::SetFurnitures (via eventData[Go_Appear::GO_TILE])
et intégrer dans GOC_Destroyer::OnWorldEntityCreate

- remettre les Sanctuary avec la ressurection des Skeletons
=> furniture comme Portal, mais avec GOC_DropZone
==> OK 18/04/2018, premier Test sur GOC_DropZone OK
===> OK 19/04/2018, spawn skeleton OK dans Arena, des problemes en mode Test si Object_Pool no more node

- Ajouter la possibilité de descendre d'un mur ou plateforme : flechebas+saut (04/08/2017)
=> 17/04/2018 OK : ajout de GOC_Move2D::CheckGoDownWall()

- 15/04/2018 : suite à changement dans le chargement des maps MapStorage::InitializeMap() qu'en mode delayed, le GOC_Portal ne peut obtenir une map en INSTANT
=> il faut donc delayer dans GOC_Portal
==> des problemes apparaissent lors du transfer
===> apres plusieurs teleportations, plusieurs portals sont superposés et si pris ils engendrent plusieurs teleportations
====> un oubli d'ajout GOT_Furniture aux listValue GOTYPEPROPERTIES de GameAttributes => OK !
===> NOTE : les Furnitures sont skipper lors du MapStorage::SaveEntities2Memory() (ce qui est plus rapide).
            Bien prendre en compte que cela ne permet pas de sauvegarder les changement de position de ces furnitures en cas de suppressions/ajouts des Tiles.
===> dans ces cas il arrive que le player aboutisse dans une map vide ce qui implique sa mort
====> pb dans GOC_Destroyer::SetWorldMapPosition() et RigidBody2D::ApplyApplyWorldTransform()
=====> la nouvelle position n'est pas prise en compte par RigidBody2D dans OnMarkedDirty à cause du physicsWorld_->SetApplyingTransforms(true) dans RigidBody2D::ApplyApplyWorldTransform()
======> création de RigidBody2D::ApplyUserWorldTransform()
=======> OK!
===> la teleportation arrive souvent dans le ciel en tile 1 2 (map sans GOC_Portal, ni GO_START)
====> le GameRand va tjrs donne le meme nombre car la seed est lié à chaque map du coup le tirage au sort est mal placer le mettre à la l'affectation sur la map (soit dans le OnSetEnabled)
=====> OK!
====> de plus des entities parasites GOT_Start sont encore dans la liste des entités arrivant à des situations impossibles (voir pb suivant)

- 16/01/2018 : GOT_Start ne sont pas retirés de la liste des entities dans World2D car pas de GOC_Detroyer
=> créer une PurgeEntities dans World2D appelé lors des UnloadMapAt
==> OK !

- 08/02/2018 : impossibilité de franchir certaines entrées des caves (outerview vers innerview) en testmode en zone AnlWorldModel
-> probleme de generation de collider ?
=> verifier dans une precedente version dans zone problematique => pas de pb a priori avec la precedente version 1.5
==> le ShrinkSelfCommonPoints réalisé dans MapColliderGenerator::CloseContour() pose problème dans la méthode GOC_Destroyer::UpdatePositions() à cause du
  ShrinkEpsilon appliqué pour grossir un peu les contours (afin d'éviter aux holes d'intersecter les contours)
===> 09/02/2018 : solution ne pas grossir les contours, seulement rétrécir les holes et tester
====> 09/02/2018 : atm ok

- remettre les Lames
=> OK en cours de test
=> voire pour le reseau

- reactivation des grapins
=> décrocher du grapin si changement d'avatar => OK
=> voire pour le reseau (surement à desactiver, juste pour le mode local)
=> pouvoir monter à la corde (must have)
=> pb de stability sur les grapins

- remettre les Portals :
=> 23/10/2017 : Reactivation avec nouveau portal
=> pb avec RigidBody2D qui bloque le changement de worldposition
==> il faut reinitialiser le RigidBody2D::bodyDef_.position dans RigidBody2D::ApplyWorldTransform pour permettre à RigidBody2D::OnMarkedDirty de bien mettre à jour box2D
=> RAF : Population des Portals et Connection des portals entre eux (setdestination), finaliser le setdestination avec viewz
==> 7/11/2017 : Ok ajout des Furnitures dont fait partie Portal, simple population sans objectif dans les dungeons, la map destination est établie au hasard
puis prend comme destination le premier portal disponible dans cette map; autrement prend comme destination le premier GOT_START trouvé dans la celle-ci.

- Changement de ViewZ : Ajout temporisation(switchViewEnable_) dans GOC_Destroyer::UpdatePositions et check Feature sur newViewZ dans ViewManager::SwitchToViewIndex
-> encore des stucks possibles (02/08/2017)
=> OK 03/08/2017 : MassCenter corrigé sur Vampire ; ajout GOC_Destroyer::IsOnTileBorder pour supprimer d'éventuels stuck par le haut si besoin (desactiver pour le moment)
==> (16/10/217) réapparition du problème de stuck dans les murs lors du changement de viewZ
==> 18/10/2017 : correction du problème provenant de GOC_Destroyer::GetUpdatedWorldPosition() => position du centre de masse doit être worldscaled
===> Attention fonctionne bien si le RigidBody2D a l'attribut UseFixtureMass = false
==> la temporisation avec switchViewEnable_ n'est plus nécessaire

- GOC_PhysicsGrapin (16/10/2017) : dans Urho3D Node::GetWorldPosition2D() pose probleme avec le grapin (chaine stressée).
-> Surement un pb lors du GOC_PhysicsGrapin::CreateChains : les Node::SetWorldRotation2D utilisées ne permettent pas la mise
   à jour Node::rotation2D_ (qui est ensuite utilisée par Node::GetWorldRotation2D().
   -> ce probleme est introduit à la mise en place des Matrix2x3 (mai 2017 - aucun pb avant sur grapin)
=> patch rapide dans Urho3D : mise à jour de Node::rotation2D_ à chaque changement sur Node::rotation_
==> quantifier l'impact sur les perf.

- Coffre se déclenche si entity n'est pas de type player. Les types player et Ally sont les seuls autorisés à se servir dans les coffres
=> OK (04/08/2017) : correctif dans GOC_Detector ; prend en compte seulement la body collisionshape de type trigger.
- Coffre ne se ferme pas apres depart du player
=> OK (04/08/2017) : Erreur d'event dans PreLoader.xml (Go_DetectorPlayerOut ald Go_DetectorPlayerOff)
- Ajouter Light pour le coffre lorsqu'il s'ouvre plein, l'eteindre quand vide ou se ferme :
=> OK (04/08/2017) : Ajout de GOC_Animator2D::LightOn, GOC_Animator2D::LightOff et GOC_Animator2D::ApplyNewStateAction se déclenchant à chaque changement de state,
  le currentState a ainsi une nouvelle possibilité de lancer une Action (en plus de celui déclenché via START_LOOP event)

- Suite à l'ajout du SWIM, bug après un firstboxjump dans l'animation walk (reste en "fall") (constaté chez Petit).
=> OK (03/08/2017) : correctif movestate dans GOC_Move2D::Update_Walk

- Changement de GOC_Destroyer::GetUpdatedWorldPosition(Vector2& position) basé sur le MassCenter de RigidBody2D ald Drawable2D
-> (02/08/2017) : bien mettre à jour les xml des entités avec UseFixtureMass=False et MassCenter=x y (impact sur le changement de viewZ)

- Suite  à l'ajout du SWIM, le vampire ne marche plus, mais vol si sur le sol
=> OK, CANWALKONGROUND ajouter dans GOC_MOVE2D && GOC_ANIMATOR2D

- activer touche spécial pour junkelspil = passage dans les murs : creer ability automount
=> OK, Actor AddNativeAbilities et refactor Equipment

- affectation de la touche manette spécial ability. utilise l'ability si avatar est autorisé
=> OK, activé via l'equipment et holder->HasTag(ability)

- pb bat : bat ne bouge pas (pb de prey ?)
=> Les Bats se ciblaient. Interdiction pour le GOC_Detector de prendre pour target des node de meme nom
=> OK, en Test

- pb option switch mur : ajouter une routine pour empecher d'entrer dans un mur
=> OK dans Player SwitchViewZ
==> Ajouter dans ABI_CrossWalls

- pb fin de mission : rewards sont données en continue à intervalle de quelques secondes si l'on n'accepte pas une nouvelle mission.
=> ok ajout mission state IsFinished

- GOB_MountOn:
-> trouver pourquoi ne fonctionne pas après changement de level
 => OK : pb de creation nouveau GOC_AIControl dans UpdateComponents

- non affichage de l'equip sur le second joueur sauf l'armure
-> pb d'updateslot ou bien sur l'equipment ?
-> lorsque prise de collectable en direct, pas d'update dans le bagpanel, ni equipment
==> OK : pb de ControllerType GO_AI_ALLY

- l'attaque fantome ne detruit pas les collectables ! la bombe oui !
-> corriger l'attaque fantome ? pb de faction ?
==> OK : pb de rbody->SetAwake; remplacer par SetAllowSleep(false)

-> non prise en compte de la diminution de la vie sur le client
==> OK : pb Server_UpdateObjectControls, ne prenait pas en compte les nodes provenant des clients pour le PrepareControl.
</>

</>




<RESEAU>
========

<TODO>
------

- 04/10/2021 : il faut revoir une fois de plus lorsque l'entité attaque, l'animation loop parfois encore cette fois en local. GOC_Animator2D::SetState(), GOC_Animator2D::CheckAnim()
=> modif dans GOC_Animator2D::CheckAnim()
==> toujours le meme pb. dur à reproduire : vu uniquement en world. En arena en mettant bcp d'entité, non reproduit.

- 27/09/2021 : la collecte de collectable sur un client est bien repercuté coté server mais pas vers les autres clients.

- 20/09/2021 : lors du changement d'ability sur un client, il faut le repercuter coté server autrement le server ne sera pas quelle abilité utilisée dans Player::OnFire2()
=> 21/09/2021 : Etant donner que le Player::OnFire2() n'est plus utilisé en version Net (coté server), ce cas ne se pose plus.
==> le faire neanmoins, pour assurer d'eventuels cas.

- 19/09/2021 : snap initial lorsqu'un client se connecte en cours de partie. Ce n'est pas nécessaire en arene. Cela le sera en World networked

- 29/08/2021 : le reseau est saturé apres plusieurs suicides avec le skeleton lorsque ACTIVE_NETSIMULATELATENCYANDPACKETLOSS est activé
=> pb avec knet ? comme pour les messages reliables ?
=> voir pour afficher dans le DebugHud, le nombre d'ObjectControl et ObjectCommand envoyés et reçus.
==> voir pour passer à SlikeNet : integration faite dans la version 1.7 d'Uhro.
===> 31/08/2021 : integration faite avec FromBones : pas d'incidence sur le code de FromBones.
====> Modification de SLikeNet pour activer le Latency Simulator : modification de ReliabilityLayer::ApplyNetworkSimulator et RakPeer::ApplyNetworkSimulator ... inversion de logique => _DEBUG par_RELEASE
=====> IMPORTANT : par defaut le net simulateur est activé. NE PAS OUBLIER D'ACTIVER dans slikenet/include/defines.h la ligne #Define _RETAIL pour desactiver le NetSimulator en version Publique.
====> apres 3 suicides avec ACTIVE_NETSIMULATELATENCYANDPACKETLOSS, les nouvelles boneparts deviennent instables (elles se déplacent dans tout les sens) puis il y a un certain temps, elles arrivent à leur position
=====> en corrigeant GOC_Destroyer::HandleUpdateTime() pour permettre la destruction des bones, il n'y a plus de congestion lors du test.
=====> logger les stamps, verifier le nombre de paquets, verifier la gestion de la congestion par SLNet
======> utilisant GameCommands::"netstate" => 25 paquets envoyés par sec => le network etant configuré à 25 fps ; apres plusieurs suicide, le nombre de paquets diminue à 1-2 par sec.
======> utilisant GameCommands::"netlog" pour obtenir le LogStatistics de Connection => le nbBytesPerSec est de 25000KBytes/sec apres le 2eme suicide, la congestion a lieu apres le 3eme suicide, soit environ 35000KBytes/sec => 286MBits/s ce qui est beaucoup
=======> en prenant à l'envers à partir de la taille des ObjectControls : 3 suicides pour le client correspond à 3*17Bones*3+1Avatar=52 ObjectControls envoyés vers le serveur = 52 * 72 Bytes = 3744Bytes pour une frame (sans la compression)
=======> soit 3744Bytes*25fps=94KBytes/sec ---> on est loin de ce qui est affiché par LogStatistics => erreur dans Connection::SendRemoteEvents() les KB sont des Bytes et pas de KiloBytes
========> en corrigeant/activant ACTIVE_PACKEDOBJECTCONTROL, la taille des objectcontrols passe à 48Bytes, la congestion arrive un peu apres.
=========> il faut logger l'envoi des objectControls et des objectCommands par seconde dans GameStatus::"netlog" -> ajouter le code dans GameNetwork::DumpObjectControls()
==========> 1) limiter le nombre de traitement d'objectControls par envoi.
===========> OK : 06/09/2021 -> modification de GameNetwork::HandlePlayServer_NetworkUpdate  GameNetwork::HandlePlayClient_NetworkUpdate() limite l'envoi à MAX_OBJECTCONTROLTOSEND maximum
============> conséquence : plus de sacade coté des autres clients. Il faut donc limiter un maximum les Object controlés par les clients.
==========> 2) les "acks" server->client sont pour le moment des objectcontrols. ils doivent être changer par une structure moins consommatrice de données pour limiter la qté de data à retourner.
============> OK : 06/09/2021 -> modification de ObjectControlInfo (WriteAck et ReadAck) et modification de GameNetwork::HandlePlayClient_ReceiveClientUpdate et modifier GameNetwork::HandlePlayServer_NetworkUpdate pour recevoir et
     envoyer les acks uniquement dans le cas du retour ACK serveur/client, ajout de GameNetwork::UpdateControlAck().
==========> coté client, il faut eviter d'envoyer trop d'ObjectControl vers le serveur. C'est le serveur qui est dimensionné pour avoir le meilleur debit d'envoi.
==========> 3) apres spawn des part bones ou bien drop d'items et ack du server, il faudrait reaffecter le ownership au server.

- 14/08/2021 : pour ameliorer le temps de deconnection d'un client, le serveur pourrait controler la reception du stamp dans GameNetwork::HandlePlayServer_ReceiveUpdate().
=> si le stamp est toujours le meme pendant Xs alors deconnection du client.
==> 08/09/2021 : avec SLNet, lorsque le server est deconnecté, le temps de deconnection des clients est encore plus long (30sec)

- 12/08/2021 : les body parts doivent pouvoir être détruites par les differents clients
=> OK : il suffit de modifier les attributs de ScrapsEmitter dans avatar-newskeleton.xml

- 11/08/2021 : pb de spawn lors par exemple de l'explosion du skeleton ou bien d'elsarion.
=> cf GOC_BodyExploder2D, GameNetwork::AddSpawnControl()
==> le spawn multiple au meme instant entraine-t-il le debordement du spawnstamp ?
===> la suppression du check localspawnstamp receivespawnstamp dans GameNetwork::AddSpawnControl() résout ce pb mais il n'y aura plus de synchro de spawnstamp
====> autre solution, modifier GameNetwork::AddSpawnControl() pour admettre le spawn multiple, il faudra pouvoir ajouter la quantité.

- 09/08/2021 : Adapter GOC_Portal pour accepter les Net_Player
=> teleporter uniquement les nodes locaux, les autres clients ou serveur s'occupent des autres nodes.
==> RAF : verifier avec les entités montées.

- 03/07/2021 : suite à la modification du spawning effectuer coté client (le client spawn desormais toujours sans attendre la reponse du serveur),
le spawn d'une bombe par exemple coté client fait apparaitre le pb de "snapping" des synchronisation avec le serveur.
La bombe revient en arriere est prend la position du serveur avec le double de decalage (puisque latence client->serveur, puis serveur-client).
=> il faut introduire les concepts de client prediction+server reconciliation et lag compensation pour diminuer les effets de la latence (cf. https://www.gabrielgambetta.com/lag-compensation.html)
==> client prediction necessite de bufferiser les ObjectControls envoyés au serveur. Pour le moment seul le dernier objectcontrol prepared est stocké et seuls les 2 derniers objectcontrol reçus sont stockés.
==> un objet spawné par le client est stocké dans GameNetwork::clientObjectControls_, le server reçoit l'ObjectControlInfo d'une part et d'une autre le spawn lui meme
==> todo : de meme coté serveur ...
==> il faut revoir le stamp client et le stamp serveur.
==> lors du spawn, il faut verifier si l'entity qui spawn appartient à la machine.
    Si la machine est le server, le nodeid ira dans ObjectControlInfo::serverNodeID_ autrement dans ObjectControlInfo::clientNodeID_
    Modifier GameNetwork::AddSpawnControl() qui pour le moment spawn avec owner=0(server)
    Le node spawné hérite le owner du node holder.
==> remplacer ObjectControlInfo::owner_ par clientId_
===> si un etat revient different au client, il doit corriger son etat courant en tenant compte de l'etat recu et l'extrapolant selon la latence.
====> pour le moment, le serveur prend pour argent comptant les informations provenant du client. Il lui faut une méthode pour lutter contre le cheating.
=====> par ex : calcul des distances possibles parcourable entre chaque reception. si la distance parcourue est superieure à la distance possible calculée, il y a triche. Sauf si pouvoir de teleportation utilisé biensur.
==> lag compensation va s'occuper des cas ou l'avatar coté client arrive à toucher une cible. Cette cible est à une position passée pour le client possesseur de cette entité.
    coté client, les animations hurt doivent popper des que l'avatar touche une cible sans attendre l'approbation du serveur mais ne pas etre repetes à la reception des infos serveur. (server reconciliation)
==> vérifier que tout les packets envoyés soit en message soit par ObjectControlInfo soit taggé par un stamp généré par le client emetteur.
    Le serveur recoit les stamps de chaque client et permet de classer pour chaque client la chronologie des commandes passées.

- 23/06/2021 : crash si un client meurt et drop son inventaire et qu'un autre client ramasse du stuff
=> surement du au fait que le serveur ne stocke pas encore les inventaires des clients.

- 08/06/2021 : en Reseau Arena si mort de l'avatar, faire un repop automatiquement au bout de 5sec (mettre un timer de repop)
=> modifier PlayState::CheckGameLogic() => GOManager::GetNumActivePlayers() prend en compte les Players et les Net_Players alors qu'il ne faut uniquement que prendre en compte les joueurs locaux pour le mode arena
=> l'objectif pour gagner pourra être dans un temps imparti (5min/10min...)
==> Tuer le maximum de joueurs
==> ou Obtenir le maximum d'un objet déterminé (exemple des bones)

- 04/06/2021 : NOTE pour gagner en rapidité, les objets spawnés via GOC_Animator2D::SpawnEntity() n'ont pas tous un ObjectControl (qui permet le controle des etats d'une entité (position,animation...) via le serveur).
=> par exemple c'est le cas pour les bullets et les boules de feu. Ces objets sont gerés en LOCAL.
==> pour cela il suffit de mettre dans Objects.xml l'attribut "replicateMode":0
==> le spawn s'effectue sur le serveur et les clients de façon local. L'attribut de shoottarget est completé avec ObjectControl::holderinfo_::point1x_,point1y_ via envoi:ABI_AnimShooter::Use() -> reception:GOC_Controller::Update()

- 22/08/2019 :
-> GOC_Inventory : lors du drop d'un player sur un client, mettre à jour l'inventaire coté serveur du joueur
--> car sinon impossibilité du GetSlot si l'inventaire coté serveur est plein alors que celui du client non.
--> les DPS sont calculés sur le serveur. Donc si l'equipment n'est pas le bon les DPS envoyés vers le Client ne seront pas bons.
==> 02/06/2021 : OK pour le moment ajout de GOC_Inventory::NetServerSetSlot() et modification de GameNetwork::ChangeEquipment()
===> il s'agit que de l'ecrasement d'un slot d'equipment sur le server par le slot du client
====> lors des procedures de chargement d'equipement coté client tel que Player::LoadStuffOnly(), il faut en informer le server qui aura également sauvegarder les inventaires de tous les clients dans ses bases.

- 17/10/2019 : Crash du serveur lorsque l'avatar server meurt et que le client recupere des obj de l'inventaire dropper.
-> Crash Coté Server dans ou après Player::OnServerGetCollectable
--> dans Equipment::UpdateAttributes() : la money passe en index=0 ce qui fait planter la procedure qui recherche sur index-1 -> correctif interdit index=0
-> Boucle infinie coté client après correctif sur serveur apres Player::OnGetCollectable()
--> dans GOC_Collectable::TransferSlotTo() : ajout d'un break en cas ou Slot::TransferTo() retourne une quantity nulle
---> les objets et quantités de money ne sont pas identiques avec ceux de l'inventaire initial du player mort.
----> 18/10/2019 : verifier l'inventaire dropper à la mort du player et verifier la recuperation de chaque collectable.

- 08/10/2019 : la force d'impact à produire lorsqu'une entité est touché est differente entre le client attaquant et les autres à cause de l'equipment
-> voire pour repliquer la valeur de cette force ou bien tout l'equipment.

- 26/09/2019 : probleme lors du spawn du grapin en reseau. L'ancienne chaine est parfois toujours attachée ...
-> Vérifier le code dans GameNetwork::HandleObjectControlHolderChanged()

- 19/08/2019 : le marchand coté client n'est pas un actor donc ne peut pas intéragir avec le joueur.
-> voir pour l'ajout d'actor avec ObjectPool via le network

- 18/08/2019 : Comment assurer la corrélation entre les numeros d'entités, les maps en mémoires sur l'ensemble des clients connectés avec le serveur

-> CharacterMapping:
--> envoyer un RemoteEvent des changements d'equipment ou bien via ObjectControl => OK, en cours
--> 19/08/2019 : lors du pop coté clients d'entités à synchroniser avec le serveur, le charactermapping n'est pas communiqué.

-> GOB_MountOn : l'entité portée ne doit pas avoir de mouvement relatif / entité porteuse
  -> ajouter idparentnode dans ObjectControl ou bien RemoteSendEvent

-> affichage du mauvais avatar pour les seconds joueurs locaux

</>

<DONE>
------

- 27/09/2021 : parfois l'animation attack de l'ours est repeté 2x sur un client foreign.
=> cela pourrait occasionner des problemes si attack avec un spawn d'entité. Ce n'est pas le cas pour power2 de mirubil.
==> verifier AnimatorTemplate_Attacker (utiliser par loup, ours, bitroll, goblin, karotos, lizard, merchant, shuktuk), vu aussi sur l'avatar-lizard
==> verifier si pas de doublon entre l'application du state buttons et application de l'animstate
===> les logs font apparaitre que GOC_Animator2D::ChangeAnimation() est sollicité une fois par GameNetwork::UpdateControl pour le passage au state Attack
    puis une fois par l'update local en state Idle puis encore par GameNetwork::UpdateControl pour le passage au state Attack une nouvelle fois.
====> il faut pouvoir tester s'il s'agit d'un nouveau changement d'animation. Ou bien simplement la continuité du state courant.
=====> stocker le dernier etat appliqué par GameNetwork::UpdateControl() et tester.
======> ne permet plus d'utiliser les animations switchable (tickdelay).
=====> il faut mettre un id pour chaque changement d'anim. (un peu comme pour les spawn)
======> si l'anim id reçu est identique au dernier id utilisé alors ne pas changer d'animation.
=======> l'affectation de l'anim id doit se faire par GameNetwork::PrepareControl() et dans GOC_Animator2D
========> remplacement de ObjectControl::states_.spawnmode_ par flag_ (bitflag) le bit0 correspondant au spawnmode et le bit1 à l'animation changed
========> modifier ObjectControl::states_.animation_ par unsigned char ObjectControl::states_.animstateindex_ (template animation state index) et unsigned char ObjectControl::states_.animindex_ (animatedsprite (sprite) index)
=========> 30/09/2021 : OK modification de GOC_Animator2D::SetStateSilent() et remplacement par GOC_Animator2D::SetNetState().
=========> RAF : Tester si le state courant peut etre interrompu par le nouveau state. (attack -> walk normal non possible). Autrement certaines animations seront interrompues avant leur terme.
==========> OK ajout de AnimatorState::CanTransitToState()
===========> 01/09/2021 : OK gestion conforme des SwitchableAnimation notamment.

- 06/09/2021 : il faut finir les modifications de Spawn des ObjectControls => RAF le grapin avec le holderinfo.
=> le spawn des bombes se déroule :
==> en local avec le clavier GOC_Animator2D => en net => GameNetwork::UpdateControl => ChangeAnimation => spawn par GOC_Animator2D qui utilise alors static Ability::Use(),
    le principe des SpawnControl est respecté : le spawn d'entity est toujours effectué localement sur chaque client puis à la reception des ObjectControl, la synchronisation des positions, states s'effectue.
==> en local avec la souris Ability::UseAtPoint() => en net il n'y a pas de state transmis qui permet le spawn dans GameNetwork::UpdateControl
===> il peut y avoir un probleme de coherence de spawn (local/net), si changement de l'animation avant le spawn soit coté local, soit coté net.
=> le spawn des autres abilités (sauf bombe) se déroule :
==> en local, utilisation de la souris pour spawner (Player::HandleClic() => Ability::UseAtPoint()) uniquement local non transmise par le net
==> en local, utilisation de la touche action pour spawner (Player::OnFire2() => Ability::Use()) transmis via le net par le state ObjectControl::states_::buttons_ de l'avatar
==> seul le server connait l'abilité active, donc pas de spawn sur les autres clients
===> à la reception de l'ObjectControl, il faudrait realiser le spawn : ajouter ce cas dans GameNetwork::HandlePlayServer_ReceiveUpdate() et GameNetwork::HandlePlayClient_ReceiveServerUpdate() => voir les consequences avec les controllables et les bombes.
===> modification et unification de static Ability::Use() qui est utilisé dans GameNetwork::NetAddEntity() -> World2D::NetSpawnEntity().
====> RAF la lame spawn bien, mais la faction n'est pas la bonne.
====> 17/09/2021 : OK Correctif dans GOC_PhysicsGrapin::HandleRoofCollision() pour eviter la creation d'un autre spawncontrol
=====> de client => server OK mais client => server => other client pas de spawn
=====> avec un server et deux clients => double spawn des bombes.
======> il s'agit du probleme classique si le principe du SpawnControl n'est pas respecté.
=======> si GOC_Animator2D est utilisé pour le spawn, il ne faudrait jamais spawner via GameNetwork::NetAddEntity()
========> Si le mode de spawn utilisé est "Animator" (mode à communiquer dans l'ObjectControl), le code dans GameNetwork::HandlePlayServer_ReceiveUpdate() et GameNetwork::HandlePlayClient_ReceiveServerUpdate() concernant GameNetwork::NetAddEntity() sera skippé.
========> ajout de NetSpawnMode, ajout ObjectControl::states_::spawnMode_, si spawnMode_ = LOCALANDNETSPAWN alors GameNetwork::NetAddEntity() est utilisé.
=======> if faut absolument que :
========> un client qui spawn un poolnode envoit toujours un ObjectControlInfo dont le serverNodeId_=0
========> le server qui spawn un poolnode envoit toujours un ObjectControlInfo dont le clientNodeId_=0
=========> 19/09/2021 : pas mal de correctif, ajout de GameNetwork::NetSpawnControlAlreadyUsed() mis dans GOC_Animator2D::SpawnEntity() qui permet de skipper si une entity est déjà spawnée avant le prochain network update :
    evite le double spawn pour les bombes (les bombes spawnées en local via le controle clavier)
==========> faire la documentation des cas d'utilisations. voir si possibilité de simplification (pour respecter strictement le spawncontrol établi).
==========> le spawn local doit etre respecté à 100% autrement sur les autres clients, lors d'un tir l'entité risque d'etre instancié trop loin de son porteur : le serveur recoit du client les coords et les met à jour avant l'envoi vers les autres clients.
===========> il faut toujours passer par GOC_Animator2D
===> si le changement de button n'est pas reçu car perte de packet, alors Player::OnFire2() ne sera pas appelé et il n'y aura pas spawn.
====> privilègier le NetSpawn permet d'éviter ce probleme. remplacer NETSPAWNONLY à la place de LOCALANDNETSPAWN. Il faut désormais résoudre le probleme de pop trop loin du porteur.
=====> lors du GameNetwork::PrepareControl(), il faut skipper la maj du physic s'il s'agit d'un pop initial
======> ajout de ObjectControlInfo::spawninit_ qui permet de skipper la preparation du physique avant l'envoi sur le reseau s'il s'agit du pop du spawn.
=======> le pop à position initiale ne fonctionne pas à tout les coups à cause des pertes de packets
========> à la place de ObjectControlInfo::spawninit_ il faut toujours maintenir la position de pop initiale dans ObjectControl
=========> 21/09/2021 - OK : utilisation de ObjectControl::holderinfo_::point1x_ et ObjectControl::holderinfo_::point1y_ en position initiale : ajout de ObjectControlInfo::UseInitialPosition() et ObjectControlInfo::CopyPreparedPositionToInitial()
=========> sur client foreign, des mouvement sacadés des lames apparaissent apres plusieurs spawn
==========> pour les entites qui n'ont pas de GOC_Controller, ne pas utiliser GameHelpers::SetPhysicProperties() avec le smoothtransform
=========> le grapin ne se decroche pas cote client foreigner entrainant une desynchro : cf GameNetwork::UpdateControl() et GOC_PhysicsGrapin
==========> 22/09/2021 - OK : cela arrive quand le RemoveObject de GameNetwork passe avant le lifetime de GOC_Destroyer : ajout dans GOC_PhysicsGrapin::OnSetEnabled() si false alors detachchains et release.
=========> sur client foreign, parfois des lames repop en boucle, le grapin n'arrive pas à s'accroche et repop en boucle ...
==========> remettre les logs dans GameNetwork : pb de desactivation des ObjectControlInfo coté server ? voir si y'a pas des doublons d'ObjectControlInfo comme c'est déjà arrivé.
===========> 22/09/2021 - OK : dans GameNetwork::Client_RemoveObject() et GameNetwork::Server_RemoveObject() desactivé tous les ObjectControlInfo avec le bon nodeid (pas seulement le premier trouvé).
============> RAF : pour solutionner définitivement ce probleme, il faudrait implementer un pool d'ObjectControlInfo plutot avec deux listes (active/inactive)... de plus ça limiterai le nombre d'ObjectControlInfo.
=====> correctif pour le spawn de bombe via clavier avec GOC_Animator2D : modification de ABIBomb::Use => spawnMode = LOCALSPAWNONLY.
=====> encore des pbs de decalage de spawnstamp : entre GOC_Animator->GameNetwork::AddSpawnControl() et GameNetwork::HandlePlayServer_ReceiveUpdate()
======> cela peut arriver si une entity n'a pas pu etre créer du au manque dans un nodepool.
=======> supprimer GameNetwork::NetSpawnControlAlreadyUsed() de GOC_Animator2D::SpawnEntity() car plus nécessaire (aucun cas LOCALSPAWNONLY utilisant Player::OnFire2() - cf "network - spawncontrol function callings.txt")
========> toujours des decalages : il faut trouver une compensation qui fonctionne
======> dans certain cas sur server ou foreign client, le grapin ne s'accroche pas alors qu'il l'est coté client spawner.
=======> si GameNetwork::UpdateControl() impose une position au grapin avant qu'il ne soit accrocher (avant l'appel de GOC_PhysicsGrapin::HandleRoofCollision()) alors le grapin ne peut plus s'accrocher (se mettre en static).
========> modifier GameHelpers::SetPhysicProperties() qui se fait toujours en initial dans le cas des entités sans SmoothTransform : eviter le changement de position si faible ecart.
========> si il est accroché sur le client spawner, il faut qu'il le soit aussi sur le server et les autres clients. De meme s'il ne s'accroche pas coté client spawner.
=========> dans GOC_PhysicsGrapin::AttachOnRoof() il faut integrer le code de GOC_PhysicsGrapin::HandleRoofCollision() en trouvant de plus la collisionshape et le tileindex correspondant au point d'accroche.
==========> OK ajout de World2D::GetCollisionShapeAt() et World2D::GetNearestBlockTile()
==========> il reste le cas ou GameNetwork::UpdateControl() detache la corde en laissant le grapin static accroché et ensuite GameNetwork realiser un RemoveTile(), le grapin reste toujours accroché.
===========> le collisionshape renvoyé dans GOC_PhysicsGrapin::HandleBreakContact() n'est peut-etre pas le meme que GOC_PhysicsGrapin::shapeInContact_.
============> 25/09/2021 - OK : enregistrer une liste de collisionshape de contact lors du World2D::GetCollisionShapeAt() et donc souscrire à ces shapes pour le HandleBreakContact()

- 26/09/2021 : pb lors du spawn oeuf avec mirubil car l'animation sur les clients foreign peut etre interrompue par GameNetwork::UpdateControl() avant le trigger envoyé par AnimatedSprite2D vers GOC_Animator2D pour le spawn.
=> cela peut aussi etre le cas pour d'autres spawn d'entité via AnimatedSprite2D -> GOC_Animator2D.
==> il faudrait que ce state ne puisse etre interrompu que par hurt ou dead par exemple.
===> il faut tester dans GameNetwork::UpdateControl() s'il est possible de changer d'un state à un autre
====> il faut tester si le state courant a un event TICKLOOP et si oui s'il est achevé
=====> ald faire SetStateSilent, etablir une nouvelle fonction GOC_Animator2D::SetNextStateSilent à utiliser dans GameNetwork::UpdateControl qui va permet le changement d'animation lorsque les conditions le permettent (fin du TICKLOOP ou bien instantanement si pas de tickloop)
======> OK le 27/09/2021 : à verifier.

- 06/09/2021 : avec SLNet verifier si la synchronisation des clients au lancement fonctionne. Il semble y avoir desormais un decalage.
=> OK 27/09/2021 : du au packet loose, sans la simultation packet loose c'est parfait. On laisse en etat.

- 06/09/2021 : avec SLNet les clients n'arrivent pas à se connecter parfois. (à cause du packet loose). Il faut remedier à cela.
=> cf GameNetwork::HandleSearchServer()
==> OK 27/09/2021 : augmentation du delai de connection au server. NET_DELAYCHECKCONNECTION et NET_DELAYCONNECTSERVER

- 06/09/2021 : apres plusieurs suicides d'un avatar, l'avatar a des mouvements de plus en plus sacadés sur les autres clients car les informations n'arrivent plus avec le meme fps (il s'agit de l'effet de la limitation du nombre d'objetcontrol par envoi precedement realisé)
=> il faut compenser ces sacades par une simulation locale du mouvement : dans ce cas il faut que GOC_Move2D::IsPhysicEnable() soit vrai.
=> les GOC_Move2D::SetPhysicEnable(false) sont commentés.
==> les sacades sont presentes si NET_DEFAULT_LOSTPACKET > 0 avec NET_DEFAULT_UPDATEFPS=20fps
===> il faut verifier si les velocités sont correctes (peut-etre qu'il faut l'impulse à la place) : creer des draw debugs pour les velocités. les velocités sont bien présentes.
==> avec NET_DEFAULT_UPDATEFPS=1fps et NET_DEFAULT_LOSTPACKET=0 montre bien que la simulation physique est activé (l'entité n'est soumise qu'à la gravité)
===> le probleme provient de SmoothTransform. Si il est desactivé la simulation locale se fait (certes avec de mauvais resultat ... à améliorer)
====> modification de Urho3D::SmoothedTransform et GameHelpers::SetPhysicProperties() pour eviter que le smoothing continue sans arret (secousse incessante de l'entité)
=====> Toujours des pbs de secousse : voir si c'est du à un pb avec la simulation physique locale (GOC_Move2D) : ACTIVE_NETWORK_LOCALPHYSICSIMULATION_MAINONLY active de la simulation local que pour les maincontroller.
======> Les buttons n'etaient pas setté sur le server si le button=0. Le server utilisait GOC_Controller::Update() en mode non forcé => il faut le forcer.
=====> GOC_Move2D::SetPhysicEnable() suppression de l'activation/desactivation du SmoothTransform en fonction du GOC_Move2D::physicsEnable_
==> avec 10fps avec smoothtransform et sans perte de packet, les resultats sont pas mal.
===> avec perte de packet, la simulation va prendre le relai apres le smoothing mais cela donne pas mal de saccades ...
====> activer ACTIVE_NETWORK_LOCALPHYSICSIMULATION_MAINONLY pour ne plus simuler avec les buttons et utiliser la simulation par les velocités GOC_Controller::HandleNetUpdate ACTIVE_NETWORK_LOCALPHYSICSIMULATION_VELOCITY_NONMAIN
=====> ne donne pas de bon resultat avec un fps > 5
===> reduction de NET_DEFAULT_SMOOTHTHRESHOLD à 0.001, les saccades sont reduites.
====> desactiver ACTIVE_NETWORK_LOCALPHYSICSIMULATION_BUTTON_MAINONLY (=utilisation de la simulation physique button pour tout les controllers) et desactiver ACTIVE_NETWORK_LOCALPHYSICSIMULATION_VELOCITY_NONMAIN (=ne pas utiliser la simulation locale par les velocités)
=====> ajout de la coherence entre velocité et positionnement dans GameHelpers::SetPhysicProperties() pour limiter les saccades : les velocités sont la reference.
======> 14/09/2021 : OK les resultats sont beaucoup moins saccadés avec 15fps et 25% packetloose
======> pour améliorer encore, il faudrait pouvoir lissé le mouvement lorsque les velocités sont discontinues.

- 01/09/2021 : avec SLNet, les clients crashent lorsque le serveur est déconnecté.
==> voir Connection et Network::Start et Network::Stop et reprendre exactement la meme logique qu'avec Urho3D-kNet.
===> le probleme se situe dans Urho3D::Network::Update() qui a besoin de rakPeer_ or celui-ci est supprimé après l'appel de Urho3D::Network::HandleIncomingPacket() => Urho3D::Network::OnServerDisconnected() => GameNetwork::HandleConnectionStatus() => GameNetwork::StartLocal() => GameNetwork::Stop() => Urho3D::Network::Stop()
====> OK : Patch de Urho3D::Network::Update()

- 06/09/2021 : pb avec les effets de poussieres sur les Entités qui ne sont pas local du client et qui sont sur passerelles : l'effet dust spawn en permanence.
=> c'est surement du à la mise à jour des positions en continue.
==> cf GameNetwork::UpdateControl(), ce n'est pas le cas. Sollicitations en continue de GOC_Collide2D::HandleBeginContact et GOC_Collide2D::HandleEndContact(). cf Urho3D
===> RigidBody2D::ApplyWorldTransform() montre que la position varie et fait decrocher l'entité du sol.
===> ce probleme affecte le server puis reimpacte sur les clients
====> faire un essai en mettant le body en awake=false des que le sol est touché.
=====> correctif de Urho3D::RigidBody2D::SetAwake() et ajout dans GOC_Collide2D::AddWallContact2D (meilleur choix : on aurait pu le mettre aussi dans GameNetwork::UpdateControl() mais pas exactement equivalent). Toujours des pbs.
======> il s'agissait de la position en y qui fluctue du aux approximation sur les float => il faut garder la position courante en y du node lorsque celui-ci est sur le sol lorsque la difference entre la nouvelle position et la position courante est faible.
=======> OK : modification de GameHelpers::SetPhysicProperties()

- 17/08/2021 : pour solutionner le pb de l'envoi de message en reliable qui ne parviennent pas à destination, il faut tout passer par les ObjectControls
=> coté client, dans GameNetwork::HandlePlayClient_NetworkUpdate(), en meme temps que d'envoyer le gamestatus, envoyer les infos specifiques à delivrer tel que changetile, inventory etc...
==> ald d'envoyer directement via remoteevents, stocker les events à envoyer dans un buffer avec comme index le timestamp client.
===> structure => HashMap<!unsigned short int, Vector<NetObjectCommand> !> GameNetwork::objectCommands_;
==> le client devra envoyer les events à partir du dernier timerstamp client reçu du serveur et accusé reception du client => short unsigned GameNetwork::lastObjectTimeStamp_
===> à la reception du timestamp pris en compte par le serveur, le client peut supprimer les actions déjà pris en compte par le serveur pour le prochain envoi.
=> coté serveur, reception du timestamp client, update et renvoi vers le client avec le meme timestamp. de meme le serveur stocke dans un buffer les events à envoyer avec comme index le timestamp serveur
==> la partie delicate est l'envoi à l'ensemble des clients : il va falloir un timestamp serveur et que les clients renvoient le timestamp du serveur à la reception pour prise en compte.
==> le serveur envoi les infos specifiques vers chaque client.
===> les autres clients comparent le nouveau timestamp serveur reçu avec le dernier timestamp server pris en compte et renvoit le timestamp serveur vers le serveur pour prise en compte.
====> le serveur recoit donc deux timestamp, un client et un retour serveur.
=> à modifier GameNetwork::Server_SendObjectCommand et GameNetwork::Client_SendObjectCommand() pour creer et stocker les NetObjectCommand dans GameNetwork::objectCommands_.
==> 27/08/2021 : pb avec GameNetwork::HandlePlayServer_ReceiveUpdate() lors de la reception/copie coté server d'un ObjectCommand client => ok oublie d'ajouter de newObjectCommands_ = true
===> OK : 29/08/2021 - A Verifier avec toutes les commandes.

- 15/08/2021 : le changement d'un slot d'equipment sur un client n'est pas pris en compte sur le serveur. (le load equipment ok)
=> OK : correctif dans la logique de GOC_Inventory::LocalEquipSlotOn()
==> Il faut maintenant solutionner le pb de message reliable qui n'arrive pas à destination
=> manque l'implementation du remove item
==> OK : modification de GOC_Inventory::NetServerSetSlot permettant de traiter le cas ou le type est nul.

- 11/08/2021 : pb animation avec hurt
=> 15/08/2021 : revision de la strategie : la simulation doit etre realisée des 2 cotés clients et server. En local, le State Hurt est appliqué directement => Le state Hurt provenant du network ne doit pas etre appliqué.
    Cela permet coté joueur d'avoir l'impression d'avoir touché. les dps sont toujours conserver du coté serveur (autoritatif)
==> OK : Modification de GameNetwork::UpdateControl(), Modification de GOC_Life::ReceiveEffectFrom() pour enlever la tempo
===> le pb c'est les equipments qui ne sont pas repliqués (les valeurs de defense et d'attaque ne seront pas les memes entre client owner et les autres clients)

- 13/08/2021 : pb si le serveur est lancé et que tous les clients ne sont pas connectés
=> avant les modifications d'aout, il etait possible qu'un nouvel avatar arrivé d'un nouveau connecté (après le spawn des premiers clients), fonctionne bien sur les autres clients (comme sur les MMO)
==> solution 1 : laisser tel quel car cela correspond au fonctionnement de base d'un jeu en arene pvp, il faudrait creer une UI "salle d'attente".
==> solution 2 : remodifier pour avoir le meme comportement avant aout cad type MMO
===> Reserver sur tous les serveurs et clients la meme plage de nodeid pour les avatars des joueurs.
====> par clientid reserver MAX_NUMPLAYERS nodes locaux => nodes à reserver = GameStatus::MAX_NUMPLAYERS*GameStatus::MAX_NUMNETPLAYERS
=====> OK : ajout de GameStatus::ReserveAvatarNodes(), modification ClientInfo::CreateAvatarFor & PlayState::SetPlayers() et suppression du code specifique à PLAYSTATE_CLIENT_LOADING_SERVEROBJECTS (plus nécessaire)

- 09/08/2021 : le suicide (la mort et respawn d'un player) ne fonctionne pas correctement.
=> à la mort du player, l'animation dead n'est pas joué coté serveur. il n'y a pas de mort de l'avatar chez les autres clients.
=> la reactivation passe par le changement de gamestatus PLAYSTATE_STARTGAME sur le client et envoi au serveur qui reactive le player, mais le client continue d'envoyer le status
==> voir coté serveur GameNetwork::HandleServer_MessagesFromClient
===> modification mineure dans GameNetwork::HandlePlayClient_ReceiveClientUpdate pour envoyer le gamestatus PLAYSTATE_RUNNING apres reception de la bonne prise en compte par le serveur.
====> encore certains problemes apres repop sur le serveur.
====> lorsque le clic sur la messagebox de repop coté client est fait avant que le serveur n'ait stopper le player, alors repop coté client et du coté serveur le player est stoppé et l'avatar disparait.
=====> soit temporiser pour le clic que le serveur ait bien stopper le player.
=====> soit modifier pour que le stop player coté serveur soit realiser des que l'avatar meurt (ce qui est plus logique)
======> modifier Player::OnDead(), supprimer l'envoi/reception/accuséreception de gamestatus PLAYSTATE_ENDGAME
=======> attendre la fin de l'animation Dead pour stopper le player : modification de GOC_Animator2D::ToDestroy(),
========> GOC_Animator2D::ToDestroy() envoi directement GO_DESTROY -> Player::OnAvatarDestroy() -> GameNetwork::Get()->Server_SetActivePlayer() -> Player::Stop()
========> apres un changement d'avatar vers Petite ou Elsarion, coté serveur le processus ne parvient plus à GOC_Animator2D::ToDestroy()
=========> OK : modification de GameNetwork::UpdateControl() pour eviter de passer du STATE_DEAD vers STATE_EXPLODE sinon GOC_Animator2D reste bloquer sur STATE_DEAD et ne peut parvenir à GOC_Animator2D::ToDestroy()
=======> l'envoi du gamestate en message reliable (voir aussi pour les changetiles) est parfois tres long voir non realisé (bug coté kNet ?), du coup le respawn du player coté serveur peut aller
    jusqu'à plusieurs secondes (5-6sec)
========> OK : lorsque le jeu est en PlayState, obtenir le gamestate du client via GameNetwork::HandlePlayServer_ReceiveUpdate()
==> 14/08/2021 : apres suicide et respawn, l'avatar du coté des autres clients et server n'a pas les physic colliders actif. Le probleme est regler en changeant d'avatar.
=> verifier la reactivation sur les autres clients et server.
==> OK : modification de GameHelpers::SetPhysicFlipX() pour ne plus utiliser RigidBody::GetCollisionShapes() qui ne retourne que les shapes actives attachées au body.
    car dans notre cas GOC_Animator2D::physicFlipX_ doit être remis à false lors de GOC_Animator2D::Stop() et il faut donc utiliser GameHelpers::SetPhysicFlipX() alors que les shapes sont inactives.
===> Elsarion n'apparait pas contrairement aux autres
====> GOC_BodyExploder2D::HandleWaitStateForHide desactive le RigidBody2D et le Drawable2D : il convient de toujours les reactiver
=====> les reactiver dans GOC_Destroyer::OnWorldEntityCreate()
======> OK

- 01/08/2021 : Modification majeure ObjectControl, spawncontrols
1) ServerSide : entity local server => objectcontrol.clientid_=0
   OK => spawn un servernodeid GameNetwork::AddSpawnControl() et n'a pas besoin du retour client d'un clientnodeid
2) ClientSide : entity server (ou autre client) sur client => objectcontrol.clientid_=0 || => objectcontrol.clientid_!=clientID_
   OK => spawn un clientnodeid GameNetwork::AddSpawnControl() et attend le retour server d'un servernodeid (GameNetwork::HandlePlayClient_ReceiveServerUpdate)
3) ClientSide : entity local client => objectcontrol.clientid_=clientID_
    => spawn un clientnodeid GameNetwork::AddSpawnControl() et attend le retour server d'un servernodeid (GameNetwork::HandlePlayClient_ReceiveClientUpdate)
4) ServerSide : entity client sur server => objectcontrol.clientid_!=0
    => spawn un servernodeid GameNetwork::AddSpawnControl() et attend le retour client d'un clientnodeid (GameNetwork::HandlePlayServer_ReceiveUpdate)
5) pb de desynchronisation à cause du spawnstamp :
=> si le serveur ne spawn pas une entity pour une quelconque raison, il faut s'assurer que le spawnstamp coté serveur soit synchrone avec le client.
==> 08/08/2021 : OK : ajout de receivedSpawnStamps_ et localSpawnStamps_ qui permet de maintenir un etat synchone du spawnstamp
6) pb avec ObjectControlInfo::active_ et ObjectControl::states_::enable_
=> revision de la strategie
==> ObjectControlInfo::active_ est true à la creation d'une entity. ObjectControlInfo::active_ est false à sa destruction.
===> aucune reactivation possible via le circuit réseau des ObjectControls
===> pour réactiver il faut envoyer une commande réseau
==> ObjectControl::states_::enable_ s'effectue sur le client maincontroller et est répercuté sur le réseau.

- 23/06/2021 : avec plusieurs clients, l'ensemble des server/clients se mettent à ralentir lorsque l'un des clients pop un oeuf mirubil.
=> pas reussi à reproduire ce bug en mode net local, mettre ACTIVE_NETSIMULATELATENCYANDPACKETLOSS on
==> reussi à le reproduire mais non systematiquement,
===> En cas de perte de packet il faut etre sur que coté des autres clients cela popera.
====> l'oeuf mirubil comme tout autre objet replicated est spawné directement sur serveur ou client maincontrolled. (tout au moins pour le spawn via GOC_Animator2D::SpawnEntity)
=====> il serait interessant de pouvoir spawner directement sur tout client egalement (mais pose surement le probleme de changement de nodeid). ce serait bien aussi pour GOC_BodyExploder2D et le drop item.
=====> 1) tous les clients et le server spawnent tout d'abord en LOCAL
======> sur les clients, les ObjectControl necessitant une replication seront stockés dans la table temporaire clientSpawnControls_
======> sur serveur et clients, ObjectControl::states_.stamp_ est incrementé (voir comment les stocker ? sur l'ObjectControl du parent ?).
=====> 2) pour une entity replicated, le server envoie à tous les clients le nodeid attribué ainsi que les infos pour la traçabilité tel que le type d'objet, le node "parent" et l'objectStamp
======> le node "parent" est l'entity qui a spawné le nouvel objet, l'objectStamp est un int permettant de faire la correspondance du nouvel objet entre le serveur et le client.
======> ces infos doivent etre maintenu dans l'ObjectControl
======> le state ObjectControl::states_.idle_ devient ObjectControl::states_.enable_ et ajout de ObjectControl::states_.stamp_, ObjectControl::holderinfo_.id_ sera utilisé pour indiquer le node parent.
=======> à la reception d'un ObjectControl server par un client, le client verifie dans clientSpawnControls_.
========> Si l'ObjectControl reçu correspond à une entrée dans clientSpawnControls_ (ObjectControl::states_.stamp_, ObjectControl::holderinfo_.id_)
=========> l'entrée est supprimé de clientSpawnControls_ et le lien est établit entre le nodeid server et le nodeid local (evitant le ChangeID). L'entrée est également supprimé lors de la destruction du node.
==========> ajouter clientNodeID_ dans ObjectControlInfo
========> Sinon celui-ci est ignoré.

- 22/06/2021 : le changeEntity de petite lorsque changement d'avatar durant la nuit n'est effectif que sur le client main et le serveur.
=> OK : modification de GOC_Animator2D::ChangeEntity (les clients nonmain n'ont pas pas de currentTemplate)

- 22/06/2021 : apres la mort d'un client et son repop, il ne perd plus de vie
=> pb coté serveur : au repop les collisionshapes de l'avatar n'ont pas les memes maskbits que celles du pop initial.
==> en changeant de viewZ, il n'y a plus de pb.
===> OK : dans Player::Start() ajout de GOC_Destroyer::UpdateFilterBits()
====> RAF : voir si une autre solution est preferable (mettre dans Actor::Start() ... ou en amont dans GOC_Destroyer ...)

- 08/06/2021 : utilisation de la potion de soin ne fonctionne pas sur les clients
=> etant donné que seul le serveur permet la modification du state energie/pdv,
==> dans ce cas, le client doit pouvoir utiliser l'effet immediatement et envoyer au serveur l'utilisation d'un objet
===> la mise à jour du state (pdv dans le cas de la potion), ne reprendra qu'apres envoi d'une confirmation par le serveur. Si le serveur n'envoit pas de confirmation au bout d'un certain délai, la mise à jour sera débloquer.
===> cf UISlotPanel::HandleSlotDragEnd -> GOC_ZoneEffect::HandleContact -> EffectsManager::AddEffectOn -> EffectsManager::ApplyEffectOn -> GOC_Life::ReceiveEffectFrom ... GOC_Controller::Update,
====> dans GOC_ZoneEffect::HandleContact il faut si CLIENTMODE setter une propriété permettant la modification du comportement dans GOC_Life::ReceiveEffectFrom et GOC_Controller::Update et l'envoi d'un event vers le server.
=====> de façon générale, tout item retiré de l'inventaire doit faire l'objet d'un event vers server.
=====> OK : il reste à initialiser coté serveur l'inventaire en cas de LoadStuffOnly.
======> 17/06/2021 - RAF : dans Player::LoadStuffOnly() obtenir le bon savedPlayerFile_ pour le serveur correspondant au bon player coté Client

- 22/06/2021 : resoudre le pb de synchronization serveur/clients au lancement du mode arena.
=> cf PlayState::HandleInitialize, GameNetwork::HandleClient_MessagesFromServer et GameNetwork::HandleServer_MessagesFromClient
==> OK modification de GameNetwork::HandleClient_MessagesFromServer et ajout de GameNetwork::serverGameStatus_ utilisé en mode client.

- 21/06/2021 : les entity ne subissent plus les degats en regard de la barre de vie.
=> OK correctif dans GameNetwork::UpdateControl() pour permettre l'update des GOC_Controller meme si idle

- 08/06/2021 : lorsque le serveur est supprimé, les clients se relancent en mode local mais les avatars des autres clients pop aussi.
=> sans changer d'avatar sur les clients, il n'y a pas de probleme. Verifier le change avatar coté client.
==> lors du change avatar, l'avatar est detruit. cela provient de GameNetwork::ChangeObjectControlIdleState(ObjectControlInfo& cinfo) si le state est enable=false => send de WORLD_ENTITYDESTROY.
===> Il n'y a alors plus de subscriber pour un nouveau WORLD_ENTITYDESTROY.
===> Correctif OK : ne pas envoyer WORLD_ENTITYDESTROY.
====> pb pour la destruction des Lames et des Bombs : possibilité de laisser activer le LifeTimer de GOC_Destroyer (cf World2D::NetSpawnEntity) => ok pour les Lames mais pas pour les Bombs qui n'ont pas de LifeTimer
    Les Bombs sont detruites suivant la succession d'Etats state_use -> state_dead -> state_destroy => verifier l'utilisation de GOC_Animator2D::ToDestroy() sur les autres clients.
=====> GOC_Animator2D::ToDestroy() OK sur les autres clients.
======> Au bout d'un moment les Bombs ne pop plus sur le serveur et les autres clients => verifier avec une ancienne version => aucun pb avec la version du 31/05,
=======> voir si seules les modifications dans GameNetwork::ChangeObjectControlIdleState() ont impactées les bombes.
========> en envoyant le WORLD_ENTITYDESTROY dans GameNetwork::ChangeObjectControlIdleState il n'y a plus de probleme donc dilemme
=========> modifier le change avatar et laisser le WORLD_ENTITYDESTROY ?
===========> le state idle ne doit pas etre utilisé pour detruire ... trouver un correctif pour les bombes et enlever le WORLD_ENTITYDESTROY
============> 21/06/2021 : OK à la place du idle, utilisation le totaldpsreceived

- 14/06/2021 : Apres avoir supprimer le serveur, essayer de spawner des lances => crash
=> apres suppression du serveur, les clients n'ont plus de network
==> Crash dans GOC_Animator2D::SpawnEntity
===> Correctif OK !

- 08/06/2021 : Lorsque l'avatar d'un joueur (client) est touché par un monstre, coté serveur l'avatar semble bloqué quelque temps alors que du coté de ce joueur (client), l'avatar répond bien.
 pendant ce temps de bloquage coté serveur l'avatar se fait taper et perd de la vie.
=> Test réalisé avec le pop d'un Elsarion par Mirubil et attaque de celui-ci par un joueur.
==> le client gérant la position, il faut verifier ce qui empeche l'update de cette position coté serveur.
===> cf. GOC_Controller::Update(const ObjectControlInfo& info) avec le bloquage pour le STATE_HURT.
====> OK modification de GOC_Controller::Update pour permettre le déplacement.

- 03/06/2021 : pb de SpawnEntity avec l'Oeuf de Mirubil puis Spawn d'Elsarion
==> verifier les coordonnees de pop d'Elsarion ... il semble être détruit des le spawn (sa position ne serait pas setter ?)
===> OK : correctif dans GameNetwork::ChangeObjectControlIdleState() => priorité au NetSpawnEntity
===> OK : Correctif dans GameNetwork::HandlePlayServer_ReceiveUpdate => creer le bon ObjectControl coté serveur lorsque le spawn d'entité serveur est demandé par un client.
===> OK : durant le World2D::NetSpawnEntity il faut bien mettre GOC_Move2D::SetPhysicEnable() à false pour permettre à l'entité d'être déplacé par les datas provenant du serveur.

- 03/06/2021 : les Effects et leurs ticks ne semblent pas reproductibles coté clients.
=> OK : erreur avec angle (NaN value) dans EffectsManager::ApplyEffectOn => si nan mettre angle à 0.f
=> OK : modification GOC_Life::ReceiveEffectFrom pour permettre aux NetPlayers de s'attaquer.

- 13/08/2019 : ajouter les modifications de map (WALLBREAKER WALLBUILDER) en reseau
=> 05/06/2021 : OK ajout de GameNetwork::ChangeTile et NetCommand::CHANGETILE
==> OK : envoi de l'event ObjecCommand(CHANGETILE) dans ABI_WallBreaker et ABI_WallBuilder

- 03/06/2021 : pb de spawn directionnel avec la lance ou bien le pistolet
==> la lance est REPLICATED : spawné via GameNetwork::ChangeObjectControlIdleState() -> World2D::NetSpawnEntity()
==> la bullet ne l'est pas : spawné via GOC_Animator2D::SpawnEntity()
===> le spawnAngle_ si utilisation de la souris est setté par GOC_Animator2D::SetShootTarget() dans ABI_AnimShooter::Use()
===> cet angle n'est pas transmis par le reseau.
====> voir pour le transmettre via ObjectControl.holderinfo_.point1x_, ObjectControl.holderinfo_.point1y_
=====> lors du changement de ObjectControl.states_.animation_ vers STATE_SHOOT, utiliser GOC_Animator2D::SetShootTarget(Vector2(ObjectControl.holderinfo_.point1x_, ObjectControl.holderinfo_.point1y_))
======> Setting de ObjectControl.holderinfo_.point1x_, ObjectControl.holderinfo_.point1y_ dans ABI_AnimShooter::Use().
=======> OK pour l'orientation de la lance qui est replicated. RAF le flipX est mauvais si l'angle est sup à 90° et la lance fait des degats au lanceur.
========> voir pour recalquer GOC_Animator2D::SpawnEntity() dans World2D::NetSpawnEntity()
=========> OK : correctif dans GameNetwork::PrepareControl() d'une erreur sur l'obtention de la direction via Variant (Float remplacé par Vector2) et modification de World2D::NetSpawnEntity()
=======> pour la bullet qui n'est pas replicated ... il faut que GOC_Animator2D prenne en compte (si NetWorked) le Vector2(ObjectControl.holderinfo_.point1x_, ObjectControl.holderinfo_.point1y_) transmis.
========> OK modification de GOC_Controller::Update(const ObjectControlInfo& info) qui met à jour les composants apres reception via le Net de cette donnée.
=====> 04/06/2021 : OK la lance set remise en non repliqué (local) afin d'éviter les problemes de collision/stick

- 03/06/2021 : la pluie n'est pas synchrone => vérifier WeatherManager::SetRainTime()
=> OK : Remplacer le Random par GameRand

- 23/10/2019 : l'avatar du server n'apparait pas sur certains clients
-> il n'y avait plus de reservation de node pour les avatars et donc un node utilisé pour un particule effect prenait la place du nodeid de l'avatar du server.
--> solution1 : reservation des nodes lors du PLAYSTATE_CLIENT_LOADING_SERVEROBJECTS => cela ne fonctionne qu'une fois au chargement !
---> OK : modification de GameNetwork::HandlePlayClient_ReceiveServerUpdate() et les clients auront toujours le SetEnabledServerObjectControls(true)
--> solution2 : s'assurer que tous les nodes soit dans des pools (donc numeros deja reservés et alloués)
---> modification des GameHelpers::SpawnParticleEffect et autre pour utiliser des pools.

- 22/10/2019 : les entity spawné comme le ghost vampire ne sont pas bien flippé. Ceci apparait depuis les modifications apportées coté réseau septembre 2019.
=> OK : reapplication de l'ancien code anterieur au 26/09/2019 dans GameHelpers::SetPhysicProperties() pour assurer le flipx si direction inf à 0
==> pb de nouveau sur churros, vampire ... cf correctif du 26/09/2019
===> OK : reapplication du code du 26/09/2019 et modification dans GOC_Animator2D::SpawnEntity

- 23/10/2019 : les bullets ne doivent pas etre controlés via le reseau car trop lent.
-> OK : Simplement changer le replicatedmode dans Data/Objects/Objects.json

- 22/10/2019 : Les bullets ne semblent plus fonctionner en reseau. Les premieres sont bien spawnées.
-> OK : le probleme est dans GameNetwork::Server_RemoveObject() qui reset le cinfo.node_
   ce qui empeche GameNetwork::Server_PrepareObjectControlsMessages() d'envoyer l'objectcontrol sur le reseau.

- 19/08/2019 : pb d'affichage des equipments (dimension des épées) coté client ou serveur apres un add equipment transmis via le network.
-> cf GOC_Inventory::EquipSlotOn(Node* node)
--> OK 22/10/2019 : Utiliser pour les slots armes AnimatedSprite2D::SwapSprites(keepProportion=true)

- 15/10/2019 : lors du pop d'un client, les monstres detruits sur le serveur sont quand meme spawnés.
-> pour cela desactiver simplement dans Map::SetEntities_Add la creation des entités dynamiques en ClientMode.
--> les entités apparaissent alors en position ZERO et non pas de charactermap appliqué.
--> desactiver les entités simplement et attendre le serveur : modifier Map::SetVisibleEntities pour prendre en compte le GameNetwork
---> 16/10/2019 : OK !

- 15/10/2019 : Mettre les bombes en GO_Pools.
-> OK : ajout dans Ability de ABIBomb + modification GOC_Animator2D::SpawnEntity() + ajout de l'ability dans avatar-junkelspil.xml + modif junkelspil.scml pour modifier le Trigger par Entity_ABIBomb ald Entity_Bomb

- 09/10/2019 : REFACTOR
-> reintegrer le code ajouter à URHO3D::Connection dans GameNetwork
-> modifier les boucles d'update network : integrer la creation du messages à envoyer directement dans GameNetwork et mettre à disposition ce buffer dans les Connections.
-> dissocier les boucles de send et de receive dans GameNetwork
--> HandlePlayServer_NetworkUpdate et HandlePlayClient_NetworkUpdate sont lancés avant l'envoi sur le reseau.
---> creer le buffer commun pour tous les clients et ensuite les buffers specifiques par client.
--> creer HandlePlayServer_ReceiveUpdate et HandlePlayClient_ReceiveUpdate qui seront lancés après la reception.
---> les controles des entités seront updatés par ces procédures.
-> OK le 12/10/2019 : pop des avatars
--> RAF : régler les pbs avec Lames et Bombes
---> Lames OK
---> Bombes : modification de HandlePlayServer_ReceiveUpdate pour prendre en compte le changement d'owner d'un objectcontrol.
    Lorsqu'un objectcontrol est créé/activé sur le serveur, l'owner est 0 (serveur) ou != 0 (client) cf GameNetwork::GetOrCreateServerObjectControl()
    Lorsqu'un objectcontrol est désactivé, l'owner revient à 0. cf GameNetwork::Server_RemoveObject() et GameNetwork::ChangeObjectControlIdleState()
    HandlePlayServer_ReceiveUpdate exclut les messages provenant des clients qui ne sont pas propriétaires.
----> Ajout de DISABLECLIENTOBJECTCONTROL pour desactiver coté client un clientObjectControl utiliser par un autre client ou bien un clientObjectControl déjà notify idle sur le serveur.
    Ce qui permet de reduire le buffer envoyé client-> server
    Ce message est envoyé par le serveur s'il reçoit pour chaque nodeid :
    - un owner different de celui dejà affecté (Pour changer de propriétaire, l'objectControlInfo doit déjà avoir le owner_ à 0).
    - un meme owner avec un changement de state vers idle.
----> Cette solution ne permet pas de maintenir 2 clients qui s'approprient un meme nodeid.
    En effet, si deux clients font spawnés un node de meme ID alors le serveur donne la propriété au client dont le message est arrivé en premier.
    Ce qui fait que sur le second client, ce node va blitter entre 2 positions. L'une controlée en local et l'autre par le serveur.
----> OK le 13/10/2019 : Garder ce code et passer les bombes en GO_Pools.

- 09/10/2019 : enquêter sur les messages reliable de knet. Car pas mal de probleme de non reception
-> il est possible que la simulation des pertes Network utilisé dans FromBones en activant ACTIVE_NETSIMULATELATENCYANDPACKETLOSS ne soit pas effective à 100% avec kNet
-> vérifier les sources Network::SetSimulatedLatency et Network::SetSimulatedPacketLoss
--> c'est pourtant gérer via Connection::ConfigureNetworkSimulator et kNet::NetworkSimulator

- 28/09/2019 : les bombes n'appparaissent pas toujours dans certaines sessions (clients et/ou serveur) et peuvent causées un crash
-> pb de viewZ=0, pb dans GameNetwork::HandleObjectControlIdleChanged() ?
-> les bombes ne fonctionnent plus
--> les bombes sont des objects qui ont un replicated state mais dans ObjectPool a été introduit OBJECTPOOL_LOCALIDSONLY qui force les nodes à toujours etre LOCAL.
--> on peut les mettre en local et les objectcontrols feront le restent
--> ou bien utiliser un GO_Pool
--> ou bien corriger le pb
---> le 07/10/2019 : en gardant le replicatedstate, ajout crucial de la reactivation dans GameNetwork::Client_CommandChangeNodeID
    autrement comme le node a été enlevé via GameNetwork::Client_CommandRemoveObject, l'objectcontrol est dans l'etat !actived_.
---> voir pour modifier ObjectPoolCategory::ChangeToReplicatedID pour accepter l'option OBJECTPOOL_LOCALIDSONLY
-----> ajout de ObjectPool::ChangeToID() qui accepte le changement de node local, modification de Scene::NodeIDChanged()
    modification de Connection::ProcessSendServerObjectControls() pour supprimer le TransferMessage, qui pose probleme au spawning des bombes
    modification de Connection::ProcessReceiveClientObjectControls() pour copier l'ObjectControl recu directement dans l'objectControl preparé,
    ce qui permet d'avoir le type des Controllables.
------> toujours des problemes avec les bombes, verifier que le ChangeToID se déroule correctement, vérifier la chaine avec ObjectPool::Free(Node)
-------> cette fois-ci, le serveur genere 2 bombes :
         la premiere est genéré par GameNetwork::ChangeObjectControlIdleState
         la seconde par la commande REQUESTOBJECT
--------> 1ere approche : si OBJECTPOOL_LOCALIDSONLY, utiliser GameNetwork::AddObjetControl ald GameNetwork::Client_SendRequestObject dans Map::AddEntity
---------> approche incomplete si le serveur n'a pas de nodeid correspondant disponible
----------> les bombes sont alors ajoutés par le client comme des clientObjects
            ce qui cause pb dès qu'un autre client les a utilisés, sur le serveur le owner de l'objectcontrol est affecté à la connection qui l'a utilisé en premier
            et sur le premier client l'object control est bien un clientobject.
            du coup les autres clients recoivent des clientobjects et des serverobjects avec le meme id generant un un switch permanent de l'etat idle_.
-----------> OK 13/10/2019 correctif apporté suit au Refactor , mais ne permettra jamais à plusieurs clients d'utiliser un meme nodeid. => passe en GO_Pools pour les bombes

- 19/09/2019 : certaines lames restent activées sur les autres clients/serveur
--> la lame recoit bien le idle=true et est bien restauré dans le pool mais recoit juste apres un idle=false et est respawnée
---> vérifier le timestamp dans Urho3D::Connection
---> reduction de MAX_DELTASTAMP1 à 16 et MAX_DELTASTAMP2 à 32 dans Connection
-> OK
--> 07/10/2019 : reapparition du probleme, voir avec l'impact des modifications apportées sur ce probleme
---> aucun impact, le probleme existe déjà sur la version du 19/09. En recompilant sans ACTIVE_NETSIMULATELATENCYANDPACKETLOSS, il n'y a plus de pb.
    Le pb provient de la perte possible de la commande ERASENODE. Pourquoi ? le message est censé être reliable comme tous les messages d'ailleurs.

----> voir pour se passer completement de cette commande avec uniquement l'envoi du idle_.
-----> dans GOC_Destroyer::Destroy() utiliser GameNetwork::Server_RemoveObject sans envoi de netmessage
-----> modification de GameNetwork::Server_RemoveObject : mettre l'ObjectControl en SetReadyToSend
-----> modification de Connection::ProcessSendServerObjectControls() pour envoyer tous les objectcontrols qui sont readytosend (meme ceux !actived_).
------> exclure de la commande ERASENODE, la connection qui est main pour ce noeud
------> 08/10/2019 : OK ajout du parametre allconnections dans GameNetwork::Server_RemoveObject utilisé pour les players uniquement

- 28/09/2019 : pb lors de la mort d'un player coté Client : pas de respawn possible.
-> 08/10/2019 : il s'agit d'une erreur de creation implicite de "Player" du à l'utilisation de Player::LoadStuffOnly()
--> le xml contenant le stuff contient un GOC_Controller de type GO_Player qui envoie au chargement du stuff l'event GOC_CONTROLLERCHANGE
    GOManager::HandleGOChangeType() l'intercepte et enregistre un nouveau activeplayer non souhaité
---> OK : Ajout en fin de procédure Player::LoadStuffOnly(), d'un kill adéquate (send GOC_LIFEDEAD et GOC_Destroyer::Destroy())

- 04/10/2019 : modifications ObjectControls
-> envoi d'un message ou deux messages (nodes server et retour des nodes du client) plutot que de nombreux messages (1 par node)
-> compression ok LZ4
--> amelioration possible : un objectcontrol c'est 72bytes + 4bytes pour le nodeid. réduire au max les données à envoyer. si pas de changement garder une version déjà compressée
    et la renvoyer tel quel.

- 30/09/2019 : GO_Pools::AddPool() reprend de nouveaux numeros à chaque appel. les numeros ne seront alors plus synchro entre serveur et clients dés qu''un client quitte le mode de jeu et y revient
-> OK : Reserver une seule fois et simplement restaurer les pools après chaque session PlayState

- 28/09/2019 : crash du client en mode arena lorsque celui-ci retourne au mainmenu et revient dans le mode arena
-> GameNetwork::PurgeObjects supprime les nodes qui sont des poolnode
-> Correctif GameNetwork::HandlePlayServer_NetworkUpdate() reset de allClientsRunning_ et allClientsSynchronized_ permet de relancer un client déjà connecté qui est retourné au mainmenu

- 26/09/2019 : correctif de l'orientation des lames, correctif de l'orientation de Churros, Vampire ... qui ont une orientation inversé
-> OK : ajouter le set de GOA::DIRECTION dans GameNetwork::PrepareControl() et sa prise en compte dans Ability::Use(static)
-> OK : suppression du FlipX dans GameHelpers::SetPhysicProperties()

- 26/09/2019 : Lorsqu'un coup est porté sur un client, GOC_Life::ApplyForceEffect est bien appliqué mais un décalage se produit ensuite en sens inverse de cet effet
-> vérifier la force appliquée et son point d'application coté client émetteur et client recepteur.
-> le différé de positionnement introduit dans GOC_Controller::Update() n'est pas suffisant.
--> Il faut compenser les latences client->serveur->client.
---> OK : ajout int updatedState_, cf GOC_Controller::Update()

- 13/09/2019 : le grapin sur les clients autre que spawneur n'est pas bon au niveau du lien de la chaine avec l'avatar.
--> sur les clients l'avatar "!MainControlled" a un RigidBody STATIC ce qui pose pb pour l'établissement du lien
--> mettre les RigidBody en DYNAMIC regle ce probleme (cf GOC_Controller::ChangeAvatar())
---> cela créé des problemes de sacade dans le saut desormais sur les autres clients du à GameHelpers::SetPhysicProperties() qui s'assure qu'il n'y ait pas trop de gap de positionnement reseau.
---> le code dans GameHelpers::SetPhysicProperties() est indispensable pour eviter que l'entité reste bloquée.
---> dans GOC_PhysicsGrapin::AttachOnRoof(), le centre de masse obtenu avec GetBody()->GetWorldCenter() est différent avec des Body de type different (STATIC et DYNAMIC)
---> la contrainte Revolute2D ne semble pas etre créée entre le dernier maillon de la chaine et l'entité à attacher.
----> pour compenser ces pbs, communiquer en plus la position du node et la position du centre de masse pour l'entité à attacher.
    ---> à réception dans GameNetwork::HandleObjectControlHolderChanged(), setté la position du node et utiliser GOC_PhysicsGrapin::AttachOnRoof(grapin, cm_entité, numlinks)
----> OK, mais la chaine n'est pas tendue. Pb de poids ? l'entité attachée étant un STATIC, la simulation n'applique pas de poids ?
-----> avec l'entité en DYNAMIC -> la corde n'est toujours pas tendue ...
------> la simulation n'est pas ok car aucune gravité et force ne s'applique sur les clients avec l'option SetPhysicEnable(false)
------> lorsque attachOnRoof, il faut une simulation complete avec gravité et forces => mettre GOC_Move2D::SetPhysicEnable(true, true),
        au moment du détachement de la chaine, remettre physicEnable à sa valeur initiale.
------> NOK, surement le resultat des modifications de position via le reseau, voir pour desactiver ces modifications
------> NOK en desactivant les modifications de position et en corrigeant GOC_Controller::Update(const ObjectControlInfo& info) pour appliquer completement les entrées buttons
------> Il manque l'application des forces et velocités appliquées à l'attachedNode juste avant la création de la chaine. Le dynamique initial en somme.
-------> 25/09/2019 - OK : Ajout Box2D::SetDynamics() et GetDynamics() et ajout rotation initiale du grapin (ajout float ObjectControl::holderinfo_.rot2_),
        il n'est plus nécessaire d'activer GOC_Move2D::SetPhysicEnable - l'update des Data dynamics dans GOC_Controller suffit.

- 20/09/2019 : modifier GOC_Life pour que sur les clients l'animation passe au STATE_HURT dès qu'un coup est porté
-> est-ce possible depuis que les clients sont en STATIC body ? -> modif de GOC_Collide2D::HandleBeginContact() pour appliquer la collision en ClientMode
--> OK : modification de GOC_Life::ApplyAmountEnergy(), GOC_Life::HandleReceiveEffect() et GOC_Controller::Update() pour eviter l'interruption du STATE_HURT
--> la force du coup n'est pas appliquée sur les !maincontrolled, du coup l'animation STATE_HURT apparait puis il y a un differé non souhaitable pour l'application de la force
---> en STATIC BODY aucun force ne peut etre appliquée, soit repasser en DYNAMIC BODY soit simuler de la force par un déplacement
---> OK : les GOC_Controller repasser en DYNAMIC BODY et Modification du GOC_Collider2D::ApplyForceEffect déplacé dans GOC_Life::ApplyForceEffect et utilisation de RigidBody2D::ApplyLinearImpulse() ald RigidBody2D::ApplyForce()
    + modification de GOC_Controller::Update() pour que le changement de position se réalise une fois le STATE_HURT achevé.
----> pb de bloquage apres saut sous les plateforms avec DYNAMIC.
-----> OK : correctif dans Urho3D::PhysicsWorld2D::BeginContact() dans le "One Way Wall" en s'assurant que le point de contact et bien positionner sous le centre du collisionshape de l'entité

- 16/09/2019 : pb sur le Fly en reseau
--> OK : GameHelpers::SetPhysicProperties() était sollicité en permanence lors du Fly - desactivé.

- 16/09/2019 : pouvoir choisir le type de pool (ObjectPool ou GO_Pool) dans GOT::Register() permettant d'appliquer la poolqty dans GO_Pools::AddPool()
-> OK

- 31/08/2019 : ABILITY_GRAPIN et GOC_PhysicsGrapin en reseau => utiliser le meme principe que ABILITY_SHOOTER
-> creer un GOPool pour les chainettes et pour le Grapin.
-> utiliser AddObjetControl(node) et voir pour modifier Ability::Use(Node* node, const ObjectControl& control) qui est utiliser par World2D::NetSpawnEntity()
--> 13/09/2019 OK : modification d'ObjectControl pour ajouter holderinfo_ + modif Ability, GOC_PhysicsGrapin + Ajout GameNetwork::HandleObjectControlHolderChanged()

- 03/09/2019 : ping pong infini client->serveur pour la suppression de Lame (GO_Pools) NetSpawné sur le serveur
-> coté Serveur : GOC_Destroyer::UpdatePositions() envoit un DIE => qui envoit un netmsg ERASENODE.
-> Le Server reçoit encore des ObjectControls sur ce node qui font encore NetSpawné le node et rebelotte pour le DIE.
--> le GOC_Destroyer::UpdatePositions() n'est effectif que si le Body est DYNAMIC. Mettre le body en STATIC avant de passer le node en Enabled.
---> OK World2D::NetSpawnEntity ajout de body en STATIC
--> Attention : poosibilité d'avoir le même problème avec les players qui sont en Dynamic sur le serveur

- 12/09/2019 : l'attaque d'un client ne touche pas sa cible lorsque le serveur et le client ne sont pas sur le meme viewZ
-> probleme avec le TriggerAttack qui n'est pas déclenché sur le serveur (fonctionne par contre quand sur le meme viewZ)
--> il s'agit de la desactivation du rendu des AnimatedSprite2D qui ne sont pas visibles
---> il faut voir pour permettre l'activation des triggers coté serveur dans tous les cas
----> OK : AnimatedSprite2D::UpdateAnimation() patched

- 03/09/2019 : Ameliorer la synchronisation des clients au lancement du Playstate
-> pb avec les timestamp : modification de GameNetwork::HandleServer_MessagesFromClient et ajout de CheckReceivedGameStatus : basé sur les gamestatus plus que sur le timestamp
-> modification de la logique dans GameNetwork::HandleServer_MessagesFromClient et GameNetwork::HandlePlayServer_NetworkUpdate
-> OK, fonctionne en mode Synchronization des clients et sans synchro (Modifier GameNetwork::needSynchronization_ dans GameNetwork::Reset())

- 30/08/2019 : les Lames changent de ViewZ automatiquement.
-> Ajout à l'objet Lame GOC_Destroyer de l'attribut "World Position Update" = false
--> OK : ne met pas à jour le world position ni le viewZ

- 30/08/2019 : les dps ne sont pas appliqués pour client->serveur->client
-> sur le serveur, les body et les trig attack des clients sont en STATIC. Les contact STATICBODY avec STATICBODY ne sont pas permis (cf b2Body::ShouldCollide)
--> sur le serveur tous les players doivent avoir des BT_DYNAMIC : Ok correctif dans GOC_Controller::ChangeAvatar
---> sur le serveur, cela engendre des rebonds des entités
----> essai en desactivant les interaction avec GOC_Move2D qui peut appliquer des forces au contacts avec le sol : réactivation de ajout de GOC_Move2D::SetPhysicEnable() mis à false pour les !mainControlled
-----> toujours des rebonds : le changement de position tres proche du sol fait-il reagir box2d avec une force de repulsion pour eviter la penetration du DYNAMIC dans un element STATIC ?
------> OK ! dans GOC_Move2D::HandleWallContactBegin() ajout de body->SetAwake(false) permettant de supprimer les forces, impulsions appliquées sur le body durant le contact.

- 30/08/2019 : les Parts Exploded des GOC_BodyExploder2D n'ont pas les meme dimensions serveur et clients
-> pb avec l'Event OBJECTCONTROLIDLECHANGED : les exploded parts sont spawnées via le net avant d'être spawnées via GOC_BodyExploder2D
--> solution temporaire GameNetwork::HandleObjectControlIdleChanged() skipper les nodes taggés "UsedAsPart"

- 19/08/2019 : activer les lames et grapin pour le network
-> cf GO_Pool et Abilities
--> Strategie d'allocation de nodeid à revoir : les players doivent tous etre simulés sur le serveur.
    -> les GO_Pools sont alloués et liés à chaque joueur et disposent de leur plages spécifiques d'allocation mais nécessite d'etre alloués sur tous les clients.
    --> ainsi il est facile de popper sur un client et d'avoir la correspondance des ids sur le serveur et les autres clients.
    --> il faut s'assurer que les clientid soient bien définis sur tous les clients => ajout de GameNetwork::Server_GetNextClientID() envoi des clientid par remoteevent=NET_GAMESTATUSCHANGED
    --> On limite à 64/128 ou 256 joueurs et on construit les Pools en fonction de ce nombre max de joueurs => GameStatus::MAX_NUMNETPLAYERS
    --> le joueur a acces à ses pools en indiquant son clientid => GO_Pools::GetPool(clientid, got).
    ---> OK
--> ABI_Shooter OK pour server vers client
    --> ajouter le sendevent à GameNetwork::AddServerObjetControl() sinon l'ObjectControlInfo reste inactif lors des utilisations suivantes du node poppé
    ---> vérifier les états Idle et Active de l'ObjectControlInfo
    ----> OK avec application du nouveau principe décrit section suivante.
--> ABI_Shooter client vers serveur
    -> modification du net player sur le serveur (ClientInfo::players_) permettant d'utiliser le FIRE2
    --> GOC_Controller::Update(const ObjectControlInfo& info) recuperation du state buttons_ et sendevent GOC_CONTROLACTION2
    --> lors du pop d'une lame, Crash du à la corruption du Vector GameNetwork::serverObjectControls_
    ---> dans GameNetwork::Server_UpdateObjectControls, lors de la boucle sur GameNetwork::serverObjectControls_ l'appel de GOC_Controller::Update() avec le sendevent GOC_CONTROLACTION2 ajoute un element à
        GameNetwork::serverObjectControls_ => OK : modification du for par un while
    --> régler la direction du Spawn
---> changement du principe de Spawn : GameNetwork::AddServerObjectControl() devient GameNetwork::AddObjectControl()
    ----> la variable ObjectControl::idle_ sert à communiquer l'état Spawné via le Network.
    ----> lorsqu'un changement d'état de cette variable intervient, Connection::ProcessReceiveServerObjectControl() et Connection::ProcessReceiveClientObjectControl() envoient
        l'Event OBJECTCONTROLIDLECHANGED qui est récupérer par GameNetwork::HandleObjectControlIdleChanged() pour Spawner l'entité ou la détruire.
    ----> OK !
--> RAF : GRAPIN

- 13/08/2019 : pb avec les bones PreparedMode de GOC_BodyExploder2D => 2 cas : LOCAL et REPLICATED mode
-> en LOCAL (creation de nodes LOCAL permise sur le serveur cf. ObjectPool::CreateChildIn() define OBJECTPOOL_LOCALIDSONLY)
    les Bones sont bien spawnés coté serveur, mais pas coté client : les ids locaux serveur n'arrivent pas à être recréer sur le client
--> il n'y a pas besoin de les recreer. le client doit les faire exploser (ils sont déjà preparés).
--> il faut assurer une correspondance entre les nodes client et les nodes serveur, les nodesids ne seront presque jamais identiques dans le cas des nodes préparés et surtout avec la gestion en multi-maps
---> OK correspondance assurer : modification de ObjectPoolCategory::GetPoolNode().
-> les bodyexploder n'explosent pas sur les clients car ne recoivent pas le totaldps leur permettant d'envoyer l'event GOC_LIFEDEAD
--> OK : modification GOC_Controller::PrepareObjectControl()
--> les positions des parts ne correspondent pas. Les parts ne sont pas ajoutés à GameNetwork::serverObjectControls_.
---> OK : création de GameNetwork::AddServerObjetControlSilent() pour éviter d'envoyer les events ADD_NODE (les node sont déjà créer coté clients et serveur)
-> en REPLICATED, les Bones ne sont pas préparés comme il faut sur le serveur
--> RAF !

- 15/08/2019 : pb avec Scene::NodeIDChanged() pour les childs
-> si les nodes sont marqués temporary, ne pas modifier les ids
-> les Bullets ont des AnimatedSprite2D qui génére un node "physic" TRIGATTACK.
--> OK : les nodes physic sont désormais mis en temporaire pour eviter le changement de ids

- 15/08/2019 : en mode Client pb de boucle sans fin de add/remove sur les Bullets REPLICATED
-> GOC_Destroyer::Destroy() est lancé par le GOC_Destroyer::HandleUpdateTime()
--> mettre GOC_Destroyer::SetEnableLifeTimer(false) pour toutes les entités spawnées par GameNetwork::Client_AddServerObject()
---> OK : World2D::SpawnEntity(const ObjectControlInfo&) devient World2D::NetSpawnEntity(ObjectControlInfo& info) et intégre GOC_Destroyer::SetEnableLifeTimer(false)

12/08/2019 - probleme entre serveur et clients, les furnitures spawnés n'ont pas le meme charactermapping ou entityid
--> voir Map::SetFurnitures(), MapGenerator::GenerateBiomeFurnitures()
---> OK : modification de MapGenerator::GenerateBiomeFurnitures(), remplacement du Random() par GameRand(OBJRAND)
    et utilisation du tileindex pour le COT::GetRandomTypeFrom()

11/08/2019 - Reprise de Frombones
-> Les entités Non-Maincontrolled auront un RigidBody2D de type BT_STATIC (Sur Client toutes les entités non controlées par le joueur sont Non-Maincontrolled).
    ca supprime les décrochages du au calcul Physique des BT_DYNAMIC melé aux updates des positions via reseau. Mais il faut modifier GOC_Collider2D concernant les collisions entre entités réseau.
--> OK : Appliquer dans GOC_Controller::SetMainController() et GOC_Controller::ChangeAvatar()
-> Modifier GOC_Collider2D pour autoriser les collisions avec les BT_STATIC des autres clients.
-> au lancement les players sont superposés.
--> cf GameNetwork::Server_AllocatePlayers(), ClientInfo::CreateAvatarFor() et GameStatus::SetWorldStartPosition()
--> le positionnement initial des players doit etre imposé par le serveur et non pas par les clients.
--> OK : modification de PlayState::SetPlayers() en mode ClientMode, recuperer les positions du serveur via GameNetwork::GetClientObjectControl()

-> A solutionner : Purge des Objects inactivés et Reactivation des objects inactivés
  -> Attention : le reseau envoie des ghosts (persistence)
  => DesactiveTimer OK !

-> au restart d'un joueur :
  -> pour les autres clients, ajouter l'effet respawn
  ==> OK

-> Reconcevoir la creation/suppression des objets en mode réseau :
--> pb avec GOC_Collectable : drop et collect
--> les nodeid sont attribués par le serveur
---> client demande la creation/suppression au serveur qui le réalise
==> OK, test en cours

--> appliquer le meme procedé pour la creation/suppression d'avatar ?
==> OK, test en cours

-> lors du restart, resoudre le respawn du meme avatar, pas de pb coté client
--> coté serveur, ne pas regénérer un nouvel avatar
--> appliquer le meme procedé que pour les objectpools
==> OK, test à faire

</>

*/


/** ========= **/
/** MAPWORLD  **/
/** ========= **/

/* TODO
------

- 13/10/2023 : en mode arena, apres avoir passer le boss darkren au niveau2
-> pb de generation de monde

- 13/10/2023 : lorsque l'on monte un mur,
.
*
** <-/> ce bloc n'a pas de collider
*
*
=> 16/10/2023 : Patch dans MapColliderGenerator::TraceContours_MooreNeighbor

- 27/05/2023 : supprimer les fenetres dans le Backview. il est bizarre d'avoir des trous lorsque l'on est en frontview.
=> OK modification de ObjectFeatured::SetViewConfiguration
- 27/05/2023 : les Tronc ou autre furniture Static posent probleme au niveau collision si ils sont en Innerview mais restant visible en frontview :
 le player voudrait pouvoir ci accrocher et le choix est fait que ce ne sera jamais le cas pour éviter que les furnitures innerview dans des murs ne pisent entrer en collision avec les acteurs du frontview
=> modifier le visuel pour mettre en backactorview ces furnitures.
==> OK : modification de Urho3D::Drawable2D::GetSourceBatchesToRender()
==> OK : modification de Actor::Start() pour etre sur que le viewmask soit bien attribué.

- 13/03/2023 : revoir les decorations en bordure de worldEllipses car en fin de monde ils ne sont plus raccord à l'ellipse affichée. Il faudrait que les decorations suivent bien le contour de l'ellipse (rotation).
=> 01/05/2023 : premiere tentative sur DrawableScroller
=> 22/05/2023 : seconde tentative -> pour la gestion des drawables, l'ellipse est traitée par partir : les demi-ellipses haute et basse.
==> 25/05/2023 : grosse modification de DrawableScroller : ajout de DrawableScroller::UpdateDrawablesOnTopCurve() et  DrawableScroller::UpdateDrawablesOnBottomCurve()
==> unifier la couleur entre worldEllipses et les 2 plus proches DrawableScrollers.
===> uniquement à revoir les textures : la worldEllipse (ScrollingShape) s'appuie sur backrock de backshape.png qui est en niveaux de gris, les drawableScrollers s'appuient sur fond.png qui sont en couleur.
====> remise en couleur du backrock
===> mettre en (LIT) les DrawableScrollers et worldEllipse.
==> RAF : permettre le changement de zone, les elements de scrolling doivent pouvoir changer.

- 26/07/2020 : pouvoir planter des graines (vegetation)
=> gestion de la croissance des plantes/arbres/fleurs
==> cf MapGenerator::GenerateBiomeFurnitures()
==> le code s'appuie sur MapTopography et sur la carte de biome
===> voir pour modifier les valeurs de biomemap pour y integrer les graines ?
===> MapTopography est générée une fois à la creation de la map
====> il faudrait pouvoir l'updater dans Map::SetTile mais attention avec la decoration d'arriere plan DrawableScroller (cf Map::AddBackGroundLayers et DrawableScroller::SetDrawableObjects) qui s'appuie aussi sur MapTopography
====> les images collées au tilelayer de BACKGROUND sont des fonds.xml@fond3 (cf l'attribut "Map - Add ImageLayer" dans testzone2.xml => cf MapWorld::SetMapAddImageLayerAttr)
=> pouvoir booster la pousse de la vegetation (intervention entity genre totoro, gardien de la nature ou esprit des plantes)
==> faire un essai avec un mode souris qui en survolant les plantes les font grandir.
=> pouvoir planter certaines types de graines sur RockGolem : transformation du RockGolem => le rend pacifique ou bien aggressif
=> pousse de differents type de vegetation : pacifiques ou agressives (chaos...).
=> la pousse de crystaux également à gérer.
=> la propagation pourra être par graine (spore, graine...) ou par racine/extension du pied mere de proche en proche.
==> 02/04/2023 : Reprise et création d'un LindenMayer System (LSystem).
===> 03/04/2023 : Ajout de LSystem2D qui est un composant derivé de StaticSprite2D basé sur un system LindenMayer simple (cf "Algorithmic beauty of plants" en pdf dans /Dev/Lab/trees)
====> gestion de l'age de la plante, de sa croissance et animation (repos, collision, vent1, vent2)
=====> RAF : ajouter un parametre global qui permet de régir l'animation pour differentes conditions de vent.
====> RAF : ajouter les categories de presets : "plantes", "plantes florales", "arbustes", "arbres fruitiers", "grands arbres"
====> certains grands arbres en bordure de map vont disparaitre ou apparaitre car lié à la visiblité de la map.
=====> il ne faudrait pas gerer l'activation/visiblité des ltree avec la visibilité des maps.
======> 06/04/2023 - OK : ajout de l'attribut GOA::KEEPVISIBLE et modification de MapBase::AddFurnitures() et Map::SetVisibleEntities()
====> RAF : adapter les sprites branch et leaf en fonction du type de biome.
====> RAF : rajouter fleurs et fruits.
====> RAF : possibilité d'ajouter des nodes pour permettre l'ajout de collider.

- 08/03/2023 : ajout de MapGeneratorDungeon::MakeTowers()
=> RAF : une meilleure repartition des tours.
=> RAF : ajout de toitures ou de creneaux.
==> utilisation de tiles.
==> Modification de ObjectTiled::UpdateTiledBatches()
==> Modification de MapColliderGenerator::GenerateWorkMatrix() et MapColliderGenerator::AddPointsToSegments, MapColliderGenerator::TraceContours_MooreNeighbor() pour generer les collider en halftiles nécessaire pour l'innerview.
=> RAF : ajout de passerelles entre tours.
=> RAF : ajout de remparts entre tours ou en devanture
=> RAF : ajout de decoration exterieurs : drapeaux, torches, porche ...
=> RAF : ajout d'acces : trappe au plafond.
=> fermeture des pignons.
==> 17/03/2023 : Modification de MapColliderGenerator avec ajout de BlockShape pour remplacer les HalfTiles et modification de MapColliderGenerator::TraceContours_MooreNeighbor().
===> RAF : ajout d'un tile de fermeture.
=> RAF : une tour peut se retrecir vers le sommet.
=> RAF : une tour large peut se scinder en plusieurs tours vers le sommet.
=> RAF : une tour dont les points d'accroche sont detruits doit s'ecrouler.
==> RAF : si mise en place de roues : MOBILECASTLETYPE

- 13/03/2023 : il existe des problemes de generation des maps
=> lors MapCreator::PurgeMapsOutsideVisibleAreas() la map doit etre correctement dechargée autrement les furnitures et entities seront encore affectées et reapparaitront lors de sa reaffectation par MapPool.
==> forcer le status à Unloading_Map.

- 13/03/2023 : il faut absolument que la map current soit generer en priorité ainsi qu'afficher.

- 06/03/2023 : ajout de MapGeneratorDungeon::MakeRandomWalk()
=> pas encore top : pour le moment desactivation

- 27/01/2023 : probleme d'affichage de RenderShape en Bordure de Map
=> verifier le worldboundingbox ?
==> OK : ajout de MarkDirty() dans RenderCollider::UpdateRenderShape()=>RenderShape::SetCollider() (qui modifie les shapes) afin de permettre de mettre worldBoundingBoxDirty_ à true.

- 24/01/2023 : il faut ajouter des tiles d'incrustation supplementaires (mousse, pierre, crane, tache, planches ...)
=> les terraintypes ne sont pas adaptés : ils ne servent qu'à associer un MapTerrain à un index 'terraintype' qui est lu dans la terrainmap.
=> il faut pouvoir lier terrain et biome (pour le moment  c'est un niveau de vegetation)
==> en fonction de la valeur de biome, le terrain sera choisi
=> supprimer l'enumeration MapTerrainType et TerrainAtlas::GetTerrainFromType()
==> OK remplacement par TerrainAtlas::GetBiomeTerrain.
=> deplacer et modifier ScrapsEmitter::RegisterType() pour les terrains dans le TerrainAtlas qui ajoutera le bon type de scraps-sprite selon le terrain.
==> OK : modification TileSheet2D::EndLoadFromXMLFile, MapBase::SetTile(), GameHelpers::SetTile() et GameHelpers::RemoveTile()
===> il reste certaines Tiles qui ne renvoit pas le bon terrainid.
=> il faut pouvoir creer plus de type de terrain dans la texture tiles_terrain_g.png pour le moment elle est en 1024.
==> en hdpi on pourrait la passer de base à 2048 tout en gardant des tiles de 128 ce qui permet de stocker 4 fois plus terrains (pour le moment que 4 textures de terrain sont compris dans le png) on pourrait passer à 16.
===> OK : adapter TileSheet2D pour prendre en compte le dpiRatio de la texture.
=> la taille scraps en changeant de dpi n'est pas la bonne.
==> OK : suppression dans GameHelpers::SpawnScraps() de l'utilisation des Dpi de Texture qui sont dejà pris en compte dans Sprite2D.

- 20/01/2023 : lors de la generation des colliders (MapColliderGenerator), il arrive que son interruption pour repasser sur une autre map à créer, puis sa reprise ne permet pas de generer correctement les colliders (cela se voit tres bien avec les rendershapes)
=> il faut pouvoir logger lors de la reprise et s'assurer que les bons etats et buffers sont correctes.
=> correctif dans MapColliderGenerator::GeneratePhysicCollider() et MapColliderGenerator::GenerateRenderCollider()
==> a verifier

- 12/03/2021 : modifier le MapGeneratorDungeon pour reduire les passerelles exterieures et ajouter des escaliers, echelles ...
=> voir pour avoir des exterieurs de dungeons qui soient plus uniformes : de grandes tours par exemple.
=> voir pour creer l'aspect exterieur en premier et mettre les rooms dans l'espace alloué (inspiration : les habitats de glace/neige dans le film les minions)
==> shape circulaire, ovale
===> 15/03/2021 : ajout de PixelShape permettant de generer des superellipse, spirale etc...

- 20/11/2022 : Utilisation seulement de WorkQueue pour l'ensemble de operations en thread (MapSerializer, AnlWorldModel)
=> utilisation egalement des events E_WORKITEMCOMPLETED
==> OK 22/11/2022 : Attention il faut utiliser WorkQueue::Complete() dans MapStorage::UpdateMapsInMemory() pour eviter une boucle sans fin pour non reception des events E_WORKITEMCOMPLETED lorsque l'on utilise World2D::UpdateInstant()
==> RAF verifier les thread pour la generation de WorldMap. cf AnlWorldModel et anl::maptobuffer

- Crash avec Generation des SnapShot d'IMAGING.
=> le cache est redimensionné alors qu'utiliser par la generation d'une Map.
==> il faut creer des slots MAPGENSLOT, SNAPGENSLOT qui seront passer à CNoiseExecutor
===> OK

- World2D :
=> 29/10/2022 : correctif dans World2D::UpdateStep() et MapStorage::UpdateBufferedArea() et MapStorage::UpdateMapsInMemory() permettant la bonne purge de MapCreator et aussi l'assurance que WorldViewInfo::currentMap_ soit bien attribuée.
==> voir si impact si avec le transfert GOC_Portal.
==> OK : ça à l'air bon.

- Créer WorldMap
=> 07/10/2022 : reprise
==> voir AnlWorldModel::SaveScreenShots()
==> creer l'ui de generateur de monde avec dimension du monde (minuscule, petit, standard, grand, tres grand), la racine, le nom du monde, les biomes majoritaires (jusqu'à trois) et l'apercu.
===> pour l'aperçu lancer un thread pour la generation de la carte du monde en basse definition. ce thread va réaliser plusieurs aperçus sucessif. Le premier snap en tres basse resolution (64x64 pixel). Puis d'autre snapshots continueront d'etre generés pour ameliorer le visuel de l'apercu.
	 il faut que ce soit tres rapide, instantané pour le premier snap !
===> également option d'edition du monde généré => on rentre alors de l'editeur de monde.
===> également definir la position de départ sur le monde ("Default Map Point")
==> le worldmap devra etre accessible en jeu dans la minimap en double-cliquant dessus par exemple ou sur un icone dédié placé sur le coin de la minimap.
===> premier correctif OK sur la generation par thread de anl::maptobuffer (ajout de Urho3D::WorkQueue)
====> Attention la generation des snapshots CaveMap ne fonctionne pas toujours => on obtient uniquement la version GrounMap
=====> ce n'est pas du à la dimension en pixel des essais concluants de generation avec testzone2 en debug et release de 32 à 1024 pixels !
=====> difficile d'identifier la cause
======> en utilisant dans vm.inl la directive #USE_CACHESTAT, et en testant plusieurs fois pour generer au moins une erreur, on obtient des 'inf' et des 'nan' à partir de l'instruction 25(GradientBasis) et 14(GradientBasis)
=======> les valeurs d'entrée coord.x_ et coord.y_ sont hors des limites. Il faut remonter sur la generation de ces coordonnées juste avant l'application du Gradient.
========> le probleme provient de l'instruction 213(RotateDomain) : les coordonnées z et u sont nan ici => pb d'initialisation.
=========> il s'agit de l'operateur + de CCoordinate qui initialiser un Coordinate via le construction CCoordinate(dimension) qui ne set pas les valeurs initiales.
==========> suppression de ce constructeur et modification de l'op+
===========> verifier si d'autres problemes de ce type dans les CCoordinate et VM.
==> la bonne pratique en debuggage c'est de pouvoir remonter dans les fonctions. si une fonction renvoit un nan alors il suffit de le pister en rajoutant ensuite if (isnan(value)) et de rajouter l'appel à cette fonction qui plante une nouvelle fois
	ex  avec le gradient_noise :
        	gradient_noise(coord, seed_, InterPolationFunctions[interpol_], &cache.outfloat_);
            if (isnan(cache.outfloat_))
				gradient_noise(coord, seed_, InterPolationFunctions[interpol_], &cache.outfloat_);
il faut mettre le point break sur le second gradient_noise ainsi l'on peut verifier en step into ce qui pose pb dans la fonction.
===> dans ce cas le pb etait bien amont avec un pb de coord mais l'astuce precedente pourrait servir.
==> pour l'ui dans sOptions, il y a deja la categorie world avec quelques parametres tel que worldmodel et worlddifficulty qui ne sont pas encore connectés.
===> voire pour renover cette ui.
===> ajouter worldsize et un slot pour montrer le snapshot aperçu => OK
====> ajouter un bouton sur le snapshot pour l'agrandir
====> ajouter un bouton pour selectionner le point de départ sur le snapshot
===> ajouter un bouton pour lancer l'éditeur.
===> ajouter un textedit pour le nom du monde => OK
====> ajouter un generateur aleatoire de nom pour les mondes
===> ajouter un bouton a coté du dropdownlist "racine" pour regénérer une nouvelle racine aléatoire. => pas besoin cliquer directement sur aleatoire
====> supprimer worlddifficulty => OK
=> la generation du snapshot ne devrait-t-elle pas etre comme celle de la minimap qui dispose de layers innerview et frontview.
==> il faudrait aussi inclure les donjons lorsque la granularité dans AnlWorldModel::GenerateSnapShots est égale à AnlWorldModelGranularity.
=> en release avec des snapshot de 1024, le thread sont trop long à completer ce qui va avoir pour effet en cas de changement de parametre (model,size ouseed) de geler le mainthread qui est en attente de la fin des autres threads pour finaliser les changements de parametres dans anlworldmodel.
==> maximiser la taille traiter pour les SChunk à 2048max. Il y aura plus de Schunk (plus que le nombre de thread mais gerer par la workqueue donc pas de pb)
===> OK 22/10/2022 : marche uniquement avec workqueue.
===> 26/10/2022 : implementation de l'interaction pour la worldmap dans OptionState::HandleWorldSnapShotClicked (zoom in/out et move)
====> il semble y avoir un decalage assez consequent en bordure de monde entre le snapshot et le monde généré en PlayState.
====> test réalisé avec un monde moyen ellipse racine 2000 en bordure la map -62,1 de la worldmap devrait etre -52,1
====> la scale si zoom maxi (taille d'une map) devrait etre de 1.f hors elle est 0.83f. le scale initial n'est pas le bon. Il faut une puissance de 2
=====> 30/10/2022 OK : modification OptionState::ApplyWorldChange() et OptionState::HandleWorldSnapShotClicked
====> dissocier de OptionState => creer un composant UIC_WorldMap qui entrera en interaction avec OptionState et UIC_MiniMap.
=====> ajout de la structure de base UIC_WorldMap. Reprendre le contenu de OptionState.
=====> la texture snapshot sous vulkan est par défaut filtré lineaire : modification de Urho3D::Texture::UpdateParameters() pour obtenir le meme resultat que sous GL (fonction des parametres de filtre de chaque texture).
=====> le zoom/dezoom n'est plus bon. => verifier le set initial et le scale à 1.f en zoom maxi (1 map) => le zoom maxi est de 0.65f
======> OK : la puissance de 2 doit etre sur le nummaxmaps (non sur le worldscale)
=====> zoom 4 map en initiale et centrage sur la carte courante World2D::GetCurrentMapPoint(0)
=====> le bouton worldButton doit etre un switch de UIC_MiniMap et UIC_WorldMap.
======> OK : Creer un second button sur UIC_WorldMap pour reswitcher vers UIC_Minimap.
===> pour le moment l'acces au monde Custom (GameStatus::testZoneId_=3) se fait uniquement si le nom du monde est rempli.
====> remplacement de la logique : affichage par défaut du TestZone2 (voir pour ameliorer le code), en changeant le nom du monde on passe en CUSTOM.
=====> ajout du DropDownList avec LineEdit (cf style OptionEditableDropDownList) modification Urho3D::DropDownList ajout de attribut "Editable PlaceHolder"
====> TestZone2 doit avoir les parametres non editable hormis la selection de la carte initiale par defaut.
=====> 02/11/2022 : OK lors du OptionState::HandleWorldNameChanged mettre les controls model,size,seed non editables si TestZone2
===> correctif du radius par default dans AnlWorldModel :
====> mettre à 0.f puis dans modelAnlWorldModel::EndLoadFromXMLFile() le radius sera attribué avec la valeur spécifiée dans le XML. Si non spécifié dans le XML (par radialshape) alors il sera mis à 1.f.
==> OK 03/11/2022 : OK ajouter la position des players
==> OK : stocker en memoire directement plutot que dans un fichier snapshot.png.
==> OK : changer la couleur blanche par défaut du snapshot.
==> OK 05/11/2022 : Ameliorer la navigation de la WorldMap avec le cursor qui change pour indiquer le deplacement et deux boutons zoom et dezoom.
===> ajout de Cursors direction et zoom + modification UIC_WorldMap::HandleWorldSnapShotClicked
==> RAF : creer dans OptionState, un profil pour sauvegarder les parametres de chaque monde créé par le joueur (worldname, worldmodel, worldsize, worldseed, worlddefaultmap).

- 28/10/2022 : probleme avec la worldellipse et les anlworldmodel :
=> la worldellipse ne doit s'appliquer que pour le modele ellipse : il faut trouver un autre moyen d'afficher un fond pour les modeles circle et plane.
==> meme pour le modele ellipse, il faut changer d'objet car pas toujours adapté (si on utilise un modele ellipse minuscule ou petit).
==> voir pour extraire du snapshot du monde des points caracteristiques pour creer par map une shape de fond.
===> voir World2DInfo::Update et toutes les ellipses World2DInfo::worldGroundRef_, World2DInfo::worldAtmosphere_, World2DInfo::worldHillTop_, World2DInfo::worldGround_, World2DInfo::worldCenter_
====> pour le moment seuls World2DInfo::worldGround_ et World2DInfo::worldHillTop_ sont utilisé et seul World2DInfo::worldHillTop_ est utilisé pour le rendu avec le ScrollingShape de fond en BACKROCK et les DrawableScroller l'utilisent en boundcurve.
=====> inactivation des worldEllipses via ACTIVE_WORLDELLIPSES. Test avec la Spline2D MapTopography::backFloorCurve_.
======> correctif de MapTopography::backFloorCurve_ : suppression de l'algo par dichotomie qui ne retournait pas de valeurs lissées. cf MapTopography::GetBackFloorNearestYAt
=======> verifier l'utilisation de MapTopography::freeSideTiles_ car il semble que les resultats different en fonction du CurrentViewZ. cf MapTopography::Generate
========> uniquement utiliser par MapGenerator::GenerateBiomeFurnitures lors de la generation de la map.
=========> eclatement de MapTopography::Generate, creation de MapTopography::GenerateFreeSideTiles les freesidetiles ne sont generes que si creation de biomefurnitures (non creer en cas de chargement de la map), il n'est pas necessaire de les drawdebug.
======> MapTopography::backFloorCurve_ ne peut etre utilisé pour les effets parallax de chaine de montagne ou foret. Il faut pouvoir reconnaitre une à plusieurs ellipses de ground à partir de la worldmap.
=======> voir World2DInfo::Update

- 03/06/2022 : la sauvegarde du world avec les fluid activés n'est pas implementée
=> voir MapData pour la serialization des FluidMaps
==> Size d'une FluidMap 64x64 Tiles = 4096 Tiles => une FluidCell 1 byte pour stocker la mass uniquement = 4096bytes par fluidmap. 2 fluidmap par map (innerview et frontview) 8192bytes par map.
=> voir MapCreator::GenerateLayers -> ObjectFeatured::SetFluidCells -> FluidDatas::SetCells() -> FluidCell::Set()
==> modification de FluidDatas::SetCells() qui prend en compte désormais les valeurs de mass des FluidCell provenant de MapData
==> la sauvegarde des FluidMap vers MapData::fluidValues_ se fera par FluidDatas::UpdateMapData() dans MapBase::UpdateMapData
===> OK : RAF les FluidSources sont aussi à sauvegarder avec leur états de fluid en cours.

- 26/05/2022 : les maps qui doivent etre visible apres teleportation doivent aussi etre prechargées.

- 02/10/2021 : en world il y a certains problemes :
=> le basculement des entités d'une map vers une autre ne s'operent pas toujours. (probleme existant surement avant)
=> les entités mortes qui n'ont pas basculé vers leur nouvelle map, vont reapparaitre et se remettre en dead lors du deplacement vers la map affectée
==> est-il possible que les entities ne soient pas bien detruites suite à des modifications de GOC_Life ?
==> dans Map::SetVisibleEntities(), il faut aussi absolument tester avant de les reafficher si elles ne sont pas mortes ou si l'animation dead n'est pas finie.
===> modification dans World2D::HandleObjectChangeMap(), GOC_Destroyer::UpdatePositions().
==> suite au modification du 06/10/2021 voir s'il y a encore des pbs.

- 21/05/2021 : Crash dans Map::AnchorEntityOnTileAt() du au tileindex qui trop grand
=> erreur lors du GameHelpers::RemoveTile() avec ajout d'une porte
==> OK : correctif dans MapData::AddEntityData() pour permettre l'utilisation prioritaire d'EntityData pour la position.

- 21/05/2021 : Crash dans Map::SetEntities_Load() concernant les Usable Furnitures
=> OK : Correctif anti-Crash voir ce qui en d'ecoule.

- 10/03/2021 : Bloquage possible dans la generation de map dans MapCreator::CreateMap, MapStorage::InitializeMap()
=> bloquer en boucle
[Wed Mar 10 21:53:11 2021] ERROR: MapCreator() - CreateMap at -2 20 map=356091968 ... status=Initializing=0[0] ... WAITING changing status to Generating_Map !
[Wed Mar 10 21:53:11 2021] ERROR: MapStorage() - InitializeMap mPoint=-2 20(map=356091968) ... Is Serializing MapData ... Wait !
==> 11/03/2021 : Modification de MapStorage::InitializeMap(), check si la map est en cours de serialization, reinitialisation de MapData::state_.
===> La serialization n'est faite pour le moment que lors du SaveWorld et lors du LoadMap.
===> 15/03/2021 : Ajout du state MapStatus::Uninitialized
====> encore des modifications dans MapCreator::Update et surement MapWorld et MapStorage pour le Multiviews
=====> Modification de MapCreator::mapToCreate_ devient Vector<ShortIntVector2></> et non plus Vector<Map*></> ce qui evite tout probleme d'affectation de differentes Map sous le meme mpoint.
====> traquer l'erreur : [Tue Mar 16 15:23:32 2021] ERROR: MapCreator() - GenerateDungeonMap : map=-19 16 ... NO BACKVIEW ... ERROR !
=====> probleme du aux variables locales de MapCreator genFront_, genInner_ et les functors
======> 17/03/2021 OK : mis dans MapGeneratorStatus
====> traquer l'erreur : [Tue Mar 16 17:32:31 2021] ERROR: AnlWorldModel() - GenerateModules : mpoint=-6 -2 map=-6 -2(344023024) ... No More Threads ...
=====> ne pas permettre l'affectation d'une map via MapPool si la map a ete precedement purgé alors que la generation Thread AnlWorld etait en cours => dans ce cas les threads continuent d'ecrire dans les mapfeatures
======> 17/03/2021 OK : check du MapStatus dans le Thread
====> RAF : MapCreator::Update() à rendre Multiviews
====> RAF : modifier World2D::OnMapVisibleChanged()

<ObjectMaped>
- 29/07/2020 : A partir des anciens commentaires suivants, realiser un composant ObjectMaped qui permettra dans un node de créer tous les composants permettant la réalisation d'un chateau ambulant
=>
    - 17/06/2018 : decomposer Map et ObjectTiles pour creer :
        -> TileLayer(Drawable2D) : comprenant un sourcebatch par material pour les (tiles+decals) + un sourcebatch pour les sewings
        -> PhysicLayer : un layer =  un node contenant les component CollisionShape
        -> WaterLayer(Drawable2D) : un waterlayer = un sourcebatch
        -> ces composants sont ajoutés à une entité (Node)
          -> TileLayer & PhysicLayer ajustent leurs batches selon leur visibilité par rapport aux views

    - 13/06/2018 : reconcevoir MapWorld qui est un manager de mise à disposition de Map, comme ObjectTiled l'est pour les Chunk
    -> Map est un ensemble de méthodes construisant la partie physique limité à sa zone rectangulaire définie.
    -> le monde(planete) est composé de Maps. et il est unique.
    -> on veut pouvoir avoir plusieurs planetes (grosses ou petites) et générer de l'interaction entre elles à l'instar des autres entités
    -> on veut aussi qu'une planete(entité) puisse s'aggréger ou s'exploser en differents fragments(entités)
        -> entité cassable (drawable et physic)
            - une planete est constituée de tiles dans notre cas. La Tile est le plus petit fragment.
        -> l'entité doit pouvoir également se déplacer sans moteur physique (cas des entités non visible)
            - creer un composant Drawable2D s'inspirant d'ObjectTiled et capable de modifier ses Batches en fonction de la partie visible
            - doit disposer d'une méthode UpdatePhysic() permettant de recalculer les collisionshapes sur la partie visible
                -> voir si l'on peut utiliser que des collisionboxes ce qui permet d'éviter MapColliderGenerator
        -> pouvoir utiliser ANL pour chaque planete,
        -> creer un composant WorldCreator creant les coordonnees et dimensions des planetes
            -> utiliser ces donnees pour creer le fichier de configuration d'entrée pour ANL pour chaque planete
            -> si la planete est hors de la zone d'exploration pas besoin de generer de feature

    - 18/10/2017 : Modifier Map pour avoir la facilité de connection des FluidCells
    -> sera utile pour la recherche de voisins etc...
=>
==> Reprendre Map et le transformer en composant
===> OK : supprimer tous les elements le reliant au world (minimap, connected maps, topography, backgroundlayer)
===> garder l'ajout d'entités ou de furnitures STATIC uniquement mais non lié au world, ils seront des nodes fils du node d'ObjectMaped
===> garder la génération par AnlWorldModel/MapCreator ? on veut pouvoir creer des asteroid, des iles volantes
====> creation de MapBase qui devient la classe Parent de Map et de ObjectMaped
==> Creer la fonction Node* GameHelpers::CreateObjectFrom(Map* map, const IntRect& rect) permettant la reprise d'une partie d'une map comme nouvelle entity ObjectMaped
===> OK : renommer GameHelpers::CreateObjectMapedFrom()
==> Creer un test pour le changement de position interactif d'un ObjectMaped.
===> Creation de GameStatus::SetControllabledNode() avec utilisation de GOC_PlayerController, GOC_Collide2D, GOC_Move2D et GOC_Destroyer
==> Probleme pour gerer les portes (GOC_Destroyer et currentMap_) => grosse modif à prévoir dans World2D pour intégrer les ObjectMaped, il faut pouvoir tester si l'entité est sur un ObjectMaped en plus d'être sur une Map.
===> OK : modification de GOC_Destroyer::UpdatePositions()
==> problemes pour faire bouger le chateau ambulant :
===> en body BT_DYNAMIC, les differents bodies composants le physic du chateau (1 body par layerZ) s'ecroulent et n'entrent pas en collision avec les colliders de la map.
====> les CollisionShapes sont des CollisionChains pour l'ObjectMaped du chateau et la Map du decors : Box2D n'a pas implementé de contact de type Chain avec Chain (cf. b2Contact::InitializeRegisters())
=====> si on implemente le contact "chain avec chain" il y aura des problemes de collision avec des chain concaves.
=====> le plus simple est d'ajouter des collisionboxes aux extremités du chateau pour chaque collisionchain
======> OK : creation de collisionboxes avec Generation dans MapColliderGenerator en mode BorderMode ou bien InnerMode
====> le rendu ne suit pas les collisionsShapes
=====> l'objectTiled est sur le node principal alors que rigidbodies sont sur des nodes fils et ne sont pas liés : les nodes fils bougent librement mais pas le node parent.
=====> utiliser un seul node avec un seul rigidbody ald d'un rigidbody par viewz
======> modifier PhysicWorld2D::BeginContact : faire attention à l'impact sur les elements de plateform tel que les cheminée, table etc... dont le rigidbody a un GetColliderInfo=(void*)1
======> il faut mettre dans les CollisionShapes les ViewZ et les ColliderInfo
======> 05/08/2020 : premier resultat ok sur le test chateau ambulant ! à verifier si impact sur les entity et furniture ou player ou network
=======> 09/08/2020 OK : lors de la reimplantation de GameHelpers::AddTile(), GameHelpers::RemoveTile() tester si sur un ObjectMaped
========> 15/10/2020 OK : ObjectMaped utilise aussi MapBase::SetFurnitures et World2D::DestroyFurnituresAt()
======> Certains problemes de collision entre les wallground de l'ObjectMaped et Avatar : l'Avatar passe à travers le mur
=======> 09/08/2020 OK : le RigidBody du ObjectMaped qui est un BT_DYNAMIC n'a pas la simulation complete de Box2D => forcer en le mettant en Bullet
======> Probleme pas d'affichage des RenderShape sur l'ObjectMaped
=======> 01/09/2020 : Modification de ObjectMaped::OnSetEnabled() pour permettre activer les nodes des RenderShapes
========> OK : les RenderShape ne sont pas prévu à l'origine pour se déplacer (tout comme ObjectTiled), ajout dans RenderShape::OnSetEnabled() de node_->AddListener(this) si l'attribut Dynamic est true, ajout de OnMarkedDirty()
=========> OK : lorsque les RenderShape sont déplacer, les Textures UV ne suivent pas les vertices, modification de RenderShape::UpdateFrameVertices(), il fallait utiliser la position local (cad celle de triangles) et non pas celle du world.
======> Voir pour simplifier l'update du render lors du ObjectTiled::OnWorldBoundingBoxUpdate en mode dynamic. il faut simplement recalculer le positionnement dans les batches
=======> 10/08/2020 OK : ajout de BatchInfo::UpdateVerticePositions et modif de ObjectTiled::OnWorldBoundingBoxUpdate(), ObjectTiled::UpdateTiledBatches ... utilisable seulement si USE_CHUNKBATCH désativé.
======> Modification de GameHelpers::ApplyLuminosity() pour permettre au furnitures des ObjectMaped de bien appliquer les couleurs
======> la collision entre ObjectMaped et Map ne produit pas de GroundContact dans GOC_Collide2D.
=======> 10/08/2020 OK : Modification de GOC_Collide2D::HandleBeginContact() pour inverser la normaly s'il s'agit de 2 Walls (shapes qui ont un ColliderInfo) et qu'il y a un swap de body realisé.
==> RAF : Creer une fonction Map::SetTiles(MapFeatureType feature, const IntRect& rect) permettant de modifier toute une zone rectangulaire dans une map
==> Centraliser toutes les fonctions communes dans MapBase
==> 11/08/2020 : Creer le systeme de serialization des features : permettra de faire des object custom
===> sera egalement utile pour les MAP générées par AnlWorldModel et modifier par les joueurs lorsque le taux de tilemodifier dépasse un certain montant, il sera peut-etre mieux de sauvegarder les ObjectFeatured en custommap
===> permettre le choix entre sauvegarde light (tilemodifier) ou complete (layer)
===> pour gerer la serialization des ObjectMaped dans le meme systeme, il faut trouver une astuce pour le systeme de reference ShortIntVector2
====> utiliser par exemple la plage y=-32767, les x donneront les idd des objectmaped.
====> ObjectMaped est un component => ajouter attribut "MapData" pointant sur Resource MapData à créer.
=====> Pour créer MapData s'appuyer sur des Resource tel que TileMapFile et AnimationSet2D, deplacer les fonctions MapStorage::LoadTileModifiers(), MapStorage::LoadEntities() et Save dans MapBase ou Map
=====> Utiliser la Compression d'Urho3D utilisé pour les ObjectControl par exemple cf Connection::ProcessReceiveObjectControls(int msgID, MemoryBuffer& msg)
=====> Commencer par ajouter simplement à MapBase les fonction Load et Save
=====> voir pour utiliser ResourceCache::BackgroundLoadResource pour chargement en Thread
===> Refactoring du systeme de Serialization des Maps
====> MapData est le container des données mémoires à conserver et serializer => remplacer dans Map/MapBase toutes les données Spot/Furniture/Entity par la struct MapData.
=====> Seules les FeatureViews sont laissées dans l'ObjectFeatured de MapBase. MapData gardant seulement des pointeurs sur chaque view.
====> Ajout de MapSerializer qui reprend en partie Urho3D::BackgroundLoader et y ajoute la serialization asynchrone (load et save) des MapData
====> pour la sauvegarde il faut creer une copie integrale du MapData pour eviter la modification de ces données durant la sauvegarde.
=====> la Section Entity qui est un Vector de WorldEntityInfo doit être mise à jour avant sauvegarde avec les données de World2D
====> Finir l'intégration dans MapCreator : générer les Feature, Spot, Entity, EntityAttr, Furniture (MapSerializer défini cet état) si l'état MapData::mapDataSetted_[] est faux.
=====> 22/08/2020 : serialization fonctionnelle sans crash avec l'option pour forcer la sauvegarde des featuresmaps+biomemap+terrainmap pour les Map (GameStatus::allMapsPrefab_)
=====> 27/08/2020 : correctif MapStorage::UnloadMapAt et dans AnlWorldModel::GenerateModuleThread
======> utilisation de Urho3D::WorkQueue (MODULETHREAD_VERSION == 2) car l'implementation avec pthread en direct ne permet pas l'utilisation des Thread d'Urho3D (collision dans les threads ?)
====> voir pour la serialization des ObjectMaped (voir le MapStorage)
=====> OK : déplacer MapStorage::SaveMapData() et MapStorage::LoadMapData() dans MapSerializer
=====> OK : rendre indépendant MapSerializer::FinishSerializingMapDatas() : le transformer en handle sur BeginFrame
=====> OK : déplacer MapStorage::UpdateMapData() et MapStorage::UpdateMapData_EntitiesAttributes() dans MapBase::UpdateMapData et dans Map::OnMapDataUpdate()
======> ObjectMaped::HandleSet remplace ObjectMaped::Set et permet le setting en async comme pour Map
======> ObjectMaped doit creer les objets ObjectFeatured, ObjectSkinned, ObjectTiled avant le ObjectMaped::Resize() pour permettre le stockage des Features lors du MapSerializer::LoadMapData()
======> Ajout de GameHelpers::CreateObjectMapedFrom(int dataid)
=======> MapData doit pouvoir maintenir en memoire les featuredMap dans le cas des Prefab, pour permettre le deversement sans appel à MapSerializer.
========> OK 31/08/2020 : ajout de MapData::prefabMaps_
=====> OK : suite aux modifications => pb les portes ne sont plus générées => le DungeonInfo::doorIndexes_ n'est plus rempli => correctif dans MapCreator::CreateMap() => une erreur dans le passage des parametre à ObjectFeatured::SetViewConfiguration().
=====> OK 01/09/2020 : les ObjectMaped seront desormais sauvegardés dans le dossier Custom pour permettre leur acces à l'ensemble des mondes
=====> Premier Test Ok en CREATEFROMGENERATOR => il faut maintenant pouvoir indiquer le anlworldmodel ainsi que le AnlMappingRange à MapGeneratorWorld.
======> tout se passe dans MapGeneratorStatus, premier test dans GameCommands anltest avec Levels/anlworldVM-asteroid1.xml
=======> modification de AnlWorldModel::SetSeedAllModules() pour rendre le changement de seed fonctionnel en version model VM. le fichier model devra avoir un premier module Seed nommé seed.
==> modifier MapCreator et ObjectFeatured::SetViewConfiguration ainsi que l'utilisation des viewId InnerView_ViewId, FrontView_ViewId etc... pour permettre la simplification du nombre de views.
===> remplacer tout les occurences de InnerView_ViewId, FrontView_ViewId etc... par une fonction Get utilisant les LinkViewIdViewZ utilisés dans ObjectFeatured::SetViewConfiguration()
====> difficile à réaliser étant donnée la structure ObjectFeatured::viewZ_[viewid]
=====> OK : Patch de ObjectFeatured::GetViewIDs(viewz) qui permet d'obtenir la liste des viewids pour un viewZ n'etant pas enregistrer (tel que le Frontview pour le modele Asteroid qui n'utilise que l'innerview et l'outerview
===> modifier ObjectTiled::Resize(), ObjectMaped::Resize() pour y integrer le nombre de views dependant du modeltype appliquer dans ObjectFeatured::SetViewConfiguration()
====> le modele asteroid n'a besoin uniquement que de 2 views (innerview et outerview)
====> modifier MapColliderGenerator en BorderMode pour bien faire le tour avec les collisionBox
=====> OK : dans MapColliderGenerator::GenerateWorkMatrix, test du voisinage d'une feature block : si elle n'a pas 4 voisins il ne s'agit pas d'un block interne donc à garder dans en BorderMode
=> OK 11/09/2020 : ne pas permettre la serialization des entités en mode Arena
=> Pb en World, la sauvegarde des entities n'est pas correcte. Verifier l'instant de sauvegarde en memoire puis la serialization.
==> correctif dans MapStorage::UnloadMapAt() : le code pour le check de l'état minimal en Available de la map à décharger était mal placé
=> Pb dans la generation des colliders lors du chargement/generation simultané d'une Map et d'un ObjectMaped (utilisation des memes datas MapColliderGenerator::blockMap_ etc... ce qui crache si width_ et height_ differentes)
==> OK 14/09/2020 : ajout de MapColliderGenerator::ResetMapGeneration(MapBase*) à utiliser lors du déchargement d'une map : MapColliderGenerator sauvegarde la reference de la map qui est en cours de génération sous MapColliderGenerator::map_.
        toutes demandes de génération tant que map_ n'est pas reseté sont refusées.
=> il faut tester si l'ObjectMaped est à l'interieur d'une mapbase => si à l'interieur alors ses colliders ne doivent pouvoir entrer en contact avec les entités exterieures
==> lors du changement de viewz vers INNERVIEW, verifier si l'ObjectMaped est masqué par une Map. si c'est le cas, desactiver les CollisionChains
===> OK 18/09/2020 : ajout de MapBase::IsMasked(), ObjectMaped::GetRectIn(MapBase* map), et modification ObjectMaped::ChangeViewZ()
=> l'update des colliders lors d'un SetTile ne semble pas fonctionner pour ASTEROID.
==> voir MapBase::SetTile() pour trouver le pb avec les CollisionChains
===> le code ne permet pas d'avoir plusieurs colliders pour une meme vue
====> OK : il faut obtenir les Colliders selon le type Physic ou Render demandé et pour le couple IndZ, IndV => modifier GetPhysicCollider(int indv) en GetColliders(int type, int indv), ce qui permet d'avoir plusieurs colliders pour une view.
===> l'update d'une collisionShape en x,y en BackMode ou en TopBorderBackMode ne permet pas la generation des colliders pour le BLOCK du dessous si il existe
====> OK : Correctif dans MapColliderGenerator::GenerateWorkMatrix()
===> MapBase::SetTile sur une tile innerview/outerview/backview sans tile background ne permet pas l'update des colliders
====> OK : Modification des views impactées dans MapBase::SetTile
==> implementer l'update des CollisionBoxes.
===> 20/09/2020 OK : creation de MapBase::UpdateCollisionBox(), modification de PhysicCollider::blocks_ devient un HashMap.
=> la generation d'ASTEROID peut produire des FeaturedMap vides !
==> OK 20/09/2020 : La taille mimimale de generation doit etre 3. (et non 2)
=> l'update des collisionbox doit tenir compte du mode de generation MapColliderMode notamment du mode BorderMode (Asteroid Box)
==> OK 21/09/2020 : modifier MapBase::UpdateCollisionBox()
=> lors du switch viewZ, il faut prendre aussi en compte si le player est sur un ObjectMaped
==> OK 21/09/2020 : modification de GOC_Destroyer::IsOnFreeTiles() et GameHelpers::CheckFreeTilesAtViewZ()
=> en innerview pour l'asteroid, le layer des tiles (LAYER_OBJECTMAPED) chevauche celui des acteurs
==> OK 21/09/2020 : nouvelle modification des valeurs des layers cf. DefsViews.h solutionne aussi la pluie avec les Decals en outerview.
==> OK 21/09/2020 : le changement des layers a modifié la generation des Dungeons. Il s'agit du parametrage dans Arena.xml et autres pour les dungeons => mettre les z à 40
=> le chargement des furnitures n'est pas correcte si des modifications de tiles ont été réalisées.
==> voir la sauvegarde des furnitures
===> cf Map::OnUpdateMapData(), MapData::furnitures_ n'est pas mis à jour lorsqu'une furniture est supprimée par un removetile (ou autre) cf GameHelpers::RemoveTile
====> pour les Map utilisation de World2D::DestroyFurnituresAt()
====> pour les ObjectMaped utilisation de MapBase::RemoveFurnitures() qui reste à implémenter.
=====> sol1 (utilisez le define MAPDATA_SAVEFURNITURELIKEENTITIES) : sauvegarder les furnitures avec les MapData::entitiesAttributes_. La map loaded ne devra pas générer de nouvelles furnitures mais chargées celles sauvegardées.
======> modification de Map::OnUpdateMapData() et MapData::Save() pour permettre la serialization dans MapData::entitiesAttributes_ (ne jamais sauvegarder MapData::furnitures_ qui devient caduque)
=======> pb1 : les entités Portal ne s'affichent pas correctement.
=======> pb2 : toutes furnitures n'apparaissent pas sur les maps precedemment decharger => voir le SaveWorld ?
========> OK patch dans MapStorage::UnloadMapAt()
=======> pb3 : les furnitures tardent à s'afficher à l'approche en bordure de vision
========> OK 25/09/2020 : dans AnimatedSprite2D patch lors de AnimatedSprite2D::UpdateAnimation(0.f) utiliser pendant AnimatedSprite2D::OnSetEnabled(), recalcul de drawRect_
=====> sol2 : modifier World2D::mapFurnitures_ pour y integrer une reference à chaque MapFurniture de MapData::furnitures_ pour permettre une modification facile en cas de Remove Furniture
======> pb pour les DynamicFurnitures : n'étant pas static, elles ne peuvent être détruites par World2D::DestroyFurnituresAt(). Alors qu'elles figurent dans MapData::furnitures_ à la génération, si elles bougent (dynamic)
     ou bien si elles sont detruites leur entrée dans MapData::furnitures_ ne sera pas mise à jour ou supprimée. Par conséquent dans ces cas, la sauvegarde sera erronée. Ex: Portal.
=======> RAF : modifier Map::OnUpdateMapData() pour mettre à jour MapData::furnitures_
=> RAF : certaines entities et furnitures tel que rockgolem et feudecamp ne sont pas bien sauvegarder en memoire car ont des nodes fils qui ne sont pas pris en compte par GameHelpers::SaveNodeAttributes()
==> modifier GameHelpers::SaveNodeAttributes() et GameHelpers::LoadNodeAttributes() pour prendre en compte les nodes fils non temporaire
==> ou bien utiliser Node::Save et Node::Load et remplacer les NodeAttributes par Serializer
===> grosse modif : MapData::Load, MapData::Save, Map::OnUpdateMapData, ObjectPool::CreateChildIn, remplacer toutes les occurences de NodeAttributes par MemoryBuffer ou VectorBuffer ?
=> RAF la serialization avant la teleportation n'a pas l'air ok.
=> pouvoir generer des ObjectMaped non fixe en rotation.
==> 29/09/2020 : ajout de parametre rotation dans MapBase::SetPhysicProperties() et MapModel::colliderBodyRotate_
===> pour que cela fonctionne bien il faut revoir Urho3D::PhysicsWorld2D::BeginContact() => OK conversion des point locaux en world point pour tester si le contact est bien à l'exterieur de la shape.
====> RAF : prendre en compte les holes (dans ce cas test si le contact est bien à l'interieur de la shape)
===> RAF : MapBase::IsMasked() et MapBase::GetRectIn() sont à modifier pour etre compatible avec la rotation
=> pouvoir generer des ObjectMaped sans Colliders (exemple asteroid en render uniquement, déplacement sans physic (comme static))
==> 29/09/2020 : ajout de ObjectMaped::SetPhysicEnabled()
=> faire un test de generation de plusieurs asteroids et les bombarder sur la scene
==> modifier les ObjectMaped pour differencier les Id des Object avec Physics et les autres.
===> 04/10/2020 OK : Les Object Physics ont des id pouvant aller de 1 à MAX_PHYSICOBJECTMAPEDS et sont enregistrés dans le tableau static physicObjects_.
===> Les Object Non Physics ont des ids à partir de MAX_PHYSICOBJECTMAPEDS. ces Ids servent pour le Layering et pour la serialization. Encore des pbs avec la superposition de ces objects dans certains cas avec les DECALS
===> Les Object Non Physics generes ne sont pas serializés et ne changeront pas de viewZ. cf ObjectMaped::CreateFrom.
==> creer des asteroids sans collider en background, les faire se déplacer du haut de la zone visible vers le bas en diagonale. des qu'en bas et non visible les remettre en haut en changeant la position initiale et scale.
===> 05/10/2020 Test OK
=> Les Maps sont uniquement chargées la première fois en memoire si disponible puis sauvegarder en fin de jeu cf MapStorage::InitializeMap() et MapStorage::UnloadMapAt() et MapStorage::SaveMaps()
==> OK : mis en Define MAPSTORAGE_ONLYSERIALIZEATSTARTANDEND
=> creer un MapModel pour les chateaux ambulant.
==> OK 07/10/2020 : Backview, InnerView, Outerview, utilisation du MapGeneratorDungeon, creation du collider INNERVIEW en SHT_BOX pour gerer le Dynamic
===> Il manque les colliders des plateformes : modification de MapColliderGenerator, ajout de struct Plateform et PhysicCollider::plateforms_ devient un HashMap
====> Ajout de MapBase::UpdatePlateformBoxes(), modification de MapBase::SetTile pour mettre à jour la carte Features lors de l'ajout/suppression de RoomPlateForm
====> Crash à corriger surement dans MapBase::UpdatePlateformBoxes() lors de l'ajout à proximité à gauche d'une plateforme après avoir supprimer déjà une fois un RoomPlateform
=====> 14/10/2020 : Ne pas effacer systematiquement PhysicCollider::plateforms_ dans MapColliderGenerator::GeneratePhysicCollider() : ajout du parametre bool createPlateform.
==> pouvoir ajouter un moyen de déplacement (roues / reacteurs ...)
===> OK 10/10/2020 : ajout de virtual MapBase ObjectMaped::OnPhysicsSetted() - 2 roues aux extremités basses en mode rotation. le centre de gravité est au milieu des 2 roues et modification de l'inertie pour eviter crash Box2D.
====> ajout des Drawables pour les roues, reglage du modele avec deux choix possibles avec resorts ou sans (cf. ObjectMaped::OnPhysicsSetted() et ObjectMaped::CreateWheel)
====> RAF : voir pour créer des propulseurs, des pattes mécaniques permettant de gagner en stabilite/deplacement sur les reliefs.
=> RAF : finir l'ajout des MapModel dans MapStorage::InitTable(), et modifier MapCreator::GenerateAsteroid() et autres fonctions generatrices pour utiliser MapModel
=> RAF : implémenter correctement ObjectMaped pour l'utilisation du mode CREATEFROMGENERATOR pour chaque type de modeles (dungeon,cave,asteroid)
=> il faudrait pouvoir reunir toutes les données spécifiques à chaque modèle dans la structure MapModel et réunir le code qui est disséminé
    cf ObjectFeatured::SetViewConfiguration(), ObjectMaped::CreateFrom(), ObjectMaped::HandleSet(), MapCreator::SetGenerator(), MapCreator::GenerateAsteroid(), DefsMap => NUMASTEROIDPHYSICCOLLIDERS, MapBase::SetColliderType() ...
=> ObjectMaped MobileCastle : probleme avec les Map si le donjon est haut et que le déplacement de la camera fait disparaitre les collider de la Map ou s'appuie le donjon : ecroulement du donjon.
=> ObjectMaped MobileCastle : mouvement sacadé des entities du à l'espace entre collisionBoxes
==> OK 12/10/2020 : diminution de la taille des collisionBoxes en InnerMode et réajout des CollisionShapes en INNERVIEW. les CollisionBoxes sont nécessaire pour les collisions ObjectMaped contre ObjectMaped
=> ObjectMaped MobileCastle : la creation des doors n'est pas possible : cf GameHelpers::RemoveTile(), MapBase::SetTile()
==> OK 15/10/2020 : pb corriger dans GameHelpers::RemoveTile()
=> ObjectMaped MobileCastle : probleme avec les furnitures qui ont un RigidBody Static (masse infinie) ou bien Dynamic (la masse du donjon doit etre alors beaucoup plus grande que celles des furnitures) et qui peuvent entrer en collision avec les murs : mise en orbite du donjon.
==> OK 11/10/2020 : mise en dynamic des furnitures (pour eviter la masse infinie des objets Static et tout risque de "satellisation" du donjon)
    et correctif du centre de la collisionbox de sol pour les furniture tel que enclume, marmite, table, cheminee pour l'utilisation en innermode SHT_CHAIN du collider INNERVIEW du donjon
===> ancrer physiquement les furnitures qui ont un rigidbody dynamic et qui ont la propriété GOTypeProperties::GOT_Static au tile lié
====> lors du RemoveTile il faudra supprimer l'ancrage.
===> on veut que certaines furnitures soient accrochees et libres en rotation.
====> les tentures avec un seul rigidbody c'est impossible. la tringle doit etre fixe, le rideau accroche à la tringle et libre en rotation pour la partie basse => StretchableSprite2D piloté par 1 RigidBody pour la partie basse accroché avec 2 ContraintRope2D ?
====> les tables, les armoires, les marmites doivent pouvoir glisser sur le sol (donc dynamic) et libre en rotation.
=====> OK : ces furnitures n'ont pas de tile support, ce sont des entités comme les autres en RigidBody Type Dynamic.
====> les cheminées, les enclumes, les sanctuaires, les portails doivent etre ancrés au sol et pouvoir suivre le mouvement de rotation du chateau ambulant.
=====> OK : furnitures à tagger GOT_Static et mise en RigidBody Type Static (faire tres attention que les CollisionShapes de la furniture ne puissent entrer pas dans les Walls, au moment du pop). Essai concluant avec les Cheminées
=====> OK : Pb de visibilité des furnitures des ObjectMaped => correctif dans MapBase::SetFurnitures() et GOC_Destroyer::OnWorldEntityCreate() => specifier eventData[Go_Appear::GO_MAP] pour eviter que World2D::HandleObjectAppear
    ne l'enregistre dans World2D::mapEntities_ sur un mauvais mPoint (celui de GOC_Destroyer n'est pas le bon)
====> à l'utilisation de Urho3D::RigidBody2D::SetFixedRotation(false), RigidBody2D::SetUseFixtureMass(false) et RigidBody2D::SetMassCenter() il y a crash
=====> il faut alors spécifier une Inertie qui soit compatible avec b2Assert(m_I > 0.0f) avec (m_I = massData->I - m_mass * b2Dot(massData->center, massData->center) dans b2Body::SetMassData
=====> 22/10/2020 : dans Urho3D::RigidBody2D ajout de Urho3D::RigidBody2D::SanitateInertia() qui resoud le pb.
=====> Pas de destruction de furnitures hormis les portes : cf GameHelpers::RemoveTile(), World2D::DestroyFurnituresAt
======> OK 26/10/2020 : modification de World2D::DestroyFurnituresAt, suppression de CC_FURNITURE au profit de CC_INSIDESTATICFURNITURE et CC_OUTSIDESTATICFURNITURE, modification de GOC_Destroyer::UpdateFilterBits()
=====> Pb de creation des portes lorsque le chateau est incliné
======> OK 26/10/2020 : Correctif de MapBase::GetWorldPosition() : utilisation Node::GetWorldTransform2D() pour prendre en compte la rotation
=> Test de l'ObjectMaped à l'interieur dans Dungeon.
==> OK 28/10/2020 : en ViewZ=INNERVIEW pb de layer pour le Backview de l'ObjectMaped et les wheels (non visibles) => mettre en BACKVIEW+1
==> OK 28/10/2020 : en ViewZ=FRONTVIEW pb de layer pour les wheels (visible) => mettre en OUTERVIEW-1
==> interdire le changement de ViewZ vers FRONTVIEW pour les portes d'un ObjectMaped interne à un dungeon.
===> 28/10/2020 : modification de GOC_Destroyer::UpdatePositions()
====> OK 29/10/2020 : nouveau correctif de GOC_Destroyer::UpdatePositions() qui permet désormais de changer de ViewZ en empruntant un chemin vertical (jusqu'à présent ct une lacune). on peut désormais sortir de caverne par les conduits de "cheminee".
=====> il n'est normalement plus nécessaire de générer des MapfeatureType::Door qui posent probleme avec les TileModifier

=> 03/10/2021 : suite à modification ObjectTiled, RenderShape etc... les ObjectMaped ne s'affichent plus :
==> il doit y avoir un probleme de creation des informations viewportDatas_ d'ObjectTiled pour ObjectMaped notamment ObjectTiled::ViewportRenderData::currentViewZindex_ qui vaut -1 dans ObjectTiled::UpdateSourceBatchesToRender()
===> dans ObjectTiled::SetCurrentViewZ() currentViewZindex_ est lancé à -1., verifier pourquoi, il est seulement setté dans ObjectTiled::GetWorldBoundingBox2D()
====> OK correctif dans ObjectTiled::GetWorldBoundingBox2D() car un ObjectMaped n'est pas forcement chunked.
=> OK 03/10/2021 : probleme avec GOC_Destroyer et le Unstuck => ajout de GOC_Destroyer::SetEnableUnstuck() pour permettre la desactivation de l'Unstuck dans le cas des MobileCastle.
=> OK 03/10/2021 : probleme avec les colliders : les filters ne sont pas les bons => ne pas permettre GOC_Destroyer::UpdateFilterBits(), et les Wheels ne peuvent plus utiliser CM_INSIDEEFFECT (qui n'entre plus en collision avec les walls).

=> 11/04/2022 : suite aux modifications dans MapBase::GetBlockPositionAt(), le positionnement des wheels n'est plus bon.
==> la logique est modifié. il faut se positionner en bas cad à GetHeight()-1 et aller vers le haut UpDir.
===> OK Correctif dans MapBase::GetBlockPositionAt() et ObjectMaped::OnPhysicsSetted()
==> les RenderShapes ne sont pas affichés correctement après changement en INNERVIEW
===> OK Correctif dans ViewManager::SwitchToViewIndex -> GameHelpers::UpdateLayering -> GameHelpers::SetDrawableLayerView pour eviter le changement des layers des rendershapes.

 </ObjectMaped>

=> 26/09/2020 : Si changement de resolution d'écran, ou redimensionnement de la fenetre, apres teleportation via GOC_Portal il y a un zoom de camera apres la teleportation par GOC_Portal.

- 26/07/2020 : pouvoir ajouter des lumieres/torches
=> gestion de l'enlightement : calcul de la zone à éclairer et ajout de la light adéquate (rayon ...)

- 08/04/2020 : pouvoir interagir avec certaines furnitures (ex : les tentures pour les tirer et voir ce qu'il y a derriere... ou bien ouvrir les portes des armoires et decouvrir des items)
=> utiliser GOC_EntityAdder avec condition d'activation (animation "opened" par exemple).
=> utiliser GOC_Inventory pour pouvoir collecter les items ?
=> ajouter GOC_Animator2D et voir pour detecter le clic sur l'armoire (cf l'UI du marchand ?)
==> Ajout du collisionBox Trigger + Modification Player::HandleClic()
==> Ajout de l'animator template AnimatorTemplate_InteractiveFurniture dans PreLoader.xml
===> 10/04/2020 : modification de GOC_Animator2D_Template::ApplyEventToStates() permettant l'ajout d'un meme event à deux states dont les nexstates sont differents
    cf PreLoader.xml template AnimatorTemplate_InteractiveFurniture Event Go_TrigClicked

- 11/02/2020 : Crash apres avoir supprimer des blocks en INNERVIEW pour remonter en surface,
 puis en surface l'acces ne permet pas de rebasculer automatiquement en FRONTVIEW,
 basculement en manuel, puis essai de creation d'un acces sur le block FRONTVIEW de cette sortie non visible => crash
LOG :
[Tue Feb 11 23:04:46 2020] INFO: Map() - SetTile feat=NoMapFeature(0) x=32 y=29 z=44(viewid=0) tileindex=1888 mPoint=6 19
[Tue Feb 11 23:04:46 2020] INFO: Map() - SetTile ... before filters feat=NoMapFeature(0)
[Tue Feb 11 23:04:46 2020] INFO: ObjectFeatured() - ApplyFeatureFilters : COPYTILEMODIFIER ... addr=1888 feat=0 to 0 on viewId=0 to viewId=1 ... OK !
[Tue Feb 11 23:04:46 2020] INFO: Map() - SetTile ... after filters feat=NoMapFeature(0)
[Tue Feb 11 23:04:46 2020] INFO: Map() - SetTile : TileModifier Added => TileModifiers (NoMapFeature(0) 32 29 44) Size=19 !
[Tue Feb 11 23:04:46 2020] INFO: Map() - SetTile : Update ObjectSkinned : x=32 y=29 ...
[Tue Feb 11 23:04:46 2020] INFO: ObjectSkinned() - SetTileFromTerrain mode=Connected0 x=32 y=29 viewid=0 feat=NoMapFeature(0) maxdim=10
[Tue Feb 11 23:04:46 2020] INFO: ObjectSkinned() - SetTileFromTerrain mode=Connected0 x=32 y=29 viewid=1 feat=NoMapFeature(0) maxdim=10
[Tue Feb 11 23:04:46 2020] INFO: ObjectSkinned() - SetTileFromTerrain mode=Connected0 x=32 y=29 viewid=2 feat=OuterFloor(14) maxdim=10
[Tue Feb 11 23:04:46 2020] INFO: Map() - UpdatePhysicCollider : update collider i=2 x=32 y=29 ...
[Tue Feb 11 23:04:46 2020] INFO: MapColliderGenerator() - GeneratePhysicCollider ... viewZ=44 indz=1 indv=2 viewid=0 colliderZ=44(44) colliderMode=FrontMode=0 shapeType=SHT_CHAIN=2
[Tue Feb 11 23:04:46 2020] INFO: Map() - UpdateCollisionChain ...
[Tue Feb 11 23:04:46 2020] WARNING: Map() - UpdateCollisionChain : mPoint=6 19 sLastContourId_=A > chains size(1)
[Tue Feb 11 23:04:46 2020] INFO: Map() - UpdateCollisionChain : mPoint=6 19 sLastContourId_=A cs=437240048 SendEvent MAPTILEREMOVED at 1888 ...
[Tue Feb 11 23:04:46 2020] INFO: Map() - UpdateCollisionChain : Contours Updated ...
[Tue Feb 11 23:04:46 2020] INFO: Map() - UpdateCollisionChain : Holes Updated ... OK ! => CRASH

- 27/01/2020 : voir pourquoi MapTerrain::GetRandomTileGidForConnectIndex() est appelé dans les cas ou ConnectIndex=MapTilesConnectType::Void
-> en attendant de remonter à la cause, ajout d'un skip de si connectindex=Void

- 17/01/2020 : les donjons en surface doivent avoir leurs propres types de materiaux : differents pavements
-> utilisation de MapSkin deja realisée
--> pour le moment utilisation d'un random skin cf MapCreator::GenerateDungeonMap()

- 14/01/2020 : Modifier les Decals de bordure et les Tiles de Background en fonction des Biomes (penser à la vegetation).

- 13/01/2020 : decalage des layers de +4 DefsViews.h afin d'avoir plus de place entre le BACKGROUND et les BACKBIOME (pb furnitures arbres en chevauchement avec tiles de background)
=> ainsi les layerZ classique changent (BACKGROUND:6=>10 INNERVIEW:20=>24 FRONTVIEW:40=>44)
==> possibilité d'avoir des vegetations en avant plan dans l'innerview grace à (FRONTBIOME) à implementer dans MapGenerator::GenerateBiomeFurnitures()

- Créer une BiomeMap (carte des biomes : Rainforest, Grasslands, Desert, Temperate Forest, Tundra, Taiga, Polar, Chaparral)
-> elle agira notamment en modificateur sur la TerrainMap pour la selection du materiaux sur une tile
--> revoir SkinData => HashMap(FeatureType , MapTerrain*) devient HashMap(FeatureType, unsigned) unsigned étant index sur un tableau des Materiaux
==> pour generer la biomemap, utiliser la worldmap pour identifier les differentes zones (montagneuses, plaines, sous-sol)
===> 10/01/2020 : pour le moment la biomemap est un simplefbm ce qui pourrait etre suffisant
====> voir pour la correspondance des valeurs de la biomeMap
=====> voir pour creer une TemperatureMap et une HumidityMap pour générer les biomes.

- 10/11/2017 : finir l'ajout des furnitures (s'appuyant sur BiomeMap à créer)
-> seules les furnitures des Chunks Visible doivent s'afficher ce qui n'est pas le cas pour Portal pour le moment
=> mais dans ce cas comment gérer les chunks non visible dont les furnitures dépassent
==> ne pas le gérer dans les chunks mais plutôt dans le visibleRect_ de World2D
===> toutes les furnitures qui ne sont pas à l'intérieur du visibleRect sont désactivés
===> voire comment implanter la logique (voir World2D::SetEntitiesVisible() ?
====> peut-etre faut-il les considerer comme des entités mais avec un flag static ?
====> de plus si destruction de terrain que faire de ces furnitures => deja probleme avec les portal
====> remplacer par du dynamic avec un poids important => oui + nouveau categoryBits/MaskBits GO_Furniture
=====> simplement enlever le mur et laisser tomber la furniture ? ou bien detruire la furniture accrochée ?
=====> comment lier une furniture à un mur sans qu'elle ne tombe par gravité (plante grimpante par exemple) le pb ne se posant pas pour portal puisque sur le sol.
=====> 2 familles de furnitures : les StaticFurniture et les DynamicFurniture
======> les StaticFurniture ont un rigidbody static et ont une ref vers une tile. Si cette tile est detruite alors la StaticFurniture aussi (plante grimpante)
======> les DynamicFurniture ont un rigidbody dynamic et n'ont pas de ref à une tile. (portal)
======> les 2 familles ne peuvent pas être touchée par les autres entités autre que des murs, leurs triggers peuvent déclenchés une interaction avec les autres entities néanmoins
======> de ces familles découle des catégories liées à la biomemap, au type de générateur (dungeon, world), ou bien aux quetes (portal, sanctuaire)
-> voir pour le layering (cf GOC_Destroyer::SetViewZ et GOA::LAYERALIGNMENT)
=> 13/04/2018 : systeme de vegetation en cours ... premier resultat ok
==> trop de furnitures générées en scene solo
===> réduction du pourcentage de spawn dans les directions left/right/bottom ?
=> 14/01/2020 : les StaticFurnitures n'ont plus besoin de RigidBody suite aux modifications et ajout World2D::AddStaticFurniture()
==> pour la gestion des map visibility, il faut dissocier furnitures et entities : pour le moment les furnitures sont aussi des ENTITIES
    if faut egalement dissocier l'affichage des Tiles de celui des Entities/Furnitures afin de ne pas avoir l'affichage des tiles bloqués par celui de l'affichage des entities d'une autre map

- 15/09/2018 : ajouter dans MapGeneratorDungeon des templates de tours, chateaux parametrables

- 03/08/2017 : Possibilité de créer des Custom Maps (via Editor Intégré ?) intéressant pour les lieux particuliers comme les boss zones
-> cf. EDITOR

- 25/04/2018 : ajouter des portes (furnitures de dungeon). Clé, vérouillage ...
=> le 12/09/2018 : ajout de la porte01. Le vérouillage sera effectué par une CollisionBox en static
==> RAF : codage du verrou + object "clé"

- Créer une TerrainMap (carte des terrain : argile, terre, sable, pierre)
-> l'altitude modifie le type de terrain :
--> en forte profondeur : 80% pierre et 20% argile;
--> en surface faible altitude (lit mer, riviere) : 50% sable, 35% pierre, 15% argile;
--> en surface moyenne altitude (plaine): 50% terre, 25% argile, 15% pierre, 10% sable;
--> en surface forte altitude (montagne) : 70% pierre, 20% terre, 10% sable;
       - l'eau (le terrain modifie la presence d'eau : argile et pierre créent des bassins, le sable et la terre filtre l'eau, la pierre crée des infiltrations moins importante),
       - la temperature de l'air (les reliefs, les caves, la concentration d'eau modifient le climat donc la BiomeMap)
==> 06/02/2018 : à réaliser en priorité, ainsi que les furnitures ci-après.
-> voire avec le worldgenerator si possibilité de reprendre les cartes intermédiaires pour générer une terrainMap;
==> 17/03/2018 : terrainMap générée avec le worldGenerator (simple fbm) ou bien par default avec MapGenerator::GenerateDefaultTerrainMap()
===> dans le cas où l'on utilise un backscroller opaque les batches des tiles et decals sur le layer du backscroller ne sont pas nécessaires

- Créer une PopulationMap
--> permet de placer les habitations et donjons
--> comment gérer la diversité des espèces par région ?
---> suivants les biomes et terrain, altitude, profondeur et milieu (eau, air, terrain)

- 24/08/2018 : Les TileModifiers ne sont pas sauvegarder
=> Correctif appliqué dans Map::SaveTileModifiersTo() :
==> Attention : le Counter MAP_FUNC1 est utilisé, donc il doit être initialisé à 0 au debut de la sauvegarde.
===> OK !
==> Finir de mettre Asynchrone le code appelé par World2D::SaveWorld()

- 13/06/2018 : voir Box2D pour recentrer les coordonnées dans le cadre d'un monde infini (donc pb sur les float).

- 25/04/2018 : lors de la génération des Spots en dungeon, certains spots se trouvent en exterieur.
=> bien vérifier que ceux-ci soient bien à l'intérieur des murs du dungeon.

*/

/* DONE
------

- OK 17/01/2023 : amelioration de World2D dans la gestion de la visibilité => evite d'avoir visibleAreaMap trop importante qui ralentissait l'application en cas de dezoom (dynamic zoom)

- 08/04/2020 : ajouter le lustre
=> 28/12/2022 : utilisation de GOC_PhysicsGrapin (à renommer ?)
==> OK : quelques modifications dans GOC_Animator2D et GOC_Destroyer.

- 09/12/2b022 : Correctif sur GOC_Destroyer::Unstuck()
=> 10/12/2022 : encore des pb notamment le drawable apparait figer loin du RigidBody qui est coincé dans un mur.
==> le Unstuck n'arrive pas à setter la position du body correctement.
===> 28/12/2022 OK : Correctif dans GOC_Destroyer::Unstuck() avec ajout de RigidBody2D::SetBodyPosition() qui permet de setter la position dans Box2D. Utilisation egalement dans GOC_Destroyer::SetWorldMapPosition().
====> Cela devrait regler les pbs : ce n'est pas sur. Risque de plantage si Box2D est en cours d'update.

- 10/12/2022 : modifier l'AI des entity pour pouvoir descendre des plateformes.
=> 27/12/2022 : c'est OK voir Behavior 20/12/2022

- 24/05/2022 : toujours de gros probleme avec portal pour la teleportation
=> lorsque la teleportation ne peut se faire et est annulée, l'avatar demeure invisible.
==> OK : GOC_Portal::HandleBeginContact() il manque un return;
=> lorsque la teleportation est reussie, à l'affichage de l'avatar les maps ne sont pas toujours toute chargées occasionnant des bloquages dans des murs
    ou bien affichage en FrontView alors que l'avatar est en innerview.
==> le probleme provient des attributs dMap_, dPosition_, dViewZ_ qui changent dans GOC_Portal::HandleTransferBodies juste après World2D::GoCameraToDestinationMap.
===> OK : utilisation d'une structure differente GOC_Portal::TeleportInfo.

- 18/05/2022 : les scrolling n'apparaissent pas après chargement d'une sauvegarde.
=> les World2DInfo::imageLayerResources_ ne sont pas settés : la sauvegarde de l'attribut dans World2D n'est pas fait !
==> OK ajout de "Map - Add ImageLayers" qui permet de gerer en StringVector.

- 17/05/2022 : la serialization du world laisse des borders bloquantes : il faut les mettre en temporary pour eviter leur sauvegarde.
=> OK : modification de World2D::UpdateVisibleCollideBorders() et World2D::Set()

- 17/05/2022 : correctif dans RenderShape::GetSegmentsOnMapBorder() pour supprimer un crash du à MapBase::GetFeatureViewAtZ()
=> GetViewId(viewZ) doit etre remplacer par une fonction renvoyant toujours une viewid valide : creer GetNearestViewId(viewZ)
=> OK !

- 11/05/2022 : serialization : bug de chargement de map vu en mode Arena apres avoir gagner dans le premier monde, changement de monde (aléatoire), sauvegarde.
=> verifier si la sauvegarde inclut bien tous les parametres du composant World2D et si lors du chargement ils sont bien settés.
==> OK : il s'agissait d'une desactivation de code dans GameHelpers::LoadSceneXML()

- 05/10/2021 : les entities ne sont pas restaurées dans les pools apres un unload map
=> cf Map::RemoveNodes => GOC_Destroyer::Destroy()
==> Modification de GOC_Destroyer::Destroy() pour un remove immediat grace à static TimerRemover::Remove()
==> il semble que les GOT Collectable ne soient pas toujours remis dans ObjectPool. Trouver ce qui pose probleme
===> Cela arrive lorsque des Entity sont spawnés dans une map qui est en cours d'Unloading
====> il faut bloquer le spawn dans une map en cours de purge.
====> premier verrou dans World2D::SpawnEntity()
=====> provient de GOC_Inventory::HandleDrop() => GOC_Collectable::DropSlotFrom()
======> GOC_Inventory::HandleDrop est provoqué par l'event GOC_LIFEDEAD envoyé par GOC_Destroyer::Destroy()
=======> dans l'ideal, il faudrait que GOC_Destroy n'envoit que l'event GO_DESTROY.
========>pour l'instant ajouter la var GOA::DESTROYING et tester dans GOC_Inventory::HandleDrop()
========> meme chose pour GOC_BodyExploder2D, GOC_BodyFaller2D et GOC_Collide2D, Actor::OnDead
========> 06/10/2021 OK !

- 05/10/2021 : il n'y a pas de rendershape en fond pour les map Dungeon
=> dans DefsMap.cpp => modification de la table dungeonRenderColliderParams[]
==> BackGround : { 1, 0, BACKGROUND, BACKGROUND, BackRenderMode, SHT_CHAIN, BACKGROUND_MASK, 0 }
===> 05/10/2021 : OK, il faut obligatoirement le mode BackRenderMode autrement cela ne fonctionnera pas.

- 03/10/2021 : les border rendershape ne sont pas toujours faite quand le mode est USE_TILERENDERING avec ACTIVE_RENDERSHAPE_EMBOSE
=> il faut pouvoir regenerer les border des rendershape à la connection d'une map avec une autre.
==> les bordures de map sont généré dans le batch EMBOSEBATCH. Il faut mettre dirty le batch EMBOSEBATCH.
===> 05/10/2021 : OK correctif dans Map::UpdateRenderShapeBorders()

- 04/10/2021 : Crash avec le Portal en world
=> OK : Patch dans World2D::SetKeepedVisibleMaps() -> ObjectTiled::SetRenderPaused() -> corrigé node = 0

- 27/04/2021 : Correctif pour la generation des holes des PhysicCollider et RenderCollider. Ceux-ci étaient en partie non générés dû à une erreur de definition des contourBorder dans MapColliderGenerator::TraceContours_MooreNeighbor().
=> OK !

- 10/03/2021 : ne pas permettre l'ajout des furnitures avec GOA::PLATEFORM sur le layer BACKGROUND car si une de ces furnitures est cachée, le collider est toujours utilisable. c'est le meme probleme avec ObjectMaped (chateau ambulant)
=> cf MapGenerator::GenerateBiomeFurnitures() avec BiomeExternalBack
==> OK : dans furnitures.json, ne jamais classifier ces furnitures dans les categories BiomeBackGround|BiomeBackGroundSides|BiomeBackGroundBottom

- 24/01/2021 : ObjectTiled() - UpdateSourceBatchesToRender occasionne les lags dans ArenaZone ou MapWorld
=> le profilage indique GetChunkBatchInfoBased.
==> les lags ne sont présents qu'en debug en version non CHUNKBATCH

- 28/09/2020 : encore des bloquages possibles de generation de map. Checker World2D::UpdateStep(), MapStorage::UpdateBufferedArea(), MapStorage::UpdateMapsInMemory()
=> 05/12/2020 : cas sur Android => affichage d'une map erronée (set visible) puis chargement de la bonne map => pb de state avec le SetVisible et le Unload ?
==> A tester apres les modification sur anlvm du 08/12/2020
===> 19/12/2020 : correctif dans World2D, ajout de World2D::OnMapVisibleChanged() qui remplace World2D::UpdateVisibleCollideBorders(). Ne prend en compte que les maps qui sont effectiveVisible pour la mise à jour du collideBorder.
====> RAF : a rendre Multiviews

- 08/12/2020 : problemes de generation sur l'ensemble des Maps.
=> vue sous linux en mode debug avec (MODULETHREAD_VERSION 2), le define ALTERNATE_COORDENTRY est donc actif.
=> les maps semblent etre tronquées de moitié en Y. La moitié haute mal générée et la partie basse non générée ... A revoir.
==> difficilement reproductible
=> 12/12/2020  : sous windows gcc release avec WorkerThreads avec MODULETHREAD_VERSION 2, la generation est incorrecte. GCC Win Rel => le define ALTERNATE_COORDENTRY est inactif.
==> 12/12/2020 : sous windows gcc release sans WorkerThreads avec MODULETHREAD_VERSION 2, la generation est incorrecte. GCC Win Rel => le define ALTERNATE_COORDENTRY est inactif.
==> 12/12/2020 : sous windows gcc release sans WorkerThreads avec MODULETHREAD_VERSION 1, la generation est correcte. GCC Win Rel => le define ALTERNATE_COORDENTRY est inactif.
==> 12/12/2020 : sous windows gcc release avec WorkerThreads avec MODULETHREAD_VERSION 1, la generation est correcte. GCC Win Rel => le define ALTERNATE_COORDENTRY est inactif.
===> en activant ALTERNATE_COORDENTRY (cf VM/vm.inl) avec gcc release MODULETHREAD_VERSION 2, il y a crash si lancement sans debogage. avec debogage pas de crash ... pb d'initialisation de variable ?
====> comme la carte est mal générée, le player ne trouve pas de place pour positionner l'avatar Player::UpdateComponents() => le GOC_Destroyer detruit l'avatar. ensuite Actor::avatar_=0 et crash dans Actor::ResetAvatar
=====> correctif dans Actor::ResetAvatar et dans PlayState::HandleInitialize
==> 12/12/2020 : sous windows vs sans WorkerThreads avec MODULETHREAD_VERSION 2, la generation est correcte. MSC_VER => le define ALTERNATE_COORDENTRY est actif.
==> 12/12/2020 : sous windows vs avec WorkerThreads avec MODULETHREAD_VERSION 2, la generation est correcte. MSC_VER => le define ALTERNATE_COORDENTRY est actif.
==> 12/12/2020 : sous windows vs sans WorkerThreads avec MODULETHREAD_VERSION 1, la generation est correcte. MSC_VER => le define ALTERNATE_COORDENTRY est actif.
==> 12/12/2020 : sous windows vs avec WorkerThreads avec MODULETHREAD_VERSION 1, la generation est correcte. MSC_VER => le define ALTERNATE_COORDENTRY est actif.
==> remettre les gamelogfilters MAPCREATE et WORLDUPDATE pour le moment.
===> OK 13/12/2020 : quelques modifications dans anlvm : notamment remplacement des std::containers par ceux d'Urho3D semblent avoir éliminer le probleme.
=====> OK 14/12/2020 : OK sur linux => suppression de ALTERNATE_COORDENTRY qui n'est plus necessaire

=> verifier le delay maxi async utilisé pour le chargement initial des maps
==> Utilisation de 3 fonctions d'acces globale TimeOver() à utiliser avant tout dans les Boucles, TimeOverMaximized() à utiliser en fin de block mcount pour finir la procedure courante si le delayUpdate donné est trop court pour continuer, et HalfTimeOver().
===> OK 26/09/2020 : TimeOverMaximized() permet de gagner en rapidité pour les phases de chargement dans le delayToUpdate est long et de plus fragmenter durant les pĥases de jeux.
====> le chargement async initial passe de 10sec à 4sec.

=> 26/09/2020 : probleme de non chargement/generation de maps surement lié au MapStorage.
==> OK 28/09/2020 : il s'agit surement d'un bloquage du à MapColliderGenerator. Desormais, lorsqu'une nouvelle map necessite la generation de collider,
    MapColliderGenerator deverouille la map qui bloque (reinitialisation local du MapCounter FUNC3 pour la map bloquante) et traite le collider de la nouvelle map
    Changement de code dans MapCreator::Update() avec ajout d'un Tri permettant de recuperer la map la plus proche de la camera (mapsToCreate_ devient un Vector ald List)

- 15/06/2020 : pb de NaN position genere par GOC_Destroyer::UpdatePositions() => GOC_Destroyer::GetUpdatedWorldPosition2D() avec certains parts générés en PrepareMode par GOC_BodyExploder2D
=> à l'Explosion : GOC_BodyExploder2D::SetExplodedNodesComponents() va utiliser la methode World2D::AttachEntityToMapNode() qui fait appel à Node::SetWorldTransform2D()
==> après analyser avant appel à cette derniere methode les valeurs de la transformation sont ok, apres appel les valeurs sont corrompues certaines fois et retourne NaN.
===> LOG ti=0.7 -0 15.5004 0 0.7 1.72724 tf=-nan nan 15.5004 -nan nan 1.72724 => m00_ m01_ et m10_ m11_ sont corrompus => il s'agit de la partie scale et rotation.
====> cf Node::SetWorldTransform2D() & Matrix2x3
=====> Modification de Matrix2x3::Rotation() qui utilise acos => ne permet pas le test des limites => utilisation de Urho3D::Acos() qui fait le Clamp aux limites
======> OK : plus d'erreur pour le moment.

- 13/02/2020 : sur RPI, les cartes générées sont differentes de celles generees sur WINDOWS ou LINUX
-> meme seed, meme 10 premiers nombres avec GameRand::Dump10Value()
=> carte identique en arena
==> test avec anl::KISS
==> ajout de GameCommands : anltest qui lit anltest.xml et renvoit une carte 16x16 des valeurs flottantes générées également ajout du dump integral des instructions de anl::kernel avec les valeurs générées (notamment des constantes qui posent pb entre RPI et Linux)
===> il s'agit d'un probleme de passage des random de KISS sur la pile lors de l'execution des methodes anl::CKernel::simpleFractalLayer (egalement BillowLayer et Ridged)
====> correctif effectuer en creant des float angle,ax,ay,az pour les randoms dans anl::CKernel::simplefBm, anl::CKernel::simpleBillow() et anl::CKernel::simpleRidgedLayer()
=====> 17/02/2020 OK : les cartes générées sur LINUX sont les memes que sur RPI => tester sur WINDOWS.

- 13/02/2020 : Pb de map non visible et de generation de map (vu sur RPI)
-> d'apres les logs, le status peut rester bloquer sur Unloading_Map alors que la map est egalement dans la pile des map à générer
--> la map n'est pas encore dechargée qu'elle est remise en load et donc retirer de la liste de maps à décharger
===> correctif : PushMapToLoad et PushMapToUnload, ne pas faire de verification si maptoload est dans la liste unload.
===> laisser faire le process sans raccourci. plus long mais plus sur.
====> le 14/02/2020. A verifier sur RPI.

- 23/01/2020 : crash apres removetile en bordure de map de 2 tiles sur chacune des map, retour menu puis rechargement (le pb n'existe pas en quittant et relancant l'application)
=> dans ObjectTiled::UpdateSewingBatches => GetTerrainId() => Tile::GetDimensions()
==> Modification de GetTerrainId() pour exclure les Tile*=0 et les Tile*=Tile::EMPTYPTR
=> toujours sur la view BackView(viewid=3 z=13). La backview est setté uniquement les map dungeon.
===> la map 1 19 est un dungeon et la map 0 19 est une cave, en allant chercher le terrainid de cette map dans la viewid=3 qui n'est pas setté cela va chercher un tile avec pointeur qui n'est plus affecté
===> modifier ObjectTiled::UpdateSewingBatches en bordure en tenant compte de l'existence du viewid dans la connectmap : si pas de viewid correspondante toujours ajouté la couture.
====> 27/04/2020 : OK !

- 30/04/2018 : lors d'un removetile ou addtile tenir compte si le tile est en frontier de map pour créer les decals sur la map en bordure
-> 19/01/2020 : ObjectSkinned::SetTile doit etre modifié pour accepter les tile en bordure et gerer la connection avec les map voisines à l'instar de Map::ConnectHorizontalMaps()
==> OK le 22/01/2020 : modification de ObjectSkinned::SetConnectIndex_0() utiliser par ObjectSkinned::SetTileFromSkin() et ObjectSkinned::SetTileFromTerrain()
===> il reste une imperfection masquer par les Sewings lors du rechargement des TileModifiers : les decals en bordure ne s'affichent pas
====> OK 25/01/2020 : correction de Map::ConnectHorizontalMaps() et Map::ConnectVerticalMaps() sur le meme principe

- 23/01/2020 : apres un removetile, retour au menu et relance, la vegetation a disparu de la map
-> voir les logs
-> pb de reset des maps ? pas de pb en quittant le jeu et en rechargeant la partie
==> OK 24/01/2020, static World2D::mapFurnitures_ n'etait pas vidé lors de la destruction de World2D

- 13/09/2018 : Crash au chargement du monde
=> il s'agit des TileModifiers. Si le fichier .til est corrompu ou bien si changement de dimension width,height des Maps
==> voir à faire un test avant chargement des tilemodifiers pour vérifier l'intégrité des tilemodifiers
===> 15/01/2020 : Patch dans Map::SetTileModifiers() pour eviter le crash et LOG ERROR de MAP Versioning.

- 22/03/2018 : les entities changeant de map vers une map non chargée doivent être desactivés et mis en attente du chargement de la map. (créer un status d'attente)
=> pour le moment, l'entity atteignant une zone non chargé, ne change pas de map et continue de tomber
==> l'event GO_CHANGEMAP ne semble pas être envoyé
====> test de GOC_Destroyer avec une BigBomb en bordure de map (PlayState::HandleCreateMode_MouseButton() avec LSHIFT+MButton)
=====> Modification rapide dans GOC_Destroyer::UpdatePositions() pour reactiver le ChangeMap
======> RAF : créer le status d'attente et l'unstuck entity
- lorsque une entité sort de la visiblemaparea, il faut vérifier si la carte non visible a un collider à cet endroit.
-> Si oui alors l'entité ne peut y rentrer et rebrouse chemin.
==> 11/01/2020 : pour resoudre ces 2 problemes liés, il faut créer une collisionchain englobant les maps visibles
===> cette collisionchain sera mise à jour à chaque changement de map visible : cette shape aura 4 vertices (rectangle).
====> OK 12/01/2020 : creation de World2D::visibleCollideBorder_ et World2D::UpdateVisibleCollideBorder()

- 03/01/2020 : voir pour la generation des colliders des zones fermées
=> la generation est deja faite, disponible dans MapCollider::holeVertices_, il manque la creation des collisionchains correspondante
==> OK pour Map::AddCollisionChain2D()
==> OK 06/01/2020 : pour Map::UpdateCollisionChain()

- 28/04/2018 : Modifier l'updateCollider
-> en créant des tiles, les zones qui sont fermées n'ont alors plus de Colliders
==> si un tile ferme une zone, utiliser une plateforme (box collider)
-> le removetile doit permettre de supprimer les plateformes (box colliders)
==> prendre en compte les boxes dans l'updatecollider
===> Autre solution : generation des holes solutionnée le 06/01/2020

- 31/12/2019 : certaines cartes ne se chargent pas et restent bloquées dans un Status Non Available (Bleu). Du coup, le joueur se trouve devant un vide
=> mettre les logs de carte (desactiver le filtre GAMELOG_MAPCREATE) et reproduire ce bug, verifier le status de ces cartes, analyser les logs et le code de MapWorld et de MapStorage.
==> Modification de MapCreator::Update() : verifier si la carte courante est Available, sinon la charger
==> Modification de MapStorage::PushMapToUnload() : ajout de mapCreator_->PurgeMap
===> il y a toujours un risque pour que les cartes voisines de la currentMap ne soient pas chargées
====> voir pour tester que les maps de la visiblearea soient bien Available.
=====> OK 02/01/2020 : modification de World2D::UpdateVisibleArea() pour remplir World2D::visibleMaps_ et modification MapCreator::Update()

- 31/12/2019 : les TileModifiers ne sont pas tous sauvegardés notamment ceux des cartes voisines à la carte courante
=> à la sauvegarde du World2D (en quittant la partie en cours), sauvegarder tout d'abord en memoire les TileModifiers des cartes chargées en memoires
==> OK 01/01/2020 : modification de MapStorage::SaveMaps() pour sauvegarder en memoire les TileModifiers de toutes les MapStorage::mapsInMemory_.

- 23/12/2019 : en bordure haute de map, les plateformes ne sont pas solides pour les entités en Frontview. Pas de pb en Innerview
=> cf MapCreator::CreateMap => MapCreator::GenerateColliders => Map::CreateColliders => Map::GenerateColliders
=> cf Map::UpdateAllColliders, Map::UpdatePhysicCollider
=> cf MapColliderGenerator::GeneratePhysicCollider, MapColliderGenerator::GenerateWorkMatrix
==> cf MapColliderMode::BackMode dans MapColliderGenerator::GenerateWorkMatrix
===> OK 27/12/2019 : utilisation de fluidview pour analyser les blocks
===> Ajout Mode TopBorderBackMode dans MapColliderGenerator::GenerateWorkMatrix qui se charge de générer la blockmap pour la 1ere ligne
===> Ajout de Map::SetCollisionChain2D() qui créer les collisionchains pour un collider id
===> Ajout de Map::CreateTopBorderCollisionShapes() qui est lancé dans Map::ConnectVerticalMaps() uniquement et qui genere et cree les collisionchains pour la nouvelle bottom map connectée.
====> Ajout des physicColliders OuterTop et BackTop pour gérer ce cas.

- 28/10/2019 : sous linux en Debug en session de debuggage, le world ne produit pas les bons Inner
-> le pb provient de anlvm puisque le screenshot est aussi defectueux
--> sans session de debuggage, en redirigeant la sortie standard vers un log.txt, le probleme disparait
--> OK : en session de debuggage, en mettant le define ALTERNATE_COORDENTRY dans vm.inl (le meme que pour compiler sous Win32 VS), le probleme disparait
---> 30/12/2019 : Ajout de preprocess defined(__linux) && defined(DEBUG)

- 23/10/2019 : un crash se produit dans AnlWorlModel avec pthread (MODULETHREAD_VERSION == 1) dans GenerateModuleThread meme avec le mutex
-> à priori, ce crash disparait en parametrant engine_config.xml pour ne pas utiliser les WorkerThreads
--> OK : Ajout de la verification de la map de destination (info.genStatus_->features_[imodule]) avant ecriture. si non existante skip!

- 24/10/2019 : en world, les mondes générés sont differents entre la version gcc et la version vs
-> avec VS dans ANLVM/vm.inl, anl::CNoiseExecutor::EvaluateInstruction() certaines instructions (GradientBasis) ne vont pas avoir d'acces aux coordonnées d'entrée CCoordinate
    et generés des nan values (dans les modules "mix" outer_lowhigh et outer_mixed)
--> pour VS, passer directement par le vector coordcache_ fonctionne bien, contrairement à gcc.
---> OK : garder les deux versions en utilisant des predefined de compilation

- 05/10/2018 : Crash lors de la génération de map dans MapCreator::GenerateEntities -> MapGenerator::IsAreaForSpot() -> MapCollider::IsInside :
=> MapCollider::contourVertices_ renvoie une taille infinie alors que le buffer n'est pas attribuer ...
==> verifier le MapCollider::Clear() et Map::Clear()
==> verifier le Map::Resize(), voir pour reutiliser un tableau de pointer sur PhysicCollider
===> mauvais index de collider utilisé, remplacement de Map::GetMapColliderIndex() par Map::GetViewIndex() => les colliders sont indexer par indv

- 06/10/2018 : les collisionChain de BackGround en FRONTVIEW entrent en collision avec les entities ce qui est non souhaité.
=> probleme depuis le remplacement des MapCollider par PhysicCollider parametré avec ColliderParams
==> voir Map::AddCollisionChain2D() et comparer avec la version SourceStable (24/09)
===> vérifier si colliderZ vaut bien viewZ (06/10 ==> body->SetViewZ(physicCollider.params->colliderZ_) (24/09 ==> body->SetViewZ(mapcollider->viewZ_)) => ca a l'air ok
===> test sur la world map (7, 3)
===> vérifier dans PhysicWorld2D::BeginContact() : la normal est tres infime mais négative => il s'agit d'une inversion de normale du à la forme en ligne oblique générée par mapColliderGenerator
====> correction appliquée dans PhysicWorld2D::BeginContact() => modification du seuil à -0.1f ald 0.f
=====> OK

- 2/09/2018 : lorsque la zone est l'exterieur, les entités ne doivent pas popper en innerview.
=> Generer les mapcolliders avant la generation des entités => OK
==> lors de la génération des entités vérifiés si la zone est ouverte ou fermée pour attribuer le zview
===> Ajout de GameHelpers::IsInsidePolygon() et MapCollider::IsInside()
===> Generer la maptopography avant la generation des entités => OK (dans GenerateLayers meme avec GenerateColliders)
==> 1. si map->GetTopography()->IsFullGround() == true
===> pour chaque spot, essayer de le placer en FRONTVIEW
====> si le mapspot verifie MapCollider(FRONTVIEW)->IsInside(mapspot.point, checkholes=false) == false, placer le mapspot en frontview
====> sinon le mapspot vérifie MapCollider(INNERVIEW)->IsInside(mapspot.point, checkholes=true) == false, placer le mapspot en innerview sinon ne pas enregistrer ce POINT
==> 2. sinon
===> pour chaque spot, essayer de le placer en INNERVIEW
====> si le mapspot vérifie MapCollider(INNERVIEW)->IsInside(mapspot.point, checkholes=true) == false, placer le mapspot en innerview sinon ne pas enregistrer ce POINT
=> OK implanter dans MapCreator::GenerateEntities() -> MapGenerator::IsAreaForSpot()
==> certaines entités sont coincées dans le décor (les BodyColliders sont en collision avec les MapColliders)
====> Map::SetEntity_Add() : décaler en y pour toutes les entités (à l'instar des furnitures)
=> s'assurer qu'il y est au moins un SPOT_START minimum par map notamment pour les cartes ciel vide
==> Ok dans MapGenerator::GenerateRandomSpots()
=> pourquoi les Portal poppent parfois en 0,0 ?
===> int MapGeneratorDungeon::GetPositionOnGround() retournait false dans le premier cas => OK

- 31/08/2018 : en TestZone VM ellipsoid en demarrant en map 4 3 => le GameStatus::SetWorldStartPosition() retourne une position de GOT_START en dehors de zone
=> il s'agit d'une zone dungeon mais sans Room
==> correctif dans MapGeneratorDungeon::GenerateSpots() pour la generation de GOT_START lorsque pas de rooms

- 30/08/2018 : Le World2D ne rend visible que la map courante à l'apparition de la scene
=> modification de UpdateInstant
==> les bordures de map ne sont affichées qu'après apparition
===> Correctif ObjectTiled::UpdateDirtyChunks() pour prendre en compte le notimer

- 29/08/2018 : boucle infinie à debugguer
=> en version(TestZone) ANLVM avec ou sans ACTIVE_WORLD2D_THREADING :
==> reproduction du crash : map -2 4 de départ
===> GameCommand : go2map=9,2, puis prendre le portail à gauche (il mene à la map=12 4) puis descendre
====> les logs indiquent :
[Wed Aug 29 12:25:04 2018] INFO: MapCreator() - CreateMap at 12 2 ... Creating_Map_Layers ...
[Wed Aug 29 12:25:04 2018] INFO: ObjectSkinned() - SetViews ... startTimer=0
[Wed Aug 29 12:25:04 2018] INFO: ObjectSkinned() - SetViewFromTerrain : id=1 featureData=218865296 ...
[Wed Aug 29 12:25:04 2018] INFO: ObjectSkinned() - SetViewFromTerrain : id=1 featureData=218865296 Connected0 ...
[Wed Aug 29 12:25:04 2018] INFO: ObjectSkinned() - SetViews ... view=2/3 ... timer=0 msec
[Wed Aug 29 12:25:04 2018] INFO: ObjectSkinned() - SetViewFromTerrain : id=2 featureData=218869408 ...
[Wed Aug 29 12:25:04 2018] INFO: ObjectSkinned() - SetViewFromTerrain : id=2 featureData=218869408 Connected0 ...
[Wed Aug 29 12:25:04 2018] INFO: ObjectSkinned() - SetViews ... view=3/3 ... timer=1 msec
[Wed Aug 29 12:25:04 2018] INFO: ObjectSkinned() - SetViews ... OK !
====> puis boucle sans fin; l'interruption par le debugger donne un pthread_mutex_lock lié à WorkQueue::ProcessItems
=====> tester Urho3D sans Thread
======> le MapCreator est bloqué sur l'UpdateMaskViews => Dump des viewIds
=======> un pb de generation des viewIds => vérifier la chaine
=======> solution temporaire : dans UpdateMaskViews correction du skip lorsque viewid=-1;
=======> d'autres crashs pourraient se produire, des l'appel a ObjectFeatured::GetViewIDs() sans protection supplementaire
========> correctif dans ObjectFeatured::GetViewIDs() : ajout du check (viewIds_[viewZ].Size() && viewIds_[viewZ].Back() == -1))
=========> correctif de ObjectFeatured::SortViews() et simplification de ObjectFeatured::GetViewIDs()
==========> RAF : certain ObjectTiled renvoit une erreur ObjectTiled::SetCurrentViewZ() avec node_=0 voir pourquoi ils sont sollicités et lié à quelles maps ?

- 21/08/2018 : World2D::SetVisibleMaps() => Ajout d'un purge pour mapsToShow_ : la liste générée lors d'un dezoom etait trés grosse et générait de tres gros ralentissement (10-20fps)
=> reste un bug : certaines maps restent bloquées au Status InitializedMap

- 20/07/2018 : correctif pour la Pause
=> OK : ViewManager::MoveCamera() si Scene IsUpdateEnabled()

- 19/07/2018 : Ajout CAMERAFOCUS_ADJUSTWALK (ajuster le camera focus pour décaler d'un offset dans le cas d'un walker)
=> cf ViewManager::UpdateFocus()

- 13/06/2018 : pourquoi de lag ? cf FAQ de SFML ou c'est plutot bien expliqué
-> Profilage dans (World2D_Update)
--> il s'agit probablement de procedures qui ne sont pas optimisé en Async (doit être plus rapide que 5msec)
--> Optimiser ObjectTiled::UpdateTiledBatches, ObjectTiled::UpdateDecalBatches, ObjectTiled::UpdateSewingBatches
--> Optimiser Map::SetCollisionShapes()
--> Optimiser Map::SetFurnitures, Map::AddBackScroller
-> faire le meme profilage sur RPI et Android
-> apres amelioration, le lag se produit encore
--> engine, renderer2d, trop de batches ?
--> TODO
---> 17/08/2018 : fin de la premiere tentative avec correction du deplacement dans mapworld

- 11/06/2018 : ObjectTiled -> revoir le container pour les differents batches (TILES, DECALS, SEWING)
-> Creer ChunkBatch
--> diminution du nombre de batch (pour les decals et les sewing) mais il faut encore modifier les batches des scrollers pour permettre un dégradé sur les decals

- 28/06/2018 : affichage décroche par moment en mode arena (WINDOWED 1024x768 VSYNC)
--> comparatif du num batches entre la version courante et la version FromBones_master-WIP20180604-ConditionalAbilities+PatchBombeGrapin en mode arena (chunk 4x2)
---> version courante = 80 batches  version ancienne = 40 batches
----> trouver les changements impactant les batches dans FromBones et/ ou Urho3D
-----> Dans Urho3D Rendered2D::CompareSourceBatch2Ds => il est necessaire de garder le code
    if (lhs->material_ != rhs->material_)
        return lhs->material_->GetNameHash() => rhs->material_->GetNameHash();

- 07/06/2018 : ameliorer la rapidité de traitement avec le PhysicWorld2D,
=> utilisé le RigidBody2D::GetColliderInfo() pour identifier les "MapCollider2D"
==> OK remplacement effecté dans FromBones et Urho3D

- 23/05/2018 : disparition des tags ROOMS des la version "FromBones_master-WIP20180423-PatchBackScroller"
=> comparer cette version avec la précédente "FromBones_master-WIP20180413-Vegetation"
==> La génération des Spots est centralisée dans GenerateSpots
===> ne plus créer des spots en dehors de la fonction
===> OK, MapDungeonGenerator modifier !

- 25/04/2018 : flipping à l'apparition d'une entité via ObjectPool::CreateChildIn()
=> cette procédure rend enable le node si le parent(la map) est déjà enabled
==> ce qui implique l'affichage avant le changement de position réalisé ultérieurement par GOC_Destroyer::UpdatePositions()
===> ajout dans GOC_Destroyer::Reset() de node_->GetDerivedComponent(Drawable2D)()->GetSourceBatchesToRender() qui permet de rafraichir
=> OK !

- 25/04/2018 : disparition du player si déplacement sur d'autres maps hors player focus
=> lors du UnLoadMap, l'ajout de World2D::PurgeEntities() vide la liste des entities dont fait partie le Player, qui ne peut plus être affiché par la suite via le World2D::SetEntitiesVisible()
==> modification du World2D::PurgeEntities() pour skipper les entities players (à l'instar de Map::RemoveNodes())
===> OK !

- grace à ANLWorldModel, il est possible de créer une WorldMap : créer une WorldMap et remettre la MiniMap (04/08/2017)
=> 22/10/2017 : MiniMap réactivée (pb dans les angles à corriger)
==> 10/02/2018 : priorité créer une WorldMap permettant de visualisation un fichier anlworld et d'afficher et regler les differents modules d'ANLWORLD et de sauver le modele en mode creation
===> une nouvelle version d'anl est disponible mais changement important
====> voir comment convertir les modeles anlworld vers cette version (VM).
=====> pouvoir comparer les 2 versions en terme de rapidité de generation sur un monde équivalent (les modules n'étant pas les memes)
======> modifier AnlWorldModel pour gérer les 2 versions en parallèle
======> OK : 14/02/2018, VM est beaucoup moins rapide
=======> ajouter des caches comme les CacheArray ajouté à la V1.
========> OK : 19/02/2018, divise par 2 le temps d'exec dans imaging
========> OK : 21/02/2018, ajout des threads detaché dans AnlWorldModel avec CacheArray (avec cachearray activé on passe de 130msec à 70msec (avec 2 threads))
=========> réduire le nombre d'instructions générées avec les constantes, interpolation etc...
==========> NOK : 15/03/2018, après bcp d'efforts, pas de résultat concluant en rapidité en réduisant le nombre d'instructions voir V2 du 13/03/2018, peut-être qu'il s'agit d'une erreur de passer sans récursion
===========> serait-il bien meilleur de reprendre la V1 et de l'adapter à la VM ?
============> OK : 20/03/2018 ajout de radial, la carte obtenue en V1 est satisfaisante et beaucoup plus rapide mais sans thread : 30msec ald de 70msec en VM (avec 2 threads)
======> gestion des seeds avec VM ?
=> 22/03/2018 : sous WIN32, VM n'est pas utilisable en thread (pas de pthread et plantage avec pthread-win32) et genere des maps buggées en asynchrone.

- pbs récurrent sur les ObjectPools à corriger !
-> écrasement des nodes existants => perte de certains nodes dans la scene. Impact également le Network. voir note 20170509
-> ObjectPools : les animations ne sont pas tjrs restaurées dans la pool (bolttransfo du vampire par exemple). Il semble que l'animation spawnée ne soit pas à son état initial.
    -> bug toujours actif le 11/10/2017 ===> A CORRIGER RAPIDEMENT
    => l'effet est pris en compte par World2D (liste des entities), dans ce cas si l'effet est dejà restauré et qu'il n'est pas supprimé de cette liste
       alors le setvisible du world2D peut le réactiver (l'utiliser alors qu'il est dans le pool)
    ==> OK 12/10/2017 : Map::AddEntity() : ne pas envoyer l'event GO_APPEAR si le node a l'attr GOT_Effect
-> 20/03/2018 : pb toujours actif !
    description du bug :
    etape1 : spawn d'une entity RayonHypno
        -> World2D() - SpawnEntity  on map 0,0
        --> appel GOC_Animator2D() - ToDestroy RayonHypno(16800192)
    etape2 : déplacement générant un appel à World2D() - SetMapVisible
        -> appel de World2D()-SetEntitiesVisible : mPoint=0 0 visible=show ...
        --> appel de GOC_Animator2D() - Start : RayonHypno(16800192) state=State_Spawn(445058125) !
        ---> appel de GOC_Animator2D() - ToDestroy RayonHypno(16800192)
        ----> génération de ERROR: ObjectPool() - Free : Node=RayonHypno(16800192) ... already inside Pool !!!
    etape3 : spawn d'une entity RayonHypno
        --> l'entity réapparait bloqué
==> il semblerait qu'à l'étape 2, l'entity soit tjrs affectée à la map 0,0 occassionant un respawn lors du World2D()-SetEntitiesVisible
===> vérifier la liste des entités dans la map0,0 avant le World2D()-SetEntitiesVisible
====> il apparait bien dans la liste
=====> vérifier si dans la chaine de destroy, on supprime bien l'entity de la liste de World2D
======> Correctif dans GOC_Animator2D() - ToDestroy => ajout de World2D::RemoveEntity() et correctif dans World2D::RemoveEntity() => erase par iterator ald unsigned
======> 21/03/2018 : OK

- 07/02/2018 : AccidentalNoise ajout de CacheArray : met en cache tout une carte générée pour être réutiliser dans un autre process
=> diviser par 2 le temps de generation du WORLDGROUNDMAP.

- 18/10/2017 : Map Modifiable par les joueurs
=> fonctions de base OK 23/12/2017
    -> penser à la serialization + réseau
    -> analyser minetest.
    -> modifier les controles (actuellement simple test avec souris BL=addtile BR=removetile sur le viewZ courant du joueur)
        -> cf behavior

- vu dans World1 (Map1_0), des doors apparaissent dans des zones interieures non souhaitées
-> les FeatureFilters TRANSFERFRONTIER générent des Doors dans des zones de dungeon car TunnelInnerSpace > RoomInnerSpace
=> Correctif : 16/12/2017 inversion de l'ordre des MapFeatureType (TunnelInnerSpace doit etre inferieur à RoomInnerSpace)

- les FluidBatches de la précédente viewZ flippent juste après changement de vue (03/08/2017)
-> voir la mise à jour de ces batches
=> Semble corrigé depuis correctif du 09/10/2017

- 09/10/2017 : Correctif pour l'update des fluids dans ObjectTiled : l'update des batches est bien réalisé seulement si la simulation apporte des changements.

- reactivation des fluids : FluidSimulator + render in ObjectTile
==> Test en cours
=> prévoir le déversement des fluids entre les maps
=> les fluids doivent pouvoir changer de view (exemple inside vers outside, exit et windows)
--> si fluid sur innerview, si pas de frontview bloquant ni de outerview bloquant, deversé sur outerview
=> OK le 03/09/2017 :
    -> ok pour le deversement sur les maps adjacentes
    -> à tester avec le deversement suivant Z : methode 2 OuterViews (une pour innerview, l'autre pour frontview)
     -> voir pour réduire le nombre de fluidview : linker la featureview (outerview) pour permettre le check des cellules
        => OK le 04/09/2017

- Generation des wallcolliders : au bas des windows, en innerview il n'y a pas de collider, en frontview ils existent bien
-> voir MapColliderGenerator pour corriger l'INNERVIEW
=> OK (04/08/2017) : MapColliderGenerator::GenerateWorkMatrix (ajout de la detection du feat Window pour le BackMode) & Map::AddCollisionChain2D (BackView reconnu comme InsideWalls pour le SetFilterBits)

- les maskviews ne suppriment pas assez de tiles (qui devraient être masqués)
=> OK (02/08/2017) : modification ObjectFeatured::GenerateMaskViews pour les modes Connect4 et 0 (decals+dimensions)
==> ObjectFeatured::UpdateMaskViews ne sert plus pour le moment
=> Tres bon Gain sur la quantité de Tile Masked
=> Test sur les performances à faire
=> OK (04/08/2017) 1msec sur du 64x64 pour une viewZ

- les fluids ne s'affichent plus lors d'un changement de carte, seulement si switch view
=> le simulator fonctionne correctement
=> provient des fluidbatches, surement un pb de setdirty
=> si pb, le fait de rendre la map invisible et de la remettre visible résoud le pb d'affichage
==> OK : il peut arriver à l'initialisation d'une map que le UpdateSourceBatchesToRender se déroule avant le HandleUpdateFluid, dans ce cas il convient d'ajouter les sourceBatches
===> ajout d'un updateFluid dans le ObjectTiled::UpdateSourceBatchesToRender
====> réapparition du bug (02/08/2017)
=====> 03/08/2017 OK : réactiver UpdateFluids ald UpdateFluidBatches
====> apres changement de zView, la simulation sur la zview précedente s'arrete (scene1 pas test): toutes les vues doivent etre simulees
=====> 03/08/2017 OK : correctif dans MapCreator::GenerateSimpleGroundMap AddFluidViewToViewZ(InnerView_ViewId ...) ald AddFluidViewToViewZ(BackGround_ViewId ...)

- Intégration de la nouvelle TileSet : pb de hotspot => modification TileSheet2D + ObjectTiled
=> OK (02/08/2017)

- Modifier MapCreator pour intégrer par défaut MapCreator::GenerateMapFromWorld()
-> prévoir la possibilité de basculer vers l'ancien GenerateGround si pas de AnlWorld setted.
=> 07/07/2017 OK !

- Refactor des viewBatches (Vector<<<>>> en HashMap + Vector) </>
-> Correction d'un crash (ayant lieu dans le Renderer2D du à corruption Material* (0x18)) : UpdateSourceBatchesToRender() corrigé - les Fluids ne doivent pas etre envoyé vers le Renderer si pas de viewBatches
=> 05/07/2017 OK !

- Au chargement initial, réduire le nombre de map buffered à générer pour réduire le temps de chargement ? ou bien augmenter le temps alloué à la génération par frame
=> OK, Augmentation du temps par frame

- incorporation AccidentalNoise / Creation AnlWorld Generator
=> prévoir le remplacement des GOT_Exits par de la logique au niveau du GOC_Move2D ou GOC_Destroyer
===> Remplacement des GOT_Exits réalisé via GOC_Destroyer::UpdatePositions.
===> 21/06/2017, Sur AnlWorld generator :
====> dans le FeatureMap BACKVIEW mettre les blocks faisant frontiere entre interieur et exterieur en Door ---> OK!
====> dans le FeatureMap FRONTVIEW suppression de ces blocks frontiere ---> OK!
===> 24/06/2017, version generation asynchrone AnlWorldModel::GenerateModules OK!

- Les maps créer sont différentes sur chaque plateforme sauf normalement en activant c++11 (utilisation Mersen Twister)
=> refactor du Generateur de Hasard (GameRand créer)
==> Test à réaliser en multi platerform avec et sans c++11
===> Les tests en C++11 ne sont pas conformes. Des différences apparaissent au niveau des randoms dans la phase de génération du sol (MapCreator).
====> il s'agit de la précision float qui différe entre plateform. passage en integer (précision réglable dans les const)
====> suite au passage en integer, l'utilisation du SetParamsInt(int n, ...) par args présente un bug non identifié.
=====> utilisation exclusif de SetParamsInt(PODVector) pour le passage de params.
====> correction de Noise (il restait un rand() ...)
=====> 20/06/2017 : OK, tests concluant en C++11 et inférieurs (avec ou sans Mersen)

- Crash au niveau du destructor ~MapGeneratorDungeon sur le PODVector selfAllocatedMap :
=> le crash apparait seulement si la generation des plateforms est activé (ACTIVE_DUNGEONPLATEFORMS)
=> il n'apparait que lorsque de nouvelles cartes sont générées après déplacement dans le mapworld
=> le problème semble engendre par la création des features Plateforms
==> changement de l'algo MapGeneratorDungeon::MakeRoomPlateforms()
===> après test avec ce nouvel algo, il apparait encore ce crash de façon moins systématique
====> il semble que ce crash soit insidueux, assert à mettre dans mapworld, mapstorage, map, peut-etre une corruption mémoire suite à dépassement des limites qui se répercute sur les datas du mapgeneratordungeon
=====> OK : disparition suite à Refactoring ObjectTile 20170616. A tester si réapparition.
======> 16/06/2017 : Réapparition du crash, en utilisant c++11 générateur random Mersenne-Twister
=======> 20/06/2017 : Pas de nouvelle reapparation depuis le changement SetParamsInt(PODVector)

- le debugfluid n'est pas sur la bonne view :
=> Ok, inversion dans StaticTiledObject2D::DrawDebugGeometry() entre fluidViewIds.Front() et fluidViewIds.Back()
==> TODO : Vérifier si les fluidViewIds sont triés par zview à l'instar des viewIds

- pbs récurrent sur les ObjectPools à corriger !
-> les CollectablePart provenant de BodyExploder2D sont supprimer 2x de suite occasionnant mess err :
   WARNING: World2D() - HandleObjectDestroy : GO DESTROY node=(16781466) no entity in mpoint=0 0 !!!
   ERROR: ObjectPool() - Free : Node=CollectablePart(16781466) ... already inside Pool !!!
==> OK, modification du TimeRemover pour effacer en instant si delay=0.f

- les players ne doivent pas être parentés aux maps ! il serait mieux que les entités ne le soient pas également
==> OK en inactivant REPARENT_ENTITIES_ONMAP

- pb d'ObjectPool avec les CollectPart du BodyExploder en Replicated
-> les GOT_Skeletons ne laissent plus leurs bones : non-apparition des bones lors de l'explode après une seconde régénération du BodyExploder (rechargement d'une scene par ex)
-> les nodes semblent être disabled et pas à la bonne place à priori
-> ce probleme n'existe pas en mettant les CollectPart en Local dans GOT::InitDefaultTables()
==> OK dans ObjectPool::FreeNode reactive le AddChild vers le nodeCategory. Autrement, les nodes bones reparenté au mapNode sont effacés par le SceneCleaner.

*/



/** ======= **/
/** STORY   **/
/** ======= **/

/* TODO 
------

- 30/03/2023 : voir pour generer des actors dans le monde avec des tasks/activités (chasseur, batisseur, agriculteur, alchimiste, commercant, voleur, assassin par exemple)
=> ce qui pourra ensuite faire de bon interacteur pour une generation aleatoire de quete (comme DaggerFall)
==> pas mal de costumes à faire
=> 30/05/2023 : il faudrait un character builder pour vérifier les costumes sur un scml : verifier les fonctions permettant le characterMapping -> GameHelpers::SetEquipmentList, EquipmentList, et GOT::PreLoadObjects
==> il prendrait le scml et permettrait de charger un costume (character mapping) ainsi que la mise en couleur des differents sprites.
==> probleme avec les yeux et les bouches : pour un meme sprite soit on cree differentes versions de sprite pour le position sur chaque tete (ca va alourdir les textures) soit on cree un fichier pour chaque tete contenant les positions d'origine pour chaque sprite.
===> l'ajout de la couleur pour chaque sprite et de l'offset d'origine par rapport au parent peut être réalisé en ajoutant à Urho3D::Spriter::Ref (Color color_; float x_,y_,angle_;)
===> réaliser des fonctions SaveXML pour chaque data de Urho3D::Spriter pour permettre la sauvegarde d'une entité Spriter.
====> 02/06/2023 : implementation OK dans Urho3D::AnimationSet2D et Urho3D::Spriter
===> ajouter des fonctions permettant la modification et le rendu des couleurs et des offsets positions
====> ok pour les premiers essais avec la couleur (cf PerformTest_SaveAnimationSet()) : la couleur d'un ou plusieurs sprites est liée à l'entité.
    Si l'on veut la meme entité avec une couleur de peau differente par exemple, il faut dupliquer l'entité et utiliser AnimationSet2D::SetEntityObjectRefAttr.
====> plutot lier la couleur et l'offset au charactermapping. et ainsi créer des charactermapping pour les differentes couleurs de peau et les differentes positions pour les yeux et bouches en fonction des tetes.
====> il faudrait créer des nouvelles données dans le charactermapping : replacementColor_, linkageOffset_ (un sprite (tete...) pourra ajouter des liens avec d'autre sprites (oeil,bouche...), ces sprites seront alors offseté de la valeur indiquée)

- 18/12/2020 : Mise en place d'Acteurs dans le World2D.
=> commencer par le Marchand, lui ajouter aussi des missions.
==> ajouter aussi aux missions des textes d'introduction / histoires ...
===> ajouter un journal de quetes : il doit indiquer les quetes terminées, en cours. Pour toutes les quetes, affichage du contexte, acteur ayant donné la quete, localisation sur la carte, résumé de taches finies.
===> une quete rassemble de nombreuses missions dans un contexte (scenarios/textes) et une temporalité clairement définie.
====> commencer par une quete lineaire.
====> puis extrapoler avec des quetes à embranchement.
==> reprendre Mission et MissionManager, MissionGenerator.
===> il faut développer les objectifs de mission PROTECTOR, EXPLORER, CREATOR ... cf GameGoal.h
====> pour les objectifs PROTECTOR, EXPLORER il faut associer un actorid et une worldposition.
====> le mPoint est soit predefini, soit généré en fonction de la difficulté de la mission (ecart entre map de depart et mPoint de destination)
====> la validation de ce mPoint et la definition de la position n'intervient que lorsque la map est générée et que les conditions sont reunies (ex : Dungeon, GOT_Start). Si les conditions ne sont pas respectees, trouver un mPoint au voisinage.
=> Exemple de Quete Simple :
==> Donneur de Quete "Ernest"
===> Trouver les Quetes Accessibles (en fonction des quetes pre-requis réalisés, des niveaux de quetes necessaires ?)
===> choisir une quete correspondant au niveau (voir au niveau inferieur)
====> Affichage du dialogue d'introduction de la quete
    " Ernest : Veux-tu que je te parle des Golem de Pierre vivants dans la region ?"
    " Golem de Pierre => Ce sont d'imposants geants issus de la première ère de notre monde, engendrés par les restes de la magie primordiale et de la Terre Mère."
    " J'ai entendu dire que si l'on plantait une graine d'Eliegor sur sa tete alors, ce géant se lierait pour toujours à son donateur ! "
    " Mais biensur ce n'est qu'une histoire ancienne ... enfin si tu es assez teméraire peut-être que tu serais interessé par cette graine."
    " Graine d'Eliegor => Cette semence provient d'une fleur d'un rouge violacé intense, que l'on trouve généralement au sommet de certaines montagnes."
    " Veux-tu partir en quete du Golem D'Eliegor ?"
=====> Cette quete est composé de deux objectifs : EXPLORER pour trouver la graine d'Eliegor, CREATOR pour creer le golem d'Eliegor à partir des ingredients (Golem, Graine D'Eliegor) et des outils Pelle et Arrosoir.
=====> chaque texte de quete pourrait contenir des mots clé permettant d'avoir acces à d'autre dialogue ?
======> 20/12/2021 : Ajout de UIC_JournalPanel, JournalData et modification de Mission, MissionManager ...
=======> il faut remplir journal_fr.xml avec les données de quetes (Texte de journal et ObjectiveData)
=======> pour la quete du golem d'Eliegor : il faut creer un filet pour attrapper la graine, ainsi que la pelle et l'arrosoir qui seront à utiliser sur la tete du golem avec la graine.
======> 11/04/2022 : reprise de la creation de contenu : ajouter l'objet Pelle, pouvoir l'equiper, et pouvoir interagir avec le rockgolem.
=======> pour l'objectif CREATOR : utiliser les recipes du craft, Modification de Objective::Update.
=======> quand la quete est complete => ajouter une animation de floraison au RockGolem, le changer de faction et débloquer l'avatar rockgolem.
========> modification des Reward à faire : une recompense peut aussi être une nouvelle capacité débloquée, un nouvel avatar, une nouvelle quete ... ajouter des nouvelles category COT::ABILITY, COT::AVATAR, COT::QUEST
=========> completer le code de UIC_JournalPanel::OnMissionUpdated() en s'inspirant de UIC_MissionPanel::Update()
========> mettre l'AnimatedSprite2D Entity RockGolem + l'AnimatedSprite2D Entity flore dans le node avatar.
=========> plusieurs AnimatedSprite2D dans le node root pose probleme au GameHelpers::CopyAttributes() => modification à faire
==========> 16/04/2022 : creer des nodes fils pour la flore evite d'avoir à toucher à CopyAttributes. Petite Modification pour le changement de layer dans GOC_Destroyer::SetViewZ.
=========> OK 21/04/2022 : serialization du journal => Mission::SaveXML() fait => RAF Mission::Save() et Mission::Load()
==========> la quete fonctionne correctement dans les grandes lignes : il faut maintenant l'étoffer.
===========> OK : 1. utilisation du filet pour attraper la graine : attribut "Catchers" ajouter à GOC_Collectable
===========> 2. utilisation de la pelle sur la tete du rockgolem pour planter la graine : ajouter un trigger avec déclenchement conditionnel : etoffer GOC_Detector
============> ajout de bool GOC_Detector::attackDetector_ attribute "Attack Only".
=============> preferer analyser la collision dans GOC_Collide2D lorsque la shape body est un trigger avec un CollisionMask=CM_DETECTOR.
    ce qui permet d'enregistrer la collision pour analyse ulterieure avec MissionManager. Il faut juste s'assurer que les players ont bien leur collisionShape attack avec ce CM
==============> ajout dans Player::UpdateComponents()
===========> 3. utilisation de l'arrosoir sur la tete du rockgolem pour faire pousser la plante : de meme.
==========> 06/05/2022 : OK ajout de ObjectiveCommand, ObjectiveCommandData permettant dans un objectif de mission de soit tester une condition, soit realiser une action.
===========> ObjectiveCondition::Check et ObjectiveAction::Execute
==========> pouvoir ajouter/invoquer des followers (comme le skeleton et eliegorgolem) => ajouter la category COT::FOLLOWERS.
===========> reajout de GOB_Follow::Stop()
====> la serialization des quetes en cours à faire, notamment il faut sauvegarder les Varslot des missions.
=====> 10/05/2022 : OK correctif dans Map::SetEntities_Load() : controller->SetMainController() doit etre fait avant le SendEvent(WORLD_ENTITYCREATE), pour permettre
    à GOC_Destroyer d'envoyer GO_APPEAR vers GOManager::HandleGOAppear() avec le bon maincontrol.
=====> 10/05/2022 : OK correctif dans Mission::LoadXML() pour bien setter les MissionData, ObjectiveData et les ObjectiveVars.
=====> en mode Arena, à la mort de l'avatar, le jeu est sauvegardé mais sans l'entité RockGolem qui avait était ajouté et devenu EliegorGolem suite à la quete ...
======> la sauvegarde automatique à la mort de l'avatar ne sauvegarde pas les entités alliés ?
=====> 15/05/2022 : lorsque l'on realise la quete en arena : eliegorgolem spawn et il est bloquer dans un decors ...
=====> 15/05/2022 : lorsque l'on realise la quete en arena et que l'on tue eliegorgolem, la partie devrait etre gagnée.
=====> 15/05/2022 : la fenetre de dialogue du journal n'est pas bien dimensionnée, lorsque la fenetre du jeu au lancement est superieure a 1920x1080 ... il doit y avoir redimensionnement de la fenetre de dialogue.
======> voir Player::ResizeUI()
=======> OK : utilisation de UI::SetScale() dans Game::HandleWindowResize -> GameStatus::ResetScreen() ald homemade GameStatus::SetUIScale()
========> implique des légères modifications dans Urho3D::UI et Urho3D::Input
========> correctif dans GameHelpers::OrthoWorldToScreen.
========> utilisation de GameHelpers::GetInputPosition() ald GameStatus::cursor_->GetPosition() : la position du cursor devait être corrigé du facteur GameStatus::uiScale_
=======> mettre en option l'utilisation de UI::SetScale() car il ne s'agit pas d'une solution permettant d'obtenir un pixel perfect pour l'ui.
=======> il faudrait un mix entre les deux solutions : rescale du framing

=> pour le mode histoire "prédéfinie" ajouter la liste json de actors comprenant les infos id, type, position etc...
==> charger la liste à l'initialisation. Les avatar des actors sont instanciés au moment du chargement de la map associée.
==> cf PlayState::InitLevel() et World2D::SaveWorld()
===> 07/03/2021 : World2D::UpdateActors et Ajout d'ActorInfo dans Actor
====> 09/03/2021 : lors du SaveWorld, sauvegarde des Actors dans une nouvelle liste json en mode normal ou bien dans la liste initiale en mode Editor (faire un backup de l'ancienne version).
=====> 08/10/2022 : ajout de MapStorage::CopyInitialWorldFiles pour initialiser les fichiers du monde avec ceux de la distribution
======> permet d'avoir les actors chargés en mode histoire.

=> checker la view pour le Player::HandleClic() si pas sur la meme view que l'interactor ne rien faire.

*/

/* DONE 
------


*/



/** ======= **/
/** EDITOR  **/
/** ======= **/

/* TODO
------

- 07/06/2023 : Enrichissement de l'Editor : l'editeur en Script ne sera plus mise à jour. Utilisation uniquement du static ou du shared.
=> ajout de Animator2D : qui est un panneau d'edition des animationSet2D
==> permettra de changer la couleur, le fx par sprite ainsi que d'ajouter des offsets de positionnement pour les yeux et la bouche en fonction du visage.
==> pour le moment ne fonctionne que sous GL, sous VK il faut finir l'implementation avec RenderTarget (specifier dans RenderPath) et RenderSurface car View3D s'appuie sur ce mecanisme.
===> replacer par des panels et une visualisation de l'animatedSprite directement dans la scene courante.
===> créer le panneau timeline, le panneau animation, le panneau charactermapping.
===> voire pour reprendre la timeline faite avec SpaceMatch.
===> créer en priorité un panneau charactermapping pour l'edition des couleurs et la position des yeux et bouche en fonction du visage.
===> on pourrait également utiliser AnimatedSprite2D::spritesInfos_ Urho3D::Spriter::SpriteInfo pour stocker la couleur : ce qui serait pas mal pour changer les couleurs de l'equipement.
===> en fait ce que l'on voudrait c'est avoir un skeleton et pouvoir charger des skins dessus comme dans les implementation moderne spine, ue4 ...
====> modification de Urho3D::AnimatedSprite2D avec ajout de colorMapping_
====> 14/06/2023 : ajout dans l'editor des panneaux characterMapping, ColorMapping et SwapSprites
====> 21/06/2023 OK : sauvegarde du Color Mapping dans le SCML ou dans un SCML addon
=====> l'ui, ajouter une liste comme pour le character mapping avec un bouton New en plus pour créer des colorMapping ou bien modifier l'ui du characterMaps en Maps qui inclura les Maps de Character et de Color
====> ajout d' une dropdownlist de selection de l'entité à editer, important pour la selection des character et color mapping.
====> SwapSprites Panel s'applique characterMapping édité
====> ColorMapping Panel permet de créer un mapping de Color.
====> 29/06/2023 OK : Animation panel permet de jouer les differentes animations
====> Ajouter/Tester les delta Positions pour le characterMapping
=====> pour cela dans l'editeur, il faudra pouvoir selectionner et manipuler les sprites.
=====> 03/07/2023 OK pour la selection : ajout de AnimatorEditor::SelectSprite et AnimatedSprite2D::GetSpriteAt()
=====> 05/07/2023 OK pour la manipulation : translate, rotate, scale ajout de AnimatorEditor::MoveSelection() et pas mal de modification dans SpriterData et AnimatedSprite2D
======> fonctionne pour un mapped sprite avec modification du characterMap::MapInstruction::targetdx,dy,dangle,scalex,scaley.
======> 06/07/2023 OK : faire un test sur une animation fonctionnelle créer dans actor-medium.
======> étendre la manipulation aux slots (sprite d'origine) avec modification directe des SpatialTimelineKey.
=====> ajouter l'edition des pivots, des bones, des points et des boxes et des triggers associés spécifiques à FromBones ?
======> 07/07/2023 OK : pivots
======> 09/07/2023 OK : affichage des bones => RAF voir pour l'antialiasing pour les ligne sous Vulkan (MultiSample).
======> 11/07/2023 OK : manipulation des bones : sensibles à la rotation lorsque clic à proximité du point "pointe" et au déplacement sur le point "origine"
=======> pas encore très claire sur la création ou non de timekey lorsque manipulation. Il semble y avoir des erreurs lorsque un bone est mis en rotation : quelle timekey est MAJ ? normalement la timekey la plus proche.
========> le probleme etait lié aux spin et à l'interpolation lineaire de l'angle.
=========> lors de la manipulation de l'angle dans l'editeur régler à spin=1 par défaut et faire une dropdownlist pour pouvoir modifier le spin si nécessaire.
=========> Lorsque spin=0 il n'y a pas d'interpolation ce qui peut generer des sacades cf Urho3D::Spriter::SpatialInfo::Interpolate() et Urho3D::Spriter::AngleLinear()
=========> ce comportement peut etre necessaire pour swapper d'angle sans utiliser de curve instant.
======> ajouter un panel pour visualiser les timekeys.
=======> 12/07/2023 OK : pour le moment, juste dans l'animation panel avec une partie information sur la timeline selectionnée avec edition possible du spin.
=======> 13/07/2023 OK : ajout de la modification (add/remove) des timekeys.
=======> RAF ajout/suppression de timeline (bone et sprite)
======> il faut ajouter une box de message pour voir le mode d'edition (timeline editing, charactermap offseting)
======> ajouter un bouton pour aligné le sprite selectionné avec l'origine du bone.

- 17/09/2018 : creation de MapEditor
=> OK : possibilité de forcer le CreateMode des le mainmenu en appuyant sur F3
==> voir pour le retour en mode normal dans PlayState : utiliser un event pour recharger PlayState ?

- après settile, l'update des colliders est à corriger : 16/12/2017 car ne pointe pas vers les bons collisionshapes si split chains
    => 23/12/2017 : OK changement de methode (modification de tous les vertices ... profiler serait bien)
    ==> lors de la suppression de colliders, le Grapin ne se détache pas, de meme pour MV_CLIMB,
    ====> 27/12/2017 : OK ajout de l'event MAPTILEREMOVED envoyé par Map. GOC_Collide2D et GOC_PhysicsGrapin souscrivent à cet event.

- Serialization des tiles modifiées
-> revoir le format de map
-> voir minetest pour l'aspect réseau
-> faire la gestion asynchrone du MapStorage::UnloadMap comme le MapStorage::Initialize
    => rendre le plus fluide possible
-> revoir la strategie de chargement/dechargement des maps
    => faut-il precharger en mémoire tous les TileModifiers ou bien charger au fur et à mesure ?

- auto modification des tiles impactés par un changement d'un tile de couche superieure ou inferieure
-> établir les régles des tiles impactés
=> 17/07/2020 : l'ajout de tile doit selectionner le tile vide sur le layer le plus profond non masqué (non obturé par une tile superieure) en commencant par le layer du viewz specifié
==> la permutation de tile ne sera utilisable que sur le layer du viewz
===> Modification de GameHelpers::AddTile() et Map::SetTile()
=> 17/07/2020 : la suppression de tile doit selectionner le tile plein sur le layer le moins profond non masqué (non obturé par une tile superieure) en commencant par le layer du viewz specifié
===> Modification de GameHelpers::RemoveTile() et Map::SetTile()
=> 21/07/2020 : dans MapCreator::GenerateDungeonMap les lignes suivantes impactent les views BACKVIEW et OUTERVIEW :
        map->featuredMap_->AddFeatureFilter(COPYTILEMODIFIER, InnerView_ViewId, BackView_ViewId, MapFeatureType::InnerSpace, MapFeatureType::RoomWall);
        map->featuredMap_->AddFeatureFilter(COPYTILEMODIFIER, InnerView_ViewId, OuterView_ViewId, MapFeatureType::InnerSpace, MapFeatureType::RoomWall);
        map->featuredMap_->AddFeatureFilter(COPYTILEMODIFIER, InnerView_ViewId, OuterView_ViewId, MapFeatureType::RoomWall, MapFeatureType::RoomWall);
    vu les FeatureFilter definis dans MapCreator (Copy de Innerview vers Outerview et BackView), il faut desactiver les COPYTILEMODIFIER
    dans ObjectFeatured::ApplyFeatureFilter(unsigned) pour realiser les AddTile et RemoveTile définis ci-dessus.
==> Pour le AddTile en Map DUNGEONINNERTYPE, toujours creer les tiles en INNERVIEW et laisser faire les filtres
    (decommenter les filtres COPYTILEMODIFIER precedemment commentés dans ObjectFeatured::ApplyFeatureFilter(unsigned))
==> de meme pour le RemoveTile
==> la creation en BACKGROUND ne s'effectue pas si le COPYTILEMODIFIER du FRONTVIEW vers le BACKGROUND n'est pas désactivé dans MapCreator::GenerateWorldGroundMap et MapCreator::GenerateSimpleGroundMap
==> 28/07/2020 : etablissement des regles suivantes :
// en frontview
// => pouvoir creer des tiles de background et des tiles de frontview
// => pouvoir detruire des tiles de background et des tiles de frontview
// => pouvoir detruire des tiles de outerview qui detruit automatiquement l'innerview et le backview
// => ajouter une option, pour ne jamais creer de tiles de background
// en innerview
// => pouvoir creer des tiles d'innerview qui ajoute automatiquement des tiles en backview et outerview
// => pouvoir creer des tiles de background
// => pouvoir detruire des tiles d'innerview solid qui seront remplacés par InnerSpace
// => pouvoir detruire des tiles de background si pas de tiles en frontview

- Créer l'UI
=> selection du layer (zview : frontview,outerview,innerview, background ...)
=> creation d'un selecteur de case (simple, par box, ou multiple (box + simple + simple + box ...))
=> modification des cases du selecteur (panneau feature, terrain, skin ...)
=> creation du panel pour la selection d'objets à ajouter : entity, furniture, actor
=> 23/12/2020 : hack de l'editeur de Urho3D. Integration dans FromBones
==> Modification des Spawns dans Map::SetEntities_Add() => Spawn dans node Entities Local ou Replicated si Network.
==> 23/12/2020 OK : finalisation de l'intégration en PlayState : Appui sur F3 => Toggle Editor.
==> les GOA doivent etre enregistrées dans Urho3D pour pouvoir être editable dans l'Inspector
===> OK : Enregistrement via GOA::RegisterToScene() -> Scene::RegisterVar().
==> les entities instanciées d'ObjectPool doivent être des prefabs (non modifiables sauf pour les positions).
==> ajouter listview pour selectionner le got à spawner selon la category selectionnée.
===> 03/01/2021 : lors de la selection de la category afficher la listview

==> normalement le Save World suffit pour prendre en compte les changements.
===> 03/01/2021 : pb lors de la sauvegarde pour la position des furnitures
====> cf MapData::UpdateObjectInfos() et Map::GetMapTilePosition()
====> 09/01/2021 : les methodes developpées pour le moment sont :
=====> MapData::UpdateMapFurniture() et MapData::UpdateObjectInfos() utilisées lors de la sauvegarde d'une map pour synchroniser les MapFurniture : entre autre, le positionnement (via tileindex_, randomoffset_, tileoffsetx_, tileoffsety_) est mis à jour.
======> voir pour reduire la taille en byte de ces 4 datas car autant utiliser un Vector2 autrement. (Vector2 = 2 floats = 2*4 = 8 bytes) tileindex_=uint=4bytes, randomoffset_=int=4bytes, tileoffsetx_=int=4bytes, tileoffsety_=int=4bytes
=====> Map::SetStaticMapFurnitureAt() utilisée lors du SpawnFurniture et de Map::UpdateMapFurniture() se concentre sur le positionnement à partir d'une worldposition sur la plus proche side d'un block solide uniquement.
======> pour la Tenture, il faut pouvoir associer un tile de backview ou de background. voir pour definir une propriété d'ancrage
    => remplacer tileoffsetx_ et tileoffsety_ par tileanchor_ qui peut prendre les valeurs de 0 à 4 (4 etant le centre de la tile, les autres les sides) et tiletype_ qui definit si la tile doit etre solide ou non
    ==> voir pour fusionner MapFurniture et WorldEntityInfo en gardant les infos essentielles
    ===> WorldEntityInfo ne sert que pour transferer les datas de Map::Populate() vers Map::SetEntities_Add()
    ===> MapFurniture est utilisé pour communiquer les datas des generator vers Map::AddFurnitures() et Map::SetFurnitures() et l'ajout ponctuel de nouvelle furniture via Map::AddFurniture() et World2D::AddStaticFurniture()
    ===> ces 2 structures sont membres de MapData et sont à substituer par EntityData occupant 8bytes.
====> 17/01/2021 : Ok EntityData remplace WorldEntityInfo et MapFurniture. Map::AnchorEntityOnTileAt() remplace Map::SetStaticMapFurnitureAt.
=====> Rappel : MapData ne sert qu'à la serialization. Ce n'est pas un gestionnaire d'entités.
=====> crash : surement pb de corruption mémoire. Logguer EntityData
======> la structure MapData::entityInfos_ ne va pas pointé vers les bon EntityData* si ajout/suppression d'une EntityData dans MapData::furnitures_ et MapData::entities_ ce qui peut occassionner une corruption de memoire
=======> ne jamais supprimer des entityData mais remplir par un EntityData::gotindex_=0 (similaire à la façon de procéder dans la version avec MapFurniture) ?
========> 18/01/2021 - OK : le pb venait de l'ajout dans GOC_Destroyer::UpdatePositions() de MapData::RemoveEntityData() et MapData::AddEntityData() necessaire pour le changement de Map. Correctif appliqué avec ajout de moveEntityData_.
=========> encore un crash (corruption mémoire) : non identifié
==========> crash lors du SaveWorld F6. Quelques correctifs dans MapData::AddEntityData (ajout des freeEntityDatas : entitydatas desattribué via RemoveEntityData qui peuvent être reattribués via AddEntityData)
===========> lors du SaveWorld, le MapData::PurgeEntityDatas() va être lancer ce qui est destructif pour MapData::entityInfos_.
============> voir MapData::PurgeEntityDatas() pour reconstituer MapData::entityInfos_
===========> en activant uniquement les furnitures, il n'y a pas de crash => la cause provient des entities.
============> Pour le moment, les EntityDatas ne servent à rien à updater pour les entités etant donné qu'il y a deja les entitiesAttributes de serializer => desactivation des EntityDatas pour les Entities seulement, dans MapWorld, GOC_Destroyer et Map.

=====> a VERIFIER dans MapCreator suite à l'introduction d'EntityData, si les MapDatas dejà en mémoire sont bien utilisées pour alimenter directement Map::SetFurnitures plutot que d'avoir à les regenerer avec MapGenerator.
======> OK c'est dejà fait cf MapCreator::GenerateEntities() avec le map->GetMapData()->SetSection(MAPDATASECTION_FURNITURE);

===> 03/01/2021 : pb si deplacement d'un GOT_Portal, celui-ci semble inactif apres.
====> Semble etre resolu depuis le remplacement par EntityData

- faire l'update des colliders après Map::SetTile

*/

/* DONE
------

- Créer les fonctions de bases pour la modification de tiles et la mise à jour des batches
-> void Map::SetTile(FeatureType, int x, int y, int zview)
    => 15/11/2017 : OK pour Connected4 et Connected0
    => 12/11/2017 : dans le cas ou l'on supprime le dernier tile d'un batch, celui-ci est toujours apparent
        => Corrige ObjectTiled::UpdateTiledBatches(), ajout de ClearBatchVertices

*/
