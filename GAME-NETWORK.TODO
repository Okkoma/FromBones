@IMPORTANT
----------------------------------------------------------------------------
- 01/09/2021 par defaut le net simulateur est activé.
- NE PAS OUBLIER D'ACTIVER dans slikenet/include/defines.h
- ligne #Define _RETAIL pour desactiver le NetSimulator en version Publique_
----------------------------------------------------------------------------

Todos:

    ☐ 02/02/2024 : il y a encore des problemes avec les spawn de mirubil serveur -> client ; vu egalement avec les bombes

    ☐ 07/02/2024 : sur un client, si un avatar distant rentre dans la zone d'affichage du joueur, cet avatar ne s'affiche pas toujours.
        => modification GameNetwork::UpdateControl de reactivation du node si vivant et sur une map visible.
        => correctif ClientInfo::CreateAvatarFor (ajout AddTag("Player")) pour etre sur coté server
        --> 10/02/2024 : il y a certaines fois ou l'avatar n'est pas visible. Il suffit de changer d'avatar pour qu'il se raffiche ...

    ✔  10/02/2024 : ajouter les effets sur les clients distants
        -> correctif dans GOC_Controller::SetControllerType, probleme de faction qui etait mal setté pour les mobs (faction=0)
        --> ca à l'air ok pour le CaC avec GOC_Life::ReceiveEffectFrom
        --> les effets de feu ne fonctionnent pas.
        ---> Lors du changement d'equipement sur un client via UPDATEEQUIPMENT ou SETFULLEQUIPMENT, il faut mettre à jour les attributs de GOC_Attack.
        ====> OK 14/02/2024 : ajout de Equipment::GetEquipmentEffects() à utiliser dans GOC_Inventory::NetClientSetEquipment()

    ✔ 10/02/2024 : lorsque un mob est en contact (sans déplacement), on ne voit pas l'animation attaque
        -> ajout dans GOC_Animator2D::CheckAnim() de netChangeCounter_++ si fin de l'animation

    ☐ 10/02/2024 : ameliorer la priorisation des maps à charger pour l'affichage sans avoir de maps manquantes dans le visuel apres teleportation
        -> bloquer la zone tant que les maps ne sont pas affichées pour eviter d'avoir ce probleme visuel

    ☐ 02/02/2024 : Probleme avec la potion coté client
        -> probleme avec UpdateControlAck ?
        -> 10/02/2024 : il arrive meme qu'un avatar perd le jeu en prenant une potion. Vue avec Petite
            ou alors est-ce un autre pb ? un mob qui n'apparait pas coté client ? les logs ne sont pas assez détaillés pour juger.
            Il faut ajouter les tick effects ...

    ✔ 09/02/2024 : il y a ping pong de purgemap et de requestmap coté server
        -> il semble que la position du client ne soit pas bien pris en compte coté server
        --> cela peut arriver du aux positions transmises via ObjectControl et en bordure de map
        -> TravelerNodeInfo::Update() et le traitement de BufferExpandInfo dans MapStorage
        ==> ok correctif dans TravelerNodeInfo::Update() : en reseau il faut utiliser la position de l'ObjectControl et non pas celui du node qui est en extrapolation dans le temps et parfois lag.

    ☐ 09/02/2024 : le server envoit parfois des packets d'ObjectCommand qui ne contiennent parfois que des action NOACTION
        -> il est possible de les supprimer pour alléger la charge réseau

    ✔ 07/02/2024 : le drop item Map::AddEntity spawn parfois dans un mur sur le server mais pas sur le client
        -> dans Map::AddEntity, GOC_Destroyer n'a pas encore la position mise à jour ...
        => OK : modification de Map::AddEntity() => viewz=NOVIEW et updater la position de GOC_Destroyer. Permet d'eviter le unstuck dans GOC_Destroyer::UpdatePositions.

    ☐ 07/02/2024 : lors du drop collectable, il faut etre sur d'avoir le bon nodeid entre server et client.
        -> server->client : correctif dans World2D::SpawnCollectable utilisé par le client : utilisation du nodeid en provenance du server.
        -> client->server : le client drop un item, le server recoit la commande DROPITEM avec le nodeid prit sur le client
            le server drop l'item et emet la commande ADDCOLLECTABLE avec normalement le meme nodeid ...
        ==> si le nodeid est different, il faut que ce client le sache ... cf GOC_Collectable::DropSlotFrom
        ===> envoi de la commande LINKNODEID qui va faire le lien pour ce node entre le server et le client.
        ====> A tester. Verifier les logs

    ☐ 07/02/2024 : la taille (entityvariation) des furnitures n'est pas la meme lorsque l'on recharge la map

    ✔ 05/02/2024 : Consolider World2D pour la teleportation en reseau cf GameHelpers::TransferPlayersToMap
        --> il semble que le server ne modifie pas la position du TravelerNodeInfo, le node etant disable sur le client, son etat est repercuté et donc sa position n'est pas setté sur le server
        ==> OK : création ObjectCommand SETPLAYERPOSITION client->server qui force la mise à jour de position
        ==> OK : ajout de Player::FindASafePlace() car le client n'a pas la map disponible (UpdateInstant en clientmode n'est pas géré) et doit trouver la position de l'avatar lors de sa réactivation.
        ===> OK : coté server, il faut desactiver le SetPosition de GOC_Destroyer le temps que le client charge les maps, trouve une "SafePlace" et envoit un second SETPLAYERPOSITION

    ☐ 22/11/2023 : mettre à jour network.svg
        => Gestion des spawn
            Client initialise le spawn => il faut que ce soit avec AddSpawnControl (le client créée un node avec un clientnodeid et prend un spawnid, spawnstamp++)
                pour le drop de collectable cela n'est pas le cas à cause du slotdata qui n'est pas communiqué avec l'ObjectControl (seulement avec l'ObjectCommand)
                le AddSpawnControl n'a pas besoin d'etre utilisé dans ce cas.
                On envoie toujours une commande DROPITEM vers le serveur qui renvoit une commande ADDCOLLECTABLE vers les autres clients.

            Map::AddEntity hors editeur, est utilisé directement uniquement par Node* World2D::SpawnEntity
                World2D::SpawnEntity est ensuite utilisé dans les fonctions suivantes
                 Actor
                 GOC_Animator2D::SpawnEntity, client or server netspawning
                 GOC_Collectable::DropSlotFrom, selon le dropmode ... envoi d'ObjectCommand
                    <- GOC_DropZone::HandleThrowOutItems          -> si server et owner alors dropmode=4(SLOT_ADDCOLLECTABLE) sinon -1(SLOT_NONE)=sans envoi d'ObjectCommand
                    <- GOC_Inventory::ApplyTemplateToCurrentSlots -> si server et owner alors dropmode=4(SLOT_ADDCOLLECTABLE) sinon -1(SLOT_NONE)=sans envoi d'ObjectCommand
                    <- GOC_Inventory::TransferSlotTo              -> si server et owner alors dropmode=4(SLOT_ADDCOLLECTABLE) sinon -1(SLOT_NONE)=sans envoi d'ObjectCommand
                    <- GOC_Inventory::HandleDrop                  -> si server et owner alors dropmode=4(SLOT_ADDCOLLECTABLE) sinon -1(SLOT_NONE)=sans envoi d'ObjectCommand
                    <- GOC_Inventory::NetServerDropItem           -> server ... dropmode=4(SLOT_ADDCOLLECTABLE) ... CMD=ADDCOLLECTABLE broadcast excluant clientid
                    <- UIC ...                                    -> client ... dropmode compris entre 0 et 3 ... CMD=DROPITEM
                 GameNetwork::Client_SpawnItem
                    => il faut avoir un servernodeid ce qui n'est pas le cas car provenant directement du client sender
                    => Suppression : n'est plus necessaire, sur server tout passe en dropmode=4 sinon rien, enlever la souscription du server à l'event GO_DROPITEM
                 GOC_DropZone::HandleContact, sanctuaire buildable type
                 GOC_Spawner::HandleUpdate => OK : ne pas spawner en ClientMode
                 DefsEffects (boss et bosschest),
                 ObjectiveAction::Execute => ne pas spawner en ClientMode
                 World2D::NetSpawnEntity
                    <- GameNetwork::NetAddEntity
                        <- GameNetwork::Client_SetWorldObjects : a verifier
                        <- GameNetwork::HandlePlayClient_ReceiveServerControls : instantiate distant clients avatars.
                        <- GameNetwork::NetSpawnEntity
                            <- GameNetwork::HandlePlayServer_ReceiveControls : server netspawning
                            <- GameNetwork::HandlePlayClient_ReceiveServerControls : client netspawning
        => Netspawning : voir pour la synchronisation des spawnstamps

    ✔ 04/02/2024 : Attraper des graines avec le filet en reseau ne fonctionne pas
        => cf GOC_Collectable::HandleContact avec les catchers
        ==> OK : il faut que le cshape du joueur ne soit pas un trigger. Modification de Player::UpdateComponents(), utilisation de UpdateTriggerAttacks() meme si pas maincontroller.

    ✔ 02/02/2024 : voir pour le craft networked
        -> la gestion avec plusieurs panels ne fonctionne pas encore. Il faut revoir entierement le process d'envoi vers le serveur.
        --> comment gerer le drop d'item dans le panneau de craft ou du marchand sur le serveur ?
        -> pour le moment le server ne recoit que les ObjectCommand DROPITEM, SETITEM qui sont traiter dans Server_UpdateInventory()
        -> cf 30/01/2024, 19/11/2023 et 17/11/2023
        ==> GOC_Collectable::TransferSlotTo envoie GO_INVENTORYGET qui est seul recupéré par GameNetwork coté server
        ==> UIC_BagPanel::UpdateSlot envoie GO_INVENTORYSLOTSET qui est récupéré par GameNetwork coté client pour générer ObjCmd SETITEM envoyé vers le server
        ---> UIC_BagPanel::UpdateSlot doit avoir l'argument updateNet=true, qui est vrai seulement lorsque UISlotPanel::OnDragSlotFinish est appelé
        ====> OK : modification de GOC_Collectable::TransferSlotTo pour envoyer aussi GO_INVENTORYSLOTSET si c'est un client et que le node getter a pour owner ce client.

    ✔ 02/02/2024 : il faut verifier et completer la gestion reseau inventaires, drop de collectables ... parfois on ne peut pas ramasser un collectable
        -> cas du drop de l'inventaire d'un collectable (x2 epee) dans l'equipement. celui-ci va monter une des 2 epees et drop la quantité restante dans l'inventaire mais plus de place alors drop sur le sol.
           l'objet n'apparait pas coté serveur. le serveur ne peut pas traiter le slotremain car ca lui est invisible : dans UISlotPanel::HandleSlotDragEnd (coté client) on utilise un slot temporaire.
        ==> ok modification de UISlotPanel::OnSlotRemain et de GOC_Inventory::NetServerDropItem. (dropmode = 3 est le mode pour les slots remain)
        ===> centralisation de l'envoi des net events de Drop dans GOC_Collectable::DropSlotFrom, ajout de SlotDropMode

    ✔ 02/02/2024 : Si on quitte coté serveur la partie, il faut que les clients repassent en menustate
        => ct deja le cas mais un pb dans PlayState::EndScene (utilisation SetStatus(PLAYSTATE_INITIALIZE) qui n'a rien à faire là) désormais corrigé
        ==> correctif d'un crash server, du à la non reinitialisation de GameNetwork::spawnControls_ qui porte des pointeurs vers des ObjectControlInfo qui sont supprimés des retour au MenuState.
        ===> ajout de GameNetwork::ClearSpawnControls() à utiliser des retour au menu.

    ✔ 02/02/2024 : Si un client quitte ça relance automatiquement la partie car le serveur relance le client...
        -> coté Received ObjectCommand en Menustate, il faut filtrer pour n'accepter que les commandes importantes pour ce state.
        ==> modification evitant aussi des Crash (si un client est en menustate et qu'un autre client en Playstate et spawn des objets alors il y avait crash sur le client en Menustate car tentative de creation d'objets alors que par de world...)
        ===> si en menustate, ne pas prendre en compte les commandes > REQUESTMAP
        ====> OK : modif dans GameNetwork::Server_ApplyObjectCommand et GameNetwork::Client_ApplyObjectCommand.

    ☐ 29/01/2024 : probleme de reactivation de netplayer mort sur le serveur.
        -> le message de reactivation START_GAME parvient avant que Player::Stop ne soit lancer.
        => il faut stocker la demande de Restart et attendre la fin de Player::Stop pour lancer le Restart.
        ==> patch dans GameNetwork::Server_ApplyReceivedGameStatus et GameNetwork::HandlePlayServer_NetworkUpdate
        ===> 01/02/2024 : encore des problemes, mettre les log en evidence si de nouveau le probleme resurgit.

    ✔ 01/02/2024 : deux avatars client distant monté l'un sur l'autre, si le joueur qui sert de monture change d'avatar alors probleme de position
        -> il faut lors du changement d'avatar qu'il demonte et qu'il remonte
        -> dans GameNetwork::UpdateControl ->  GOC_Controller::ChangeAvatarOrEntity
        --> si changement d'avatar verifier si un node est déjà monté, dans ce cas le demonter et le remonter.
        --> cela est deja fait grace à GameHelpers::MountNode, GameHelpers::UnmountNode
        ===> OK : Patch correctif dans GOC_Controller::MountOn partie sans MountNode, il y avait un pb avec GOC_Destroyer::ShapeRect qui ne devait pas etre setté comme il faut

    ✔ 01/02/2024 : le changement de viewZ entre deux avatars client distant monté l'un sur l'autre fait que sur les 2 clients, switch view infini
        -> cf GOC_Destroyer::SetViewZ et ViewManager::SwitchToViewIndex
        ==> il faut verifier le clientid et faire une restriction si clientids differents
        ==> OK modification dans ViewManager::SwitchToViewIndex

    ✔ 01/02/2024 : si suicide de l'avatar sur une entité montée, il faut le demonter avant de mourir
        -> OK : modifier GOC_Controller::Unmount() pour ne pas utilise GOC_Animator::ResetState() si le node est ISDEAD, sinon reset de l'animation etc...

    ✔ 01/02/2024 : Crash coté client, en mode arena dans une map 5 0 eloigné du world default map (0,0)
        -> le client essaie de prendre une position initiale safe à partir d'une map qui est dechargée (map(0,0)) et ne peut l'obtenir du server immediatement.
        => LOG CLIENT :
        [Thu Feb  1 15:18:12 2024] INFO: PlayState() - ---------------------------------------
        [Thu Feb  1 15:18:12 2024] INFO: PlayState() - RestartLevel                           -
        [Thu Feb  1 15:18:12 2024] INFO: PlayState() - ---------------------------------------
        ...
        [Thu Feb  1 15:18:12 2024] INFO: GOManager() - Reset : activePlayer Size=0 player Size=0 (keepedPlayer=false)
        [Thu Feb  1 15:18:12 2024] INFO: PlayState() - ResetPlayers  ...
        [Thu Feb  1 15:18:12 2024] INFO: PlayState() - SetPlayers  ... init=false restart=true load=false numplayers=1
        [Thu Feb  1 15:18:12 2024] INFO: MapStorage() - InitializeMap : mPoint=0 0 map=0 0 ptr=1257192464 state=Initializing=1 ... OK !
        [Thu Feb  1 15:18:12 2024] ERROR: MapStorage() - InitializeMap mPoint=0 0(map=1257192464) ... ClientMode ... put map in loading state ... Wait !
        [Thu Feb  1 15:18:12 2024] ERROR: GameNetwork() - PushObjectCommand : clientid=2(from:2) broadcast=false cmd=REQUESTMAP=20 nodeid=0 !
        [Thu Feb  1 15:18:12 2024] INFO: MapCreator() - AddMapToCreate : 0 0 !
        [Thu Feb  1 15:18:12 2024] INFO: GameContext() - SetWorldStartPosition : Find a Start Spot on mpoint=0 0 at 13 53 viewZ=100 !
        [Thu Feb  1 15:18:12 2024] INFO: GameContext() - SetWorldStartPosition : StartPosition=(wpos:17.28 13.44|viewz:100|mpoint:0 0|mpos:13 53|tindex:0|intile:0 0) ...
        ...
        [Thu Feb  1 15:18:12 2024] INFO: ---------------------------------------------------
        [Thu Feb  1 15:18:12 2024] INFO: - Player() - SetScene : player ID=1 ...
        [Thu Feb  1 15:18:12 2024] INFO: ---------------------------------------------------
        [Thu Feb  1 15:18:12 2024] INFO: Player() - SetScene : actorID=1 nodeID=16777278 controlID=0 restart=true position=435.26 18.4983 viewZ=70 ...
        ...
        [Thu Feb  1 15:18:12 2024] INFO: ---------------------------------------------------
        [Thu Feb  1 15:18:12 2024] INFO: - World2D() - UpdateInstant : viewport=0 point=5 0 ... OK ! -
        [Thu Feb  1 15:18:12 2024] INFO: ---------------------------------------------------
        ...
        [Thu Feb  1 15:18:12 2024] ERROR: World2D() - GetMapAt : point=0 0 map=1257192464 is > Available !
        [Thu Feb  1 15:18:12 2024] ERROR: ObjectFeatured() - GetViewIDs : ERROR at viewZ=100 => DumpViewIds=no ViewIDs for viewZ=100 !
        [Thu Feb  1 15:18:12 2024] INFO: ObjectFeatured() - SortViewsIds_All : Dump i=1/1 viewId=-1 viewZ=0
        [Thu Feb  1 15:18:12 2024] INFO: ObjectFeatured() - SortViewsIds_All : ... OK !
        => CRASH
        ==> OK : Modification  GameContext::SetWorldStartPosition et ajout de World2D::GetWorld()->SaveFocusPositions() dans PlayState::ResetPlayers()

    ✔ 31/01/2024 : Lorsqu'une entity monte un avatar cela pose probleme ...
        -> coté client l'entity controllé par le serveur ne monte pas sur l'avatar, sur le server c ok.
        => verifier GOC_AIController::Start() et GOC_AIController::OnEntitySelection()
        ==> cela se joue dans Start() qui n'est pas executé sur le client, car pas maincontroller.
        ===> OK : permission au GO_AI_Ally de Start meme si non maincontroller
        ==> coté second client, cela ne fonctionne pas
        ===> OK : envoyer un ordre de mount du serveur vers l'ensemble des clients.
        ===> il y a aussi un probleme lorsque l'avatar monte l'entity, il peut apparaitre decaler de la monture.
        ====> OK : cela provient de Destroyer Unstuck : toujours le desactiver quand monté.

    ✔ 31/01/2024 : coté client, il y a des problemes avec le spawn de mirubil -> oeuf mirubil -> elsarion, du surement aux spawnstamps
        -> il faut verifier en profondeur ... etre sur
        => en local, le probleme principal/majeur à corriger : l'animation peut entrer en boucle et spawné en boucle ...
        ==> verifier toute la chaine jusqu'à GOC_Animator2D::SpawnEntity
        => LOG CLIENT
        [Wed Jan 31 22:32:52 2024] INFO: GOC_Animator2D() - SpawnEntity : Node=Player_1(16777274) Try to spawn entity=OeufMirubil entityid=0 ... dirx=1 rot=-2.55142251322736e-08 faction=0
        [Wed Jan 31 22:32:52 2024] INFO: World2D() - SpawnEntity : id=0 got=OeufMirubil(3813840255) effectiveType=OeufMirubil(3813840255) position=19.25 15.90 mpoint=0 0 viewZ=70 deferredAdd=false
        [Wed Jan 31 22:32:52 2024] INFO: Map() - AddEntity : node=OeufMirubil(16790587) entityid=16 mPoint=0 0 spawn at 19.2463 15.8979 slotdata=0 ...
        [Wed Jan 31 22:32:52 2024] INFO: World2D() - HandleObjectAppear : GO APPEAR node=OeufMirubil(16790587) type=0 mpoint=0 0 viewZ=70 entitiesInMap=142
        [Wed Jan 31 22:32:52 2024] INFO: GameNetwork() - AddSpawnControl : ServerControl node=OeufMirubil(16790587) ... spawnid=553648186(holderid=16777274,spawnstamp=33) ...
        [Wed Jan 31 22:32:52 2024] INFO: GameNetwork() - AddSpawnControl : ...  oinfo=3357737200 srvnodeid=0 cltnodeid=16790587 holderptr=3388937408(nodeid=16777274,clientid=0) spawnstamp=33 !
        [Wed Jan 31 22:32:52 2024] INFO: Map() - AddEntity : mPoint=0 0 nodeid=16790587 type=OeufMirubil(3813840255) entityid=16 at 19.2463 15.8979 viewZ=70 sceneInfo.skipNetSpawn_=false ... OK !
        [Wed Jan 31 22:32:52 2024] INFO: GameNetwork() - LinkSpawnControl : oinfo=3357737200 from clientid=0 spawnid=553648186 links serverNodeID_=16790587 clientNodeID_=16790587 !
        ...
        [Wed Jan 31 22:32:53 2024] INFO: GOC_Animator2D() - SpawnEntity : Node=Player_1(16777274) Try to spawn entity=OeufMirubil entityid=0 ... dirx=1 rot=-2.55142251322736e-08 faction=0
        [Wed Jan 31 22:32:53 2024] INFO: World2D() - SpawnEntity : id=0 got=OeufMirubil(3813840255) effectiveType=OeufMirubil(3813840255) position=19.25 15.90 mpoint=0 0 viewZ=70 deferredAdd=false
        [Wed Jan 31 22:32:53 2024] INFO: Map() - AddEntity : node=OeufMirubil(16790587) entityid=16 mPoint=0 0 spawn at 19.2463 15.8979 slotdata=0 ...
        [Wed Jan 31 22:32:53 2024] INFO: World2D() - HandleObjectAppear : GO APPEAR node=OeufMirubil(16790587) type=0 mpoint=0 0 viewZ=70 entitiesInMap=141
        [Wed Jan 31 22:32:53 2024] INFO: GameNetwork() - AddSpawnControl : ServerControl node=OeufMirubil(16790587) ... spawnid=570425402(holderid=16777274,spawnstamp=34) ...
        [Wed Jan 31 22:32:53 2024] INFO: GameNetwork() - AddSpawnControl : ...  oinfo=3357737200 srvnodeid=0 cltnodeid=16790587 holderptr=3388937408(nodeid=16777274,clientid=0) spawnstamp=34 !
        [Wed Jan 31 22:32:53 2024] INFO: Map() - AddEntity : mPoint=0 0 nodeid=16790587 type=OeufMirubil(3813840255) entityid=16 at 19.2463 15.8979 viewZ=70 sceneInfo.skipNetSpawn_=false ... OK !
        ... =====> ERROR ICI pas de Link = un spawn de plus que sur le serveur ce qui crée un décalage
        ...
        [Wed Jan 31 22:33:04 2024] INFO: GOC_Animator2D() - SpawnEntity : Node=Player_1(16777274) Try to spawn entity=OeufMirubil entityid=0 ... dirx=-1 rot=2.55142251322736e-08 faction=0
        [Wed Jan 31 22:33:04 2024] INFO: World2D() - SpawnEntity : id=0 got=OeufMirubil(3813840255) effectiveType=OeufMirubil(3813840255) position=17.06 15.90 mpoint=0 0 viewZ=70 deferredAdd=false
        [Wed Jan 31 22:33:04 2024] INFO: Map() - AddEntity : node=OeufMirubil(16790587) entityid=16 mPoint=0 0 spawn at 17.0592 15.8979 slotdata=0 ...
        [Wed Jan 31 22:33:04 2024] INFO: World2D() - HandleObjectAppear : GO APPEAR node=OeufMirubil(16790587) type=0 mpoint=0 0 viewZ=70 entitiesInMap=140
        [Wed Jan 31 22:33:04 2024] INFO: GameNetwork() - AddSpawnControl : ServerControl node=OeufMirubil(16790587) ... spawnid=587202618(holderid=16777274,spawnstamp=35) ...
        [Wed Jan 31 22:33:04 2024] INFO: GameNetwork() - AddSpawnControl : ... new oinfo=3357742384 srvnodeid=0 cltnodeid=16790587 holderptr=3388937408(nodeid=16777274,clientid=0) spawnstamp=35 !
        [Wed Jan 31 22:33:04 2024] INFO: Map() - AddEntity : mPoint=0 0 nodeid=16790587 type=OeufMirubil(3813840255) entityid=16 at 17.0592 15.8979 viewZ=70 sceneInfo.skipNetSpawn_=false ... OK !
        [Wed Jan 31 22:33:04 2024] INFO: GameNetwork() - LinkSpawnControl : oinfo=3357737200 from clientid=0 spawnid=570425402 links serverNodeID_=16790587 clientNodeID_=16790587 !
        ...
        [Wed Jan 31 22:33:14 2024] INFO: GOC_Animator2D() - SpawnEntity : Node=Player_1(16777274) Try to spawn entity=OeufMirubil entityid=0 ... dirx=-1 rot=2.55142251322736e-08 faction=0
        [Wed Jan 31 22:33:14 2024] INFO: World2D() - SpawnEntity : id=0 got=OeufMirubil(3813840255) effectiveType=OeufMirubil(3813840255) position=18.68 15.90 mpoint=0 0 viewZ=70 deferredAdd=false
        [Wed Jan 31 22:33:14 2024] INFO: Map() - AddEntity : node=OeufMirubil(16790587) entityid=16 mPoint=0 0 spawn at 18.6823 15.8979 slotdata=0 ...
        [Wed Jan 31 22:33:14 2024] INFO: World2D() - HandleObjectAppear : GO APPEAR node=OeufMirubil(16790587) type=0 mpoint=0 0 viewZ=70 entitiesInMap=140
        [Wed Jan 31 22:33:14 2024] INFO: GameNetwork() - AddSpawnControl : ServerControl node=OeufMirubil(16790587) ... spawnid=603979834(holderid=16777274,spawnstamp=36) ...
        [Wed Jan 31 22:33:14 2024] INFO: GameNetwork() - AddSpawnControl : ...  oinfo=3357737200 srvnodeid=0 cltnodeid=16790587 holderptr=3388937408(nodeid=16777274,clientid=0) spawnstamp=36 !
        [Wed Jan 31 22:33:14 2024] INFO: Map() - AddEntity : mPoint=0 0 nodeid=16790587 type=OeufMirubil(3813840255) entityid=16 at 18.6823 15.8979 viewZ=70 sceneInfo.skipNetSpawn_=false ... OK !
        [Wed Jan 31 22:33:14 2024] INFO: GameNetwork() - LinkSpawnControl : oinfo=3357742384 from clientid=0 spawnid=587202618 links serverNodeID_=16790587 clientNodeID_=16790587 !
        => LOG SERVER
        [Wed Jan 31 22:32:52 2024] INFO: GOC_Animator2D() - SpawnEntity : Node=Player_5(16777274) Try to spawn entity=OeufMirubil entityid=0 ... dirx=1 rot=-2.55142251322736e-08 faction=0
        [Wed Jan 31 22:32:52 2024] INFO: World2D() - SpawnEntity : id=0 got=OeufMirubil(3813840255) effectiveType=OeufMirubil(3813840255) position=19.24 15.90 mpoint=0 0 viewZ=70 deferredAdd=false
        [Wed Jan 31 22:32:52 2024] INFO: Map() - AddEntity : node=OeufMirubil(16790587) entityid=16 mPoint=0 0 spawn at 19.2392 15.8979 slotdata=0 ...
        [Wed Jan 31 22:32:52 2024] INFO: World2D() - HandleObjectAppear : GO APPEAR node=OeufMirubil(16790587) type=0 mpoint=0 0 viewZ=70 entitiesInMap=141
        [Wed Jan 31 22:32:52 2024] INFO: GameNetwork() - AddSpawnControl : ServerControl node=OeufMirubil(16790587) ... spawnid=553648186(holderid=16777274,spawnstamp=33) ...
        [Wed Jan 31 22:32:52 2024] INFO: GameNetwork() - AddSpawnControl : ...  oinfo=2352576864 srvnodeid=16790587 cltnodeid=0 holderptr=3022959296(nodeid=16777274,clientid=0) spawnstamp=33 !
        [Wed Jan 31 22:32:52 2024] INFO: Map() - AddEntity : mPoint=0 0 nodeid=16790587 type=OeufMirubil(3813840255) entityid=16 at 19.2392 15.8979 viewZ=70 sceneInfo.skipNetSpawn_=false ... OK !
        ...
        [Wed Jan 31 22:33:04 2024] INFO: GOC_Animator2D() - SpawnEntity : Node=Player_5(16777274) Try to spawn entity=OeufMirubil entityid=0 ... dirx=-1 rot=2.55142251322736e-08 faction=0
        [Wed Jan 31 22:33:04 2024] INFO: World2D() - SpawnEntity : id=0 got=OeufMirubil(3813840255) effectiveType=OeufMirubil(3813840255) position=17.07 15.90 mpoint=0 0 viewZ=70 deferredAdd=false
        [Wed Jan 31 22:33:04 2024] INFO: Map() - AddEntity : node=OeufMirubil(16790587) entityid=16 mPoint=0 0 spawn at 17.0655 15.8979 slotdata=0 ...
        [Wed Jan 31 22:33:04 2024] INFO: World2D() - HandleObjectAppear : GO APPEAR node=OeufMirubil(16790587) type=0 mpoint=0 0 viewZ=70 entitiesInMap=140
        [Wed Jan 31 22:33:04 2024] INFO: GameNetwork() - AddSpawnControl : ServerControl node=OeufMirubil(16790587) ... spawnid=570425402(holderid=16777274,spawnstamp=34) ...
        [Wed Jan 31 22:33:04 2024] INFO: GameNetwork() - AddSpawnControl : ...  oinfo=2352576864 srvnodeid=16790587 cltnodeid=0 holderptr=3022959296(nodeid=16777274,clientid=0) spawnstamp=34 !
        [Wed Jan 31 22:33:04 2024] INFO: Map() - AddEntity : mPoint=0 0 nodeid=16790587 type=OeufMirubil(3813840255) entityid=16 at 17.0655 15.8979 viewZ=70 sceneInfo.skipNetSpawn_=false ... OK !
        ...
        [Wed Jan 31 22:33:14 2024] INFO: GOC_Animator2D() - SpawnEntity : Node=Player_5(16777274) Try to spawn entity=OeufMirubil entityid=0 ... dirx=-1 rot=2.55142251322736e-08 faction=0
        [Wed Jan 31 22:33:14 2024] INFO: World2D() - SpawnEntity : id=0 got=OeufMirubil(3813840255) effectiveType=OeufMirubil(3813840255) position=18.68 15.90 mpoint=0 0 viewZ=70 deferredAdd=false
        [Wed Jan 31 22:33:14 2024] INFO: Map() - AddEntity : node=OeufMirubil(16790587) entityid=16 mPoint=0 0 spawn at 18.6841 15.8979 slotdata=0 ...
        [Wed Jan 31 22:33:14 2024] INFO: World2D() - HandleObjectAppear : GO APPEAR node=OeufMirubil(16790587) type=0 mpoint=0 0 viewZ=70 entitiesInMap=140
        [Wed Jan 31 22:33:14 2024] INFO: GameNetwork() - AddSpawnControl : ServerControl node=OeufMirubil(16790587) ... spawnid=587202618(holderid=16777274,spawnstamp=35) ...
        [Wed Jan 31 22:33:14 2024] INFO: GameNetwork() - AddSpawnControl : ...  oinfo=2352576864 srvnodeid=16790587 cltnodeid=0 holderptr=3022959296(nodeid=16777274,clientid=0) spawnstamp=35 !
        [Wed Jan 31 22:33:14 2024] INFO: Map() - AddEntity : mPoint=0 0 nodeid=16790587 type=OeufMirubil(3813840255) entityid=16 at 18.6841 15.8979 viewZ=70 sceneInfo.skipNetSpawn_=false ... OK !
        ...
        ==> le client spawns 4 oeufs alors que le server 3 seulement. Le Client a spawné 1 qui n'était pas normal
        ===> y'a-t-il le tick delay a reglé plus finement comme cela a été fait pour les bombes ?
        ===> GOC_Animator2D semble etre bloqué sur le SpawnEntity en continue.
        ====> ajout de ANIMATOR_ENDTHRESHOLD dans GOC_Animator2D::CheckAnim qui permet de stopper l'animation quand tres proche de la fin car rien n'empeche AnimatedSprite2D de looper sans prevenir de la fin de l'animation.
        =====> OK : cela regle le probleme de spawn
        ===> RAF : avant d'utiliser NetSpawnEntity, il faudrait verifier si le spawnid est dejà utiliser, ce qui signifie qu'un node a déjà été spawné en local et est en cours d'utilisation

    ✔ 31/01/2024 : remodification de Map::AddEntity pour le netspawning. car pas de possibilité de spawner 2 fois le meme nodeid que l'on a tuer/restaurer entre les deux spawns.
        -> OK : passer obligatoirement par GameNetwork::AddSpawnControl qui incremente le spawnstamp.

    ☐ 22/01/2024 : les objets deposés au sol par un netplayer disparaissent de la map lorsque l'avatar est éloigné de l'objet
        => cela doit etre du à la gestion de la visiblité des entités ...
        => le probleme c'est que le setenabled des objets du client va s'appliquer à l'ensemble des autres clients/server ...
        ==> solution temporaire : seuls les controller pourront etre setenabled par le network => modification dans GameNetwork::UpdateControl()
            donc les objet collectable dropper de l'inventaire seront toujours visible
            par contre un familier ça ne marchera plus...

    ☐ 22/01/2024 : les blocks de fermeture des zone de boss s'ils sont detruits par un netplayer doit etre repercuté sur le reseau.

    ✔ 30/01/2024 : Adapter GOC_Portal pour accepter les Net_Player
        -> OK : coté server pas besoin de viewport ni de GoToMap ... les nodes doivent bien etre teleporté pour la reactivation des nodes.
            Attention : Si les avatars restent desactivés alors TravelerNodeInfo ne pourront etre mise à jour.

    ✔ 30/01/2024 : il arrive qu'une entity "carré bleu" (surface non définie) soit spawnée coté client à la mort d'un monstre
        -> il s'agit d'une CollectablePart vide
        => LOG coté client
        [Tue Jan 30 10:15:15 2024] ERROR: GameNetwork() - NetSpawnEntity : clientid=1 ... spawnid=33571772(holderid=16794556,spawnstamp=2) posreceived=1876.17,1539.12 oinfo=0 ...
        [Tue Jan 30 10:15:15 2024] INFO: GameNetwork() - NetAddEntity : got=CollectablePart(3802457751) ... serverNodeID=16785539 clientNodeID=0 ...
        [Tue Jan 30 10:15:15 2024] INFO: World2D() - SpawnEntity : id=16785539 got=CollectablePart(3802457751) effectiveType=CollectablePart(3802457751) position=1876.17 1539.12 mpoint=22 18 viewZ=100 deferredAdd=false
        [Tue Jan 30 10:15:15 2024] INFO: Map() - AddEntity : node=CollectablePart(16785539) entityid=0 mPoint=22 18 spawn at 1876.17 1539.12 slotdata=0 ...
        [Tue Jan 30 10:15:15 2024] INFO: World2D() - HandleObjectAppear : GO APPEAR node=CollectablePart(16785539) type=0 mpoint=22 18 viewZ=100 entitiesInMap=594
        [Tue Jan 30 10:15:15 2024] INFO: World2D() - NetSpawnEntity : Node=CollectablePart(16785539) spawned dir=0 rot=0 velx=0... OK !
        [Tue Jan 30 10:15:15 2024] INFO: GameNetwork() - NetAddEntity : got=CollectablePart(3802457751) ... node=CollectablePart(16785539) enable=true !
        [Tue Jan 30 10:15:15 2024] ERROR: GameNetwork() - NetSpawnEntity : clientid=1 node=CollectablePart(16785539) ... pos=1876.17,1539.12 spawnid=33571772(holderid=16794556,spawnstamp=2) ... new oinfo=3530517296 holderptr=3933042400(nodeid=16794556,clientid=0) !
        [Tue Jan 30 10:15:15 2024] INFO: GameNetwork() - LinkSpawnControl : oinfo=3530517296 from clientid=0 spawnid=33571772 links serverNodeID_=16785539 clientNodeID_=16785539 !
        => LOG coté server
        [Tue Jan 30 10:15:15 2024] INFO: GOC_Inventory() - HandleDrop :  Node=GOT_Vampire(16794556) drops all slots !
        [Tue Jan 30 10:15:15 2024] INFO: GameHelpers() - GetDropPoint : holder=GOT_Vampire(16794556) position=1876.17 1538.62 1876.17 1539.12 !
        [Tue Jan 30 10:15:15 2024] INFO: GOC_Collectable() - DropSlotFrom : type=ElsarionMeat(1591862966) qty=4 on viewZ=100 droppoint=1876.17 1539.12 ...
        [Tue Jan 30 10:15:15 2024] INFO: World2D() - SpawnEntity : id=0 got=ElsarionMeat(1591862966) effectiveType=ElsarionMeat(1591862966) position=1876.17 1539.12 mpoint=22 18 viewZ=100 deferredAdd=false
        [Tue Jan 30 10:15:15 2024] INFO: Map() - AddEntity : node=CollectablePart(16785539) entityid=0 mPoint=22 18 spawn at 1876.17 1539.12 slotdata=494527488 ...
        [Tue Jan 30 10:15:15 2024] INFO: GameHelpers() - SetCollectableProperties : got=ElsarionMeat(1591862966) sprite=671259728 qty=4 ispart=true
        [Tue Jan 30 10:15:15 2024] INFO: World2D() - HandleObjectAppear : GO APPEAR node=ElsarionMeat(16785539) type=0 mpoint=22 18 viewZ=100 entitiesInMap=593
        [Tue Jan 30 10:15:15 2024] INFO: GameNetwork() - AddSpawnControl : ServerControl node=ElsarionMeat(16785539) ... spawnid=33571772(holderid=16794556,spawnstamp=2) ...
        [Tue Jan 30 10:15:15 2024] INFO: GameNetwork() - AddSpawnControl : ... new oinfo=558238544 srvnodeid=16785539 cltnodeid=0 holderptr=933809760(nodeid=16794556,clientid=0) spawnstamp=2 !
        [Tue Jan 30 10:15:15 2024] INFO: Map() - AddEntity : mPoint=22 18 nodeid=16785539 type=ElsarionMeat(1591862966) entityid=0 at 1876.17 1539.12 viewZ=100 sceneInfo.skipNetSpawn_=false ... OK !
        [Tue Jan 30 10:15:15 2024] INFO: Map() - AddEntity : mPoint=22 18 modeid=1 nodeid=16785539 type=ElsarionMeat(1591862966) entityid=0 at 1876.17 1539.12 viewZ=100 zindex=1000 netusage=true ... OK !
        [Tue Jan 30 10:15:15 2024] INFO: GOC_Collectable() - DropSlotFrom : type=ElsarionMeat(1591862966) nodeid=16785539 qty=4 ... OK !
        => il s'agit d'elsarion meat, le slotdata ne passe pas par netspawing ?
        ==> les ObjectControls sont petits et ne disposent pas de données permettant le stockage de slotdata
        ===> il faudrait que le drop de collectable passe toujours par un ObjectCommand (ne soit jamais Netspawné).
        ===> verifier GOC_Inventory::HandleDrop ... GOC_Collectable::DropSlotFrom
        ====> OK : utilisation de l'ObjectCommand ADDCOLLECTABLE dans GOC_Collectable::DropSlotFrom, seul le server envoit MAP_ADDCOLLECTABLE.
        ====> A-t-on un cas d'utilisation de MAP_ADDCOLLECTABLE pour le client ?
        ===> probleme avec GOC_DropZone avec EliegorSeed par exemple : coté client, elle va etre spawnée deux fois
            une par SpawnCollectable lancé par ObjectCommand ADDCOLLECTABLE qui provient sur server,
            et l'autre en local par GOC_DropZone::HandleThrowOutItems.
        ====> OK : suppression du netspawning pour GOC_Collectable::DropSlotFrom

    ✔ 28/01/2024 : mettre la possibilité du Repop en mode World comme en Arena.
        -> OK : modification de PlayState::CheckGameLogic()

    ✔ 28/01/2024 : en quittant le world et en revenant, il y a parfois
        un probleme de reactivation du netplayer sur le serveur
        -> il est possible que ce soit un pb lié au Unstuck
        ==> RAF : celui-ci à été corriger : vérifier si le probleme ne reapparait pas.

    ✔ 27/01/2024 : En world, lorsque un avatar client meurt, il ne peut pas repoper  ...
        -> si il deconnecte de la partie et la relance, le client peut rester bloquer sur le splashscreen
        --> s'il arrive à se connecter, les entités tuées réapparaissent.
        ---> cf Server_SendWorldObjects et Client_SetWorldObjects
        ===> en supprimant Server_SendWorldObjects cela enleve le probleme mais les eliagorseed popper sur le serveur, n'apparaissent plus chez le client.
        ===> OK : garder et modifier Server_SendWorldObjects pour eviter que les entités mortes soient ajoutées.

    ✔ 25/01/2024 : en activant les pertes de paquets, le server est bloqué à l'état 6 (Synchronizing) et les clients aussi
        -> le server n'a pas reçu l'état ready d'un des clients ?
        --> le server envoit bien l'etat 9 (Running), les clients n'ont pas l'air de le recevoir
        --> verifier statusStamp
        --> il semble que rien ne passe, le NetSimulator ne semble pas fonctionner
        ===> SLikeNet RakNet version 4.082 (RakPeerInterface::ApplyNetworkSimulator Note : Doesn't work past version 3.6201)
        ===> on peut simuler avec netem sous linux
        ===> commande xterm à lancer pour configurer le loopback : https://man7.org/linux/man-pages/man8/tc-netem.8.html
            sudo tc qdisc add dev lo root netem loss 20% delay 200
            sudo tc qdisc add dev enp7s0 root netem loss 20% delay 200
            pour annuler :
            sudo tc qdisc del dev lo root netem
            sudo tc qdisc del dev enp7s0 root netem
        ===> à terme prendre LibDataChannel comme rbfx
        ===> à partir d'un autre pc, il est egalement impossible de lancer la partie ... il y a bien un pb dans le code.
        ====> reactiver le netsimulator et refaire des tests avec juste 1 client
        =====> differents correctif appliqués : c'est toujours aussi lent mais ça se lance quand meme.
        =====> le probleme principal c'est l'envoi/reception des GameStatus. Ensuite les ObjecCommand qui demandent des Ack sont aussi assez lent.
        =====> OK : remplacer SendRemoteEvent pour l'envoi des GameStatus par un ObjectCommand (qui permet le renvoit des packets donc plus sur).
        =====> OK : on peut simplifier ApplyReceivedGameStatus et enlever le statusStamp.

    ☐ 07/12/2023 : il faut envoyer les equipments pour les entity ajoutées via NetSpawning
        -> 23/01/2014 : via l'editeur en server, les equipments des skeletons ne sont pas settés coté client ...
            => l'entityid n'est pas communiqué mais doit etre necessaire pour GameHelpers::SetEntityVariation
        -> utiliser coté server envoyé la commande SETFULLEQUIPMENT, à reception les clients utiliseront GOC_Inventory::NetClientSetEquipment.
        => il faut creer une procedure pour recuperer les equipments des entity si pas player.
        ==> il suffit lors du randomize equipment dans GameHelpers::SetEntityVariation de sauvegarder l'equipment généré dans GOC_Inventory::clientEquipmentSets_
        ==> ajout de GOC_Inventory::NetServerSaveEquipment et NetServerSendEquipment et ajout de GOC_Inventory::NetClientSetEquipment dans Map::SetEntities_Load
        ===> il n'y a plus de besoin d'utiliser les procedures precedentes si l'on change le randomize en s'appuyant uniquement sur le servernodeid comme seed
             il faut juste s'assurer que dans Map::SetEntities_Load on utilise le bon entityid. ce n'est pas encore au point ... il faudrait pouvoir le communiquer autrement que dans EntityData qui n'est pas forcement à jour.
        ====> probleme resolu : on utilisera la var GOA::ENTITYDATAID dejà utilisé pour les furnitures.
              lors du Map::SetEntities_Add, les EntityData sont déjà créées à la génération du monde (cf ). Il suffit alors de lier le node créé avec l'index de l'EntityData grace à la var.
              Il sera ensuite possible pour Map::SetEntities_Load de reprendre l'EntityData et la valeur sstype_ importante pour entityid.
        ====> pour le moment Map::AddEntity n'utilise pas cette technique car on ne crée pas encore d'EntityData avec la procedure : il suffit d'ajout mapData_->AddEntityData(node) mais voir l'incidence...
              les entities ainsi créée ne pourront etre rechargé avec Map::SetEntities_Load mais pas de variation en local.
              en reseau, SetEntityVariation peut néanmoins etre utilisé car l'entityid est sauvegardé dans GOC_Controller::control_.entityid_ qui est répliquable.
        ======> pour resoudre le probleme en localmode, il faudrait créer un attribut entityid dans l'un des composants.

    ✔ 22/01/2024 : vu en arenazone les inventaires/coffres en network @done(24-01-23 13:34)
        -> refaire des essais : dropper des objets puis ramasser des objets puis prendre des coffres
        --> probleme de transfer d'item entre collectable et inventaire suite aux modifications sur GOC_Inventory (les nodeid sont remplacé par ObjectControlInfo dans GameNetwork::Client_TransferItem)
        ==> si l'ObjectControlInfo est supprimé avant le transfert alors il y a un pb. C'est ce qui se passe à priori.
        ===> cela provient de l'ordre de preparation des packets dans GameNetwork::HandlePlayServer_NetworkUpdate qui priorise les packets server commun et ensuite les packets specific
        ====> la cmd EraseNode qui est broadcasté passe avant le TransfertItem qui est spécific à un client.
            de façon temporaire, privilégier les packet specific, ça résoud localement mais ca peut generer de nouveau probleme.
        ====> ajouter un numero d'ordre de commande. A la reception ne commencer à appliquer les commandes reçu que si la precedente est déjà appliquée ou que cmdid=0.
        => il y a encore des problemes : le tampon ne peut pas toujours recuperer une sequence d'id de commandes qui se suivent
        ==> ceci est du aux commandes specifiques qui ne sont pas envoyées aux autres clients et créent donc des trous dans la séquence.
        ==> changement de code : utilisation  de packet specifique pour l'envoi aux clients des que le sender n'est pas le server et on complete par des commandes vides aux besoins sur les commandes specifiques envoyées qu'à un client.

    ✔ 22/01/2024 : Lorsque'un netplayer meurt et repop, GOC_Destroyer ne fait plus d'update de position : ce qui occasionne des pbs de bosszone notamment
        => correctif lors de la reactivation dans GameNetwork::UpdateControl(), il faut bien reactivé destroyer->SetEnablePositionUpdate(true)

    ✔ 17/01/2024 : crash du serveur avec 2 clients : en spawnant plus de 255 lames avec le premier client puis en reiterant avec le second.
        -> crash dans GameNetwork::PushObjectCommand : probleme de saturation de la pool d'objectcommand
        ==> OK : il faut pouvoir liberer la pool quand c'est necessaire. Restauration entiere de la Pool objCmdPool_ pour le serveur. Restauration par element pour le client.

    ✔ 13/01/2024 : il y a des problemes de spawn des lames en arena si server+client + entities enable.
        -> les lames ne poppent pas forcement au debut. Est-ce une saturation ?
        -> apres un certain nombre de spawn, il arrive un crashboucle infinie ?
        => OK : la boucle infinie provient de GameNetwork::HandlePlayClient_ReceiveCommands() lorsque head > 255, il repasse à 0 mais tant que le state est APPLIED ça boucle sans fin -> correctif
        --> implique ensuite un pb coté serveur : resend continu des packets car le deltapackets devient tres grand.
            [Tue Jan 16 10:46:33 2024] INFO: GameNetwork() - HandlePlayServer_NetworkUpdate : objcmd=0 clientid=1 numCmdPackets=1 deltapackets=0 sendbuffer.Size()=30
            [Tue Jan 16 10:46:33 2024] INFO: GameNetwork() - HandlePlayServer_NetworkUpdate : objcmd=0 clientid=1 numCmdPackets=1 deltapackets=65280 sendbuffer.Size()=30
            Connection::GetDeltaObjectCommandPackets() renvoit un int, il doit y avoir une confusion entre les stampAck envoyés/recus dans Connection (qui sont des shorts) et les Stamp des ObjectCommand (qui sont des bytes)
        ==> OK : lorsque la boucle arrive à 255 -> 0 : nettoyage des ObjectCommand Packet => PACKET_CLEARED.
        ---> autre probleme lié surement au SpawnStamp (ObjectControl) : des que spawnstamp 255 -> 0, les lames n'apparaissent plus de façon correcte. Comme si elle apparaissent trop tard et s'effacent rapidement.
            [Wed Jan 17 16:04:00 2024] ERROR: GameNetwork() - NetSpawnEntity : clientid=0 ... spawnid=4261412922(holderid=16777274,spawnstamp=254) posreceived=22.42,13.32...
            [Wed Jan 17 16:04:00 2024] INFO: GameNetwork() - NetAddEntity : got=ABI_Shooter(3976370133) ... serverNodeID=16807488 clientNodeID=16807488 ...
            [Wed Jan 17 16:04:00 2024] INFO: Ability() - Use (static) holder=Player_5(16777274-clientid=1) node=TA(16807488) faction=257 pos=22.42,13.32 dir=1.00 rot=53.29 mode=local
            [Wed Jan 17 16:04:00 2024] INFO: GameNetwork() - NetAddEntity : got=ABI_Shooter(3976370133) ... node=TA(16807488) enable=true !
            [Wed Jan 17 16:04:00 2024] ERROR: GameNetwork() - NetSpawnEntity : clientid=0 node=TA(16807488) ... pos=22.42,13.32 spawnid=4261412922(holderid=16777274,spawnstamp=254) ...  oinfo=1163022624 holderptr=1127566464(nodeid=16777274,clientid=1) !
            ...
            [Wed Jan 17 16:04:03 2024] ERROR: GameNetwork() - NetSpawnEntity : clientid=0 node=TA(16807489) ... pos=22.42,13.32 spawnid=4278190138(holderid=16777274,spawnstamp=255) ...  oinfo=1163022912 holderptr=1127566464(nodeid=16777274,clientid=1) !
            ...
            [Wed Jan 17 16:04:09 2024] ERROR: GameNetwork() - NetSpawnEntity : clientid=0 node=TA(16807475) ... pos=22.42,13.32 spawnid=16777274(holderid=16777274,spawnstamp=1) ...  oinfo=1163018880 holderptr=1127566464(nodeid=16777274,clientid=1) !
            ...
            [Wed Jan 17 16:04:12 2024] ERROR: GameNetwork() - NetSpawnEntity : clientid=0 node=TA(16807476) ... pos=22.94,21.03 spawnid=16777274(holderid=16777274,spawnstamp=1) ...  oinfo=1163018880 holderptr=1127566464(nodeid=16777274,clientid=1) !
            ...
            [Wed Jan 17 16:04:15 2024] ERROR: GameNetwork() - NetSpawnEntity : clientid=0 node=TA(16807477) ... pos=22.94,21.03 spawnid=33554490(holderid=16777274,spawnstamp=2) ...  oinfo=1163018880 holderptr=1127566464(nodeid=16777274,clientid=1) !
            il apparait que le meme objectControlInfo est ensuite utilisé !
        ===> OK : un decalage se crée avec le spawnstamp=1 qui est utilisé deux fois de suite. Cela a surement un impact.
            modification de GameNetwork::AddSpawnControl pour eviter que localstamp ne soit egal à 0. (ce qui evite de generer deux spawnstamp=1)

    ✔ 12/01/2024 : Régler le probleme de synchro Time/Weather client/serveur
        -> probleme d'horaire de spawn de la pluie : cf le randomize dans WeatherManager
        ==> ajout d'un nouveau Rand : WEATHERRAND car OBJRAND est déjà utiliser par les Biomes, les Entity etc... donc tres aleatoire.
        ==> autre methode non utilisé : envoyer un NetMessage.

     ✔ 07/12/2023 : les bosszones ne fonctionnent pas en reseau
        => modification de ZoneData::GetNumPlayersInside()
        --> si un client n'est pas dans la meme map et qu'il arrive ensuite, le boss n'est pas à la bonne echelle ... n'est pas considerer comme boss et repop d'un nouveau.
        ===> gestion locale meme coté client : ajout de GameNetwork::GetNetPlayersNodes(), pop du boss (Client : attente de la reception du zonedata.nodeid_ envoyé par le serveur)
        ====> ajout ObjectCommand UPDATEZONEDATA
        ===> OK : modification de ZoneData::GetNumPlayersInside() pour ajouter pour le mode Client, les Netplayers.
        ===> OK : mettre la gestion des Zones dans World2D.
        ===> verifier pour la destruction du boss et l'apparition du coffre si ok en reseau.
        ====> OK : modification du Spawning Map::AddEntity et ObjectPool::CreateChildIn pour gerer le mode outpool, pour les Boss (no NetSpawning : utilise le nodeid obtenu dans zonedata.nodeid_) et les Chest (Netspawning)
        ====> OK : la barre de vie du boss ne doit s'afficher que si le joueur est dans la zone, gerer la life bar sur plusieurs viewports.
        ===> 22/01/2024 OK : en passant en mode editeur, les EffectActions running semblent etre effacés : ne pas inclure EffectAction::Clear() dans EffectsManager::Stop()

    ✔ 12/01/2024 : lorsque le player meurt, ensuite repop, il y a la perte du NodeTravelerInfo coté serveur @done(24-01-12 17:23)
        -> Player::Stop utilise World2D::RemoveTraveler, etant donner que dans Player::Start on n'utilise pas World2D::AddTraveler, il faut le supprimer

    ✔ 28/12/2023 : coté client, lors du changement de map, les entités sauvegardées dans MapData et reinstanciées ne sont pas liés automatiquement à un ObjectControl au serveur. @done(24-01-19 08:44)
        -> c'est le cas pour les eliegorseeds (à priori elles ne sont pas netspawnable. Rappel: netspawnable == créé coté client via la reception d'un ObjectControl).
        => avec un gobelin (qui est netspawnable), cela fonctionne correctement.
        -> le NetSpawning n'est possible que si les compteurs de spawn entre client et serveur sont synchronisés (localSpawnStamps_ et receivedSpawnStamps_).
        => Ils ne peuvent pas l'être si coté client une map n'est pas chargée/générée : A verifier !
        -> de plus ces compteurs sont globaux (non lié à une map).
        => ces compteurs doivent donc etre incrementé en dehors du processus de creation de node par les maps
        ==> ils sont uniquement modifié dans GameNetwork::NetSpawnEntity et GameNetwork::AddSpawnControl
        -> en mode reseau hors NetSpawning, les nodeids ne doivent etre pris que par le server, les clients recuperent les nodesids (processus de chargement de map avec mapdata)
           sur le serveur, le chargement de map avec mapdata ne devra pas tenir compte des nodeids sauvegardés dans mapdata qui ne sont que pour les clients.

        ✔ 06/01/2024 : coté client, au chargement d'une mapdata, il faut obtenir du serveur les nodeids des entités à instancier @done(24-01-12 14:35)
            -> autrement, les entities Non NetSpawnable instanciés peuvent avoir un id different de ceux du serveur et ne seront pas ou mal lié au bon node du serveur (car pas ou mauvais ObjectControl trouvé).
            ==> coté client, il doit s'appuyer sur les nodeids qui devront etre inclus dans MapData pour instancier les entities avec les bons nodeids.
                il faut bien verifier que dans ObjectPool, les id des nodes soient bien modifiables meme pour les id local.
                Remarque : lorsqu'ils sont dans le pool, les nodes n'auraient pas besoin d'avoir de node id attribué par la scene.
                           ils le sont car une reservation de node dans la scene est faite et cela permet de gagner du temps par la suite (ne pas reattribuer de numero).
                il faut bien verifier si dans ObjectPool l'on peut prendre un object avec un numero specifique. (a priori oui)
                Remarque : Etant donné que l'on n'utilise pas la replication de scene, on peut simplifier Urho3D::Connection et Urho3D::Network.
                et fusionner toute la plage des ids Local et Raplicated pour segmenter les ids par map (utile pour les objets static fixe).
                les entités dynamique qui peuvent se déplacer (donc changer de map) auraient une plage spécifique aussi.
            ==> pour communiquer le nodeid dans MapData il faut soit modifier EntityData qui va augmenter sa taille mémoire de 1uint : soit au total 3 uint
                soit créer dans MapData, un nouveau tableau contenant les nodeids pour MapData::entities_ et MapData::furnitures_, modification de la serialization, utilisation de ce tableau dans SetEntities_Load.
            ===> création de MapData::entitiesIds_ qui a la meme dimension que MapData::entitiesAttr_ et à l'instar de ce dernier est également créé dans Map::OnUpdateMapData

        ✔ 12/01/2024 : les Entités dynamique comme les monstres n'apparaissent pas dans les entitiesAttr de MapData. Pourquoi ? @done(24-01-12 14:35)
            -> cela pose un gros probleme pour avoir la liste complet de entitiesIds mais aussi pour le chargement Map::SetEntities_Load qui sera par conséquent incomplet
            --> c'est le cas en testant dans World.
            --> verifier Map::OnUpdateMapData, World2D::AddEntity et World2D::RemoveEntity.
            ---> GOC_Destroyer n'utilise pas ces 2 procedures. via GOC_Destroyer::OnWorldEntityCreate, il envoit GO_APPEAR qui est recuperer par World2D::HandleObjectAppear qui ajoute le nodeid a la liste mapEntities
            --> il y a un pb dans Map::OnUpdateMapData à la ligne GOManager::IsA(nodeId, GO_Player | GO_AI_Ally)
                car les monstres vont etre considere comme player ou allié
            ===> patch de GOManager::IsA

        ✔ A eclaircir : Map::SetEntities_Load() s'occupe-t-elle de charger aussi les furnitures ?
            -> oui, en delegation de Map::SetFurnitures pour le cas des furnitures GOT_UsableFurniture (GOT_Portal : pour permettre la sauvegarde des attribut de GOC_Portal)
            ==> cela ne pose pas de probleme de creation redondante de furniture car prévue dans MapCreator::CreateMap -> Map::SetFurnitures (avec skip des GOT_UsableFurniture).
            ==> dans MapData::EntitiesAttr_ seules les entities et les furnitures qui sont GOT_UsableFurniture sont sauvegardées.
            -> suppression du define MAPDATA_SAVEFURNITURELIKEENTITIES qui ne sert plus à rien.

        ✔ 11/01/2024 : il faut resynchroniser les compteurs de NetSpawning @done(24-01-12 15:19)
            -> tout d'abord pourquoi GameNetwork::AddSpawnControl() est-il ajouté dans Map::SetEntities_Load() et Map::SetEntities_Add() ?
            --> si ct pour une tentative de synchronisation des compteurs, ce n'est pas le bon endroit : cette gestion devrait etre faite directement dans GameNetwork et dissocier de GameNetwork::AddSpawnControl
            --> ou bien ct pour retrouver ou creer un ObjectControl ... il faut donc tout d'abord savoir si un ObjectControl est nécessaire !
            ===> un ObjectControl pour ce node est necessaire lorsque l'on a besoin de synchroniser un node entre serveur et client : toutes les entités dynamiques.
            ===> Donc c'est nécessaire, pour les entities mais pas pour les furnitures.
            -> une fois Map::SetEntities_... finit, il faudrait simplement synchroniser les compteurs.
            ==> ajout de GameNetwork::ResyncSpawnControlStamps() et utilisation dans Map::SetEntities_Load

        ✔ 12/01/2024 : un probleme de link entre serveur/client à corriger :
            Dump coté client :.
            [Fri Jan 12 15:46:10 2024] INFO: MapData() - Load : this=3827583760 map=3842034320 ... read mpoint=24 19 width=64 height=64 seed=1639419 numviews=5 OK !
            [Fri Jan 12 15:46:10 2024] INFO: MapData() - Load : this=3827583760 mpoint=24 19 map=3842034320 ... read sid=MAPDATASECTION_FLUIDVALUE=2(2) num=2 compSize=43 decompSize=8192  ...
            [Fri Jan 12 15:46:10 2024] INFO: MapData() - Load : this=3827583760 mpoint=24 19 map=3842034320 ... read sid=MAPDATASECTION_SPOT=3(3) num=51 compSize=374 decompSize=1428  ...
            [Fri Jan 12 15:46:10 2024] INFO: MapData() - Load : this=3827583760 mpoint=24 19 map=3842034320 ... read sid=MAPDATASECTION_NODEIDS=5(5) num=1 compSize=5 decompSize=4  ...
            [Fri Jan 12 15:46:10 2024] INFO: MapData() - Load : this=3827583760 mpoint=24 19 map=3842034320 ... read sid=MAPDATASECTION_ENTITY=7(7) num=1 compSize=9 decompSize=8  ...
            [Fri Jan 12 15:46:10 2024] INFO: MapData() - Load : this=3827583760 mpoint=24 19 map=3842034320 ... read sid=MAPDATASECTION_ENTITYATTR=8(8) num=1 compSize=97 decompSize=108  ...
            ...
            [Fri Jan 12 15:46:10 2024] ERROR: Map() - SetEntities Load : Map=24 18 Entities[4/15] : reservedId=16792526 name=GOT_ShukTuk(16792526) position=2030.72 1531.66 enabled=false... OK !
            ...
            [Fri Jan 12 15:46:10 2024] INFO: GameNetwork() - LinkSpawnControl : oinfo=3146609600 from clientid=0 spawnid=1811939328 links serverNodeID_=16792526 clientNodeID_=16794280 !
            ...
            => Peut-etre faut-il supprimer le spawncontrol s'il existe, ou bien simplement creer un ObjectControl sans passer par SpawnControl dans Map::SetEntities_Add et Map::SetEntities_Load.
            ==> Remplacement du code autour de GameNetwork::AddSpawnControl() dans Map::SetEntities_Add et Map::SetEntities_Load, par GameNetwork::GetOrCreateObjectControl() etant donné que les nodeids server et client seront identiques dans ce cadre.
            => ResyncSpawnControlStamps est-il encore necessaire du coup ?

    ✔ 21/12/2023 : il faut activer les maps du server des qu'un joueur est dessus ou bien que toutes les maps server soient activées par défaut. @done(23-12-28 12:44)
        => coté Box2D ca va suivre ?
        => cote World2D il faut ajouter des nodes à suivre en plus des viewports, pour gérer le chargement/déchargement et la visibilité des maps.
        ==> 27/12/2023 : OK ajout de TravelerNodeInfo, WorldViewInfo devient TravelerViewportInfo
        ==> grosse modification dans World2D et MapStorage.
        ==> ajout d'un nouvel ObjectCommand REQUESTMAP qui permet au client de demander une mapdata.
        ==> coté server ces demandes sont stockées dans ClientInfo::maprequests_ et envoyé au client quand la mapdata est disponible.

    ✔ 21/12/2023 : sur un client qui se connecte apres les autres (le contenu des coffres a deja ete pris en partie),
                lorque ce client tente de prendre un coffre qui n'est pourtant pas vide, il ne va rien se passer.
                Les slots deja pris sont vides et le probleme se situe dans le SetInventory durant le lancement de partie du client
                qui va skipper ces slots du coup il n'y aura plus de correspondance de slotid entre les inventaires client et server lors du INVENTORY_GET -> Client_TransferItem
        => GOC_Inventory::SetInventoryAttr() skip les slots vides, creation d'une nouvelle version GOC_Inventory::SetSlots permettant de ne pas les skipper
        ==> utilisation de GOC_Inventory::SetSlots(VariantVector& , skip=false) dans GOC_Inventory::LoadInventory

    ✔ 16/12/2023 : separer Client_SetWorldObjects en 2 : l'un pour les serverobjects et l'un pour les mapdata
        -> les mapdata doivent etre setté pendant le LOADING (à la génération du monde)
        -> les serverobjects peuvent être settés plus tard.
        ==> OK : creation de Server_SendWorldMaps qui sera lancer et envoyer dans la phase de LOADING du client (cf HandleServer_MessagesFromClient)
        ==> OK : creation de Client_SetWorldMaps.
        ==> OK : modification de MapStorage::InitializeMap et MapCreator::CreateMap pour attendre la reception des MapDatas du server.
        ==> pour le mode World, il faut voir pour n'envoyer que les maps necessaire au client (dans son mapbuffer, ... quadrant)...
                   cf MapStorage::PushMapToLoad pour envoyer une nouvelle requete de MapData ? voir pour la gestion de ClientInfo::mapsDirty_ ...
        ===> OK utilisation de REQUESTMAP

    ✔ 15/12/2023 : demarrage automatique en PlayState le server si au moins un client envoie son état en PlayState
        -> OK : Demarrage en Arena par defaut, voir pour modifier ça par la suite

    ✔ 13/12/2023 : GOC_DropZone n'a pas le meme storage entre serveur et clients @done(23-12-15 09:07)
        plusieurs problemes surviennent alors :
        -> si un buildabletype est disponible coté serveur et que coté client il n'y a pas la part pour ce build,
            alors le pop se fera mais l'entity créée ne sera pas un follower de l'avatar client. donc pas de mount possible !
            -> cela arrive souvent quand un collectable tombe dans le dropzone (sanctuaire) mais que le server envoit l'ordre de destruction avant
            ==> on pourrait mettre une tempo sur la destruction
        -> si le trigger attack coté avatar client ne se déclenche pas (mais se déclenche coté server) alors on aura le meme resultat.
        => sur ce composant, pour le buildable, SpawnEntity est en mode NetSpawning (ObjectControl == passif);
           pour le throwItems, Collectable::DropSlotFrom=>SpawnEntity est en mode SkipNetSpawning (ObjectCommand == actif);
        ==> si serverMode, il faut envoyer un message indiquant le storage disponible pour le dropzone si le storage est modifié et le dernier ajout/suppression d'items.
        ==> le client verifie alors le storage, le modifie si besoin et spawn si besoin.
        ==> il faut donc envoyer pour le additem et le throwitem une netcommand pour mettre à jour le storage.
        ===> OK ajout de GOC_DropZone::NetClientUpdateStorage, NetCommand UPDATEITEMSSTORAGE et GameEvents GO_STORAGECHANGED
        ===> voir si on ne peut pas ameliorer l'envoi ... reduire la taille des messages ...

    ✔ 12/12/2023 : Monter une entité allié en reseau pose probleme @done(23-12-15 09:07)
        -> il y a un décalage énorme qui se crée qui est du à GameHelpers::SetPhysicProperties qui gère le positionnement local (pas World)
        -> lorsque le node est mis en enfant, le PrepareControl va envoyer des positions World ...
        ==> correctif dans PrepareControl, utiliser le Positionnement local
        ==> correctif dans PrepareControl et UpdateControl ne pas setter les positions si le node est monté sinon il y aura ce problème du à l'envoi/reception de positions alors que l'etat monté n'est pas encore repliquer.
        -> il faut communiquer le montage au second client, pour que le node soit accroché à la monture.
        ==> OK : le server envoit aux autres clients la netcommand MOUNTENTITYON, (ajout Client_MountNode)
        -> quand on est monté le changement d'avatar n'est pas répliqué coté client distant.
        ==> OK : modifier GOC_Controller::ChangeAvatar pour integrer le mount et unmount.
        ==> OK : Mettre la logique principal dans GOC_Controller pour eviter les doublons

    ✔ 12/12/2023 : le spawn de furniture coté server -> client est à implementer
        -> ajout de World2D::NetSpawnFurniture, modification Map::AddFurniture pour l'ajout de l'objectcontrol
        -> desactivation de l'Editeur si ClientMode
        --> le probleme : ca associe un ObjectControlInfo, ce que l'on ne veut pas pour des furnitures qui seront static.
        ---> utilisation de la NetCommand ADDFURNITURE
        ---> modification de furnitures.json: seules les furnitures marquées replicateMode=1 seront NetSpawnable

    ✔ 12/12/2023 : ajout du spawn de collectables : le drop d'item n'est pas suffisant, l'editeur a besoin d'un spawn specifique notamment pour les collectableparts @done(23-12-13 09:58)

    ✔ 12/12/2023 : coté client, le spawn d'eliegor seed pose probleme (c'est un exemple d'autres entités droppés par GOC_DropZone vont avoir ce probleme avec le storage initial)
        -> si le client n'a pas un état initial synchronisé avec le server (Snap Initial ok), alors coté client eliegorflower va spawner une graine que le server n'a plus en stock
        ==> OK 15/12/2023 : ajout dans le snap des storage des composants GOC_Inventory, GOC_DropZone.

    ✔ 07/12/2023 : ObjectControl : pb desynchronisation du spawnstamp @done(23-12-07 19:06)
        -> lorsqu'un objet est spawné et aussitot supprimé, la replication ne sera pas faite ce qui induit un décalage de spawnstamp
        ex : avec le drop d'une potion sur un Goblin qui vient de se faire occire
            il n'y a pas spawn de la potion coté client le spawnstamp server = 15 , le spawnstamp client = 14 (non apparent dans les logs) => décalage
        en fait il n'y a aucun spawn de collectable
        ==> correctif GOC_Collectable::DropSlotFrom pour permettre le netspawning quand c'est necessaire (autospawn)

    ✔ 07/12/2023 : Lors de l'ajout d'entités via l'editeur sur le serveur il faut que cela soit repercuter coté client @done(23-12-07 14:26)
        -> correctid dans Map::AddEntity(), si l'entity à un GOC_Controller il faut attribuer control_.type_, sinon le spawn ne peut se faire.
        --> attention il faudrait aussi attribuer entityid.

    ✔ 07/12/2023 : Ajout de l'UI pour la selection du mode reseau @done(23-12-07 14:26)
        -> en mode client, si server local => proposer de lancer un serveur s'il n'existe pas.
        --> pour cela un server Headless serait bienvenu.

    ☐ Server Graphics
        pouvoir choisir si on demarre avec un avatar ou pas. Par defaut aucun.
        lorsque la partie est finie (un seul survivant, ou bien temps écoulé (calcul des points), ou bien flag rapporté en fonction du mod de jeu),
        envoi du message de fin de partie à l'ensemble des clients.

    ☐ Server Headless
        L'engine n'aura plus les sous systeme Graphics et Renderer
        Suppression de l'UI, Sound, Input, Renderer2D
        quels impacts sur les composants de jeux utilisant Renderer2D, Renderer et Graphics.
        il ne doit rester que GameNetwork et PlayState (à modifier - aucun spawn de joueur locaux)

    ✔ 28/11/2023 : Pb ObjectCommand avec activation de NetSimulator @done(23-12-05 17:09)
        s'assurer que les ObjectCommands qui n'ont pas été reçu sont bien renvoyés
        il faut créer une pile d'ObjectCommands à envoyer.
        on doit pouvoir gérer
            un vector des ObjectCommands préparés et taggés par stamp
            un vector des stamps reçus (ack)
            les stamps manquants attendus
            les ObjectCommands préparés et envoyés dont le stamp est bien reçu peuvent être supprimées sinon doivent être réenvoyés.
            les ObjectCommands reçus et non taggés "InOrder" peuvent être executés.
            les ObjectCommands reçus et taggés "InOrder" sont executé quand ils arrivent en tête de séquence. la Tete de sequence correspond au stampAck qui est envoyé vers l'emetteur pour l'informer de la reception
            ce stamp ack est envoyé tant que le stamp reçu est égal à celui-ci
            si le stamp reçu est nouveau par rapport au stamp ack, le stamp ack est incrémenté jusqu'au prochain trou dans la séquence. et les ObjectCommands sont alors executés jusqu'à cette nouvelle Tete.
        => 4/12/2023 : gros refactor du ObjectCommand
        ==> les ObjectCommand sont préparé dans des ObjectCommandPacket puis envoyé via Connection
        ==> tant que les packets ne sont pas ACK reçus, ils sont renvoyés par l'emetteur
        ==> OK : il faut absolument que les stamps et ACK soient lié au client et non au serveur.
        ==> la synchronisation d'un client qui arrive en cours de partie
        ===> doit etre faite automatiquement si le CheckStamp montre une desyncro.
        ===> OK : correctif pour nettoyer la connection coté client qui retourne au MENU et coté serveur.

    ✔ 23/11/2023 : pb de desynchro des lames, des bombes etc... suite au derniere modification sur AddSpawnControl (DROPITEM-23/11/2023) @done(23-11-24 17:42)
        cf GOC_Destroyer::Destroy->Server_RemoveObject(node) qui était Server_RemoveObject(node,!node->isPoolNode_)
        cf Map::AddEntity->AddSpawnControl qui force le spawn en servercontrolled : dans le cas des lames et des bombes cela ne passe normalement pas par ici mais par Ability::Use
        LOG SERVER avatar main apres 15 spawn
            [Fri Nov 24 12:37:57 2023] INFO: Player() - HandleClic : ID=1 at 421 716
            [Fri Nov 24 12:37:57 2023] INFO: GameNetwork() - AddSpawnControl : ServerControl node=TA(16792836) ... spawnid=419430454(holderid=16777270,spawnstamp=25) ...
            [Fri Nov 24 12:37:57 2023] INFO: GameNetwork() - AddSpawnControl : ... new oinfo=2336413104 srvnodeid=16792836 cltnodeid=0 holderptr=2809938768(nodeid=16777270,clientid=0) spawnstamp=25 !
            [Fri Nov 24 12:37:57 2023] INFO: ABI_Shooter() - Use : pos=12.27,14.44 dir=-0.98,0.18 faction=1 viewZ=100
            [Fri Nov 24 12:37:59 2023] INFO: GOC_Destroyer() - Destroy : node=TA(16792836) ... enabled_=false delay=0.100000001490116 mode=FASTPOOLRESTORE ...
            [Fri Nov 24 12:37:59 2023] ERROR: GameNetwork() - PushObjectCommand : clientid=0(from:0) stamp=18(0) broadcast=true cmd=ERASENODE=1 nodeid=16792836 !
            [Fri Nov 24 12:37:59 2023] INFO: GameNetwork() - Server_RemoveObject : servernodeid=16792836 oinfo=2336413104 active=false clientnodeid=0 ... OK !
            ...
            [Fri Nov 24 12:38:07 2023] INFO: Player() - HandleClic : ID=1 at 894 239
            [Fri Nov 24 12:38:07 2023] INFO: GameNetwork() - AddSpawnControl : ServerControl node=TA(16792822) ... spawnid=436207670(holderid=16777270,spawnstamp=26) ...
            [Fri Nov 24 12:38:07 2023] INFO: GameNetwork() - AddSpawnControl : ...  oinfo=2336407616 srvnodeid=16792822 cltnodeid=0 holderptr=2809938768(nodeid=16777270,clientid=0) spawnstamp=26 !
            [Fri Nov 24 12:38:07 2023] INFO: ABI_Shooter() - Use : pos=9.94,14.67 dir=-0.09,1.00 faction=1 viewZ=100
            [Fri Nov 24 12:38:09 2023] INFO: GOC_Destroyer() - Destroy : node=TA(16792822) ... enabled_=false delay=0.100000001490116 mode=FASTPOOLRESTORE ...
            [Fri Nov 24 12:38:09 2023] ERROR: GameNetwork() - PushObjectCommand : clientid=0(from:0) stamp=19(0) broadcast=true cmd=ERASENODE=1 nodeid=16792822 !
            [Fri Nov 24 12:38:09 2023] INFO: GameNetwork() - Server_RemoveObject : servernodeid=16792822 oinfo=2336407616 active=false clientnodeid=0 ... OK !
        LOG CLIENT
            [Fri Nov 24 12:37:57 2023] INFO: GameNetwork() - HandlePlayClient_ReceiveServerUpdate : clientid=1 nodeclientid=0 servernodeid=16792836 oinfo=0 spawnid=419430454(holder=16777270,stamp=25) spawncontrol=false ... spawn entity ...
            [Fri Nov 24 12:37:57 2023] ERROR: GameNetwork() - NetSpawnEntity : clientid=1 ... spawnid=419430454(holderid=16777270,spawnstamp=25) posreceived=12.27,14.45...
            [Fri Nov 24 12:37:57 2023] INFO: GameNetwork() - NetAddEntity : got=ABI_Shooter(3976370133) ... serverNodeID=16792836 clientNodeID=0 ...
            [Fri Nov 24 12:37:57 2023] INFO: Ability() - Use (static) holder=avatar(16777270-clientid=0) node=TA(16792836) faction=1 pos=12.27,14.45 dir=0.00 rot=-10.47 mode=local
            [Fri Nov 24 12:37:57 2023] INFO: GameNetwork() - NetAddEntity : got=ABI_Shooter(3976370133) ... node=TA(16792836) enable=true !
            [Fri Nov 24 12:37:57 2023] ERROR: GameNetwork() - NetSpawnEntity : clientid=1 node=TA(16792836) ... pos=12.27,14.45 spawnid=419430454(holderid=16777270,spawnstamp=25) ... new oinfo=2329577960 holderptr=2844529248(nodeid=16777270,clientid=0) !
            [Fri Nov 24 12:37:57 2023] INFO: GameNetwork() - LinkSpawnControl : oinfo=2329577960 from clientid=0 spawnid=419430454 links serverNodeID_=16792836 clientNodeID_=16792836 !
            [Fri Nov 24 12:37:59 2023] INFO: GameNetwork() - HandlePlayClient_ReceiveServerUpdate : try ObjectCommand cmd=ERASENODE=1 for nodeid=16792836 broadcast=true cmdclientid=0 cmdstamp=18 serverObjCmdAck=17 test=true...
            [Fri Nov 24 12:37:59 2023] INFO: GameNetwork() - HandlePlayClient_ReceiveServerUpdate : apply ObjectCommand from clientid=0 cmdstamp=18 serverObjCmdAck=17 ... OK !
            [Fri Nov 24 12:37:59 2023] INFO: GameNetwork() - Client_ApplyObjectCommand : NET_OBJECTCOMMAND : cmd=(ERASENODE=1) nodeid=16792836 ...
            [Fri Nov 24 12:37:59 2023] INFO: GameNetwork() - Client_CommandRemoveObject : node=16792836 ...
            [Fri Nov 24 12:37:59 2023] INFO: GOC_Destroyer() - Destroy : node=TA(16792836) ... enabled_=false delay=0.100000001490116 mode=FASTPOOLRESTORE ...
            [Fri Nov 24 12:37:59 2023] INFO: GameNetwork() - Client_CommandRemoveObject : serverObjectControl id=16792836 inactived oldenable=1 enable=0 !
            ...
            [Fri Nov 24 12:38:07 2023] INFO: GameNetwork() - HandlePlayClient_ReceiveServerUpdate : clientid=1 nodeclientid=0 servernodeid=16792822 oinfo=2329572472 spawnid=184549430(holder=16777270,stamp=11) spawncontrol=true ... spawn entity ...
            [Fri Nov 24 12:38:07 2023] ERROR: GameNetwork() - NetSpawnEntity : clientid=1 ... spawnid=184549430(holderid=16777270,spawnstamp=11) posreceived=12.27,14.44...
            [Fri Nov 24 12:38:07 2023] INFO: GameNetwork() - NetAddEntity : got=ABI_Shooter(3976370133) ... serverNodeID=16792822 clientNodeID=16792822 ...
            [Fri Nov 24 12:38:07 2023] INFO: Ability() - Use (static) holder=avatar(16777270-clientid=0) node=TA(16792822) faction=1 pos=12.27,14.44 dir=0.00 rot=-8.38 mode=local
            [Fri Nov 24 12:38:07 2023] INFO: GameNetwork() - NetAddEntity : got=ABI_Shooter(3976370133) ... node=TA(16792822) enable=true !
            [Fri Nov 24 12:38:07 2023] ERROR: GameNetwork() - NetSpawnEntity : clientid=1 node=TA(16792822) ... pos=12.27,14.44 spawnid=184549430(holderid=16777270,spawnstamp=11) ...  oinfo=2329572472 holderptr=2844529248(nodeid=16777270,clientid=0) !
            [Fri Nov 24 12:38:09 2023] INFO: GOC_Destroyer() - Destroy : node=TA(16792822) ... enabled_=false delay=0.100000001490116 mode=FASTPOOLRESTORE ...
            [Fri Nov 24 12:38:09 2023] INFO: GameNetwork() - HandlePlayClient_ReceiveServerUpdate : try ObjectCommand cmd=ERASENODE=1 for nodeid=16792822 broadcast=true cmdclientid=0 cmdstamp=19 serverObjCmdAck=18 test=true...
            [Fri Nov 24 12:38:09 2023] INFO: GameNetwork() - HandlePlayClient_ReceiveServerUpdate : apply ObjectCommand from clientid=0 cmdstamp=19 serverObjCmdAck=18 ... OK !
            [Fri Nov 24 12:38:09 2023] INFO: GameNetwork() - Client_ApplyObjectCommand : NET_OBJECTCOMMAND : cmd=(ERASENODE=1) nodeid=16792822 ...
            [Fri Nov 24 12:38:09 2023] INFO: GameNetwork() - Client_CommandRemoveObject : node=16792822 ...
            [Fri Nov 24 12:38:09 2023] INFO: GameNetwork() - Client_CommandRemoveObject : serverObjectControl id=16792822 inactived oldenable=1 enable=0 !
        1ere remarque : il n'est pas necessaire que le serveur envoit ERASENODE pour les objects qui ont un temps de vie fixé. (Lame, Bombe etc...)
        2eme remarque : la consommation en objectcontrol va etre importante, il faut penser à un pool d'objectcontrol.
        sur les lames (15 lames de qty de pool), pb de position,rotation lors du spawn apres les 15 premieres lame ... cela reprend la position des premiers pop
            il n'y a pas le meme spawnid, le spawnstamp different. juste avant la 16 lame spawné cela se passe bien.
            le server reutilise un ObjectControlInfo mais avec spawnstamp changé => le client reprend un ObjectControlInfo dans spawnControls_
            => cela vient de la reception, en desactivant ACTIVE_PACKEDOBJECTCONTROL, on retrouve le bon spawnid.
            ==> correctif pour s'assurer que le control est bien packé (faire le Pack dans Write).
        pour les Bombes, le probleme provient de l'animation qui va lancer parfois plusieurs bombes sur le main mais pas sur les remotes.
            => il se crée un décalage de spawnstamp : le spawnstamp est pris localement. Il n'y aura pas de synchro faite
            ==> des essais ont du etre fait (je me rappelle plus trop) avec localStamps_ et receivedStamps_ mais cela ne marchera pas avec les spawnstamp qui sont spécifiquement lié à un holderid.
            => la correction de synchro est faite pour junkelspil en modifiant le tick. l'animation spawn l'entityBomb vers 400 et l'animation fait 600.
                pour eviter la repetition de spawn mettre le tick à 0.6. prise d'un nouveau animatortemplate FlyAttackerJ.
            => pour le spawn avec le clic souris, il y a toujours pb de spawn (avec la touche attaque pas de pb) coté remote
            ==> le clic n'est pas envoyer coté remote
            ===> le remote doit recevoir le changement de state ainsi que la direction de spawn.
                il faut AddSpawnControl comme les lames (NetSpawnAllow=true) avec changement d'animation en STATE_ATTACK et intterdiction pour GOC_Animator de spawner une bombe dans ce cas.
            ====> OK : ajout de GOC_Animator2D::SetSpawnEntityMode(), et modification de Ability::Use(static) => ajout holder->SetSpawnEntityMode(SPAWNENTITY_SKIPONCE).

    ✔ 21/11/2023 : lors d'un retour au menu pour un client et retour en jeu, le changement d'equipment n'est plus repercuté sur le serveur ni sur les autres clients @done(23-11-21 15:38)
        coté client lors de la reconnexion, il y a Reset de ObjCmdAck
            Client LOG
            [Tue Nov 21 14:27:24 2023] ERROR: GameNetwork() - PushObjectCommand : clientid=2(from:2) stamp=1(0) broadcast=true cmd=UPDATEEQUIPMENT=8 nodeid=16777278 !
            [Tue Nov 21 14:27:24 2023] INFO: Equipment() - UpdateAttributes index=1 ...
            [Tue Nov 21 14:27:24 2023] INFO: Equipment() - UpdateAttributes index=1 ... OK !
            [Tue Nov 21 14:27:24 2023] INFO: Equipment() - GetEquipmentValue : index=1 attribut=GOA_Life(3913190914) item=LargeSwordFlame => return Variant type=3
            [Tue Nov 21 14:27:24 2023] ERROR: GameHelpers() - SetUIElementFrom : elt= sprite=effect4(692837b0) texture=69075010
            [Tue Nov 21 14:27:24 2023] INFO: GameNetwork() - CleanObjectCommands : clean ObjectCommand[2081012256] clientid=2 cmd=UPDATEEQUIPMENT=8 cmdstamp=1 oldestObjectCmdAck=1 ... OK !
            => la commande est nettoyée avant d'etre envoyée.
        => sur le client synchroniser ClientObjCmdAck, ClientObjCmd avec le serveur.
        ==> OK : ajout de Connection::SynchronizeObjectCommands() a utilisé au lancement de partie coté client.

    ✔ 20/11/2023 : lorsque l'on deconnecte tous les clients et le serveur d'une partie et que l'on relance une nouvelle partie crash sur clients @done(23-11-20 16:03)
        sur le client, NetClientSetEquipment va crasher à cause de clientNodes_ qui n'a pas été effacé.
        => en fin de partie, nettoyer GOC_Inventory
        ==> Ok : ajout de GOC_Inventory::ClearCache()

    ✔ 20/11/2023 : lors du lancement d'une partie arena les avatars client distant poppent avant les joueurs locaux @done(23-11-20 19:34)
        voir le processus de NetSpawning, si le node est enable directement.
        => provient de HandlePlayClient_ReceiveServerUpdate dans l'utilisation de allowHotAcces_ qui force ensuite ObjectControl::SetEnable(true) qui rend le node enable.
        ==> allowHotAcces_ reste à faire, suppression de ObjectControl::SetEnable(true) dans cette partie de code de HandlePlayClient_ReceiveServerUpdate
        ==> allowHotAcces_ ne doit etre actif que si tous les clients sont running. ne pas activer pour le moment

    ✔ 20/11/2023 : la deconnection d'un client ne fait pas disparaitre l'avatar chez les autres clients @done(23-11-21 13:55)
        pour le serveur ca fonctionne
        => les ObjectControls sur le serveur sont peut-etre desactivé des la deconnection et ne sont plus transmis vers les autres clients ?
        ==> dans ce cas, il faut envoyer un ordre PushObjectCommand(ERASENODE, broadcast, clientid)
        ==> c'est le cas, mais il y a un pb de ObjCmdAck ...
            Server LOG
            [Mon Nov 20 21:43:06 2023] INFO: GameNetwork() - HandlePlayServer_NetworkUpdate : send ObjectCommand cmd=ERASENODE=1 for nodeid=16777278 to specific clientid=1 broadcast=true cmdclientid=2 cmdstamp=5 serverObjCmdAck=4 test=true...
            [Mon Nov 20 21:43:06 2023] INFO: GameNetwork() - HandlePlayServer_NetworkUpdate : send ObjectCommand cmd=ERASENODE=1 for nodeid=16777278 to specific clientid=1 broadcast=true cmdclientid=2 cmdstamp=5 serverObjCmd=4 serverObjCmdAck=4 !
            [Mon Nov 20 21:43:06 2023] INFO: GameNetwork() - HandlePlayServer_NetworkUpdate : send ObjectCommand cmd=ERASENODE=1 for nodeid=16777278 to specific clientid=1 broadcast=true cmdclientid=2 cmdstamp=5 serverObjCmdAck=5 test=false...
            ==> le premiere commande passe, ensuite boucle resend perpetuelle pour cette commande.
            Client LOG
            [Mon Nov 20 21:43:06 2023] INFO: GameNetwork() - HandlePlayClient_ReceiveServerUpdate : receive ObjectCommand cmd=ERASENODE=1 for nodeid=16777278 broadcast=true cmdclientid=2 cmdstamp=5 serverObjCmdAck=4 test=true...
            [Mon Nov 20 21:43:06 2023] INFO: GameNetwork() - HandlePlayClient_ReceiveServerUpdate : apply ObjectCommand from clientid=2 cmdstamp=5 serverObjCmdAck=4 ...
            [Mon Nov 20 21:43:06 2023] INFO: GameNetwork() - Client_ApplyObjectCommand : NET_OBJECTCOMMAND : cmd=(ERASENODE=1) nodeid=16777278 ...
            [Mon Nov 20 21:43:06 2023] INFO: GameNetwork() - Client_CommandRemoveObject : node=16777278 ...
            [Mon Nov 20 21:43:06 2023] INFO: GOC_Destroyer() - Destroy : id=16777278 ... enabled_=true delay=0.100000001490116 mode=DISABLE ...
            [Mon Nov 20 21:43:06 2023] INFO: GOC_Destroyer() - OnSetEnabled : node=avatar(16777278) !maincontroller => keep update position !
            [Mon Nov 20 21:43:06 2023] INFO: GameNetwork() - Client_CommandRemoveObject : serverObjectControl id=16777278 inactived oldenable=0 enable=0 !
            ==> pas d'autres reception apres ça
        ===> surement un pb dans GameNetwork::CleanObjectCommands() coté server.
        ===> HandlePlayServer_ReceiveUpdate applique et renvoit les ObjectCommand si broadcast. Le serveur ne recoit que les ObjectCommand des clients qui emettent leur propre broadcast.
        ===> les autres clients envoient leur retour de reception dans Connection::serverObjCmdAck_ coté server
        ===> le serveur nettoie les ObjectCommand qui restent à envoyer en comparant les ObjCmdAck en prenant le plus vieux => oldestObjectCmdAck
        ====> 21/11/2023 : dans GameNetwork::CleanObjectCommands(), il ne faut pas compter dans la recherche de oldestObjectCmdAck les ObjCmdAck provenant des clients hors partie.
        =====> Ok

    ✔ 20/11/2023 : la pluie apparait sur le serveur, un autre client mais pas le dernier @done(23-11-27 11:07)
        ajouter la synchronisation du temps au snap initial.
        => ok ajout de NetObjCommand::SETWEATHER et de WeatherManager::SetNetWorldInfos et GameNetwork::Server_SendWeatherInfos

    ✔ 20/11/2023 : probleme de Lights lorsque plusieurs avatars due aux limitations d'URHO3D @done(23-11-20 14:41)
        on doit avoir le meme probleme en multiplayers local
        => il n'y a pas de pb coté serveur car les lights sont deja desactiver pour les avatar client
        ==> faire la meme chose coté client lors du spawn des avatars distants.
        ===> modification de GameNetwork::Client_AddServerControllable
        ====> ne fonctionne pas,
            à la reactivation, il doit y avoir un node->SetEnabledRecursive(true) qui active la light.
            ou bien il s'agit de GameHelpers::SetLightActivation(Node* node) qui ne gere pas les clientids.
            mettre les SetEnabledRecursive() avant GameHelpers::UpdateLayering et modifier SetLightActivation pour prendre en compte GOA::CLIENTID.
            => ne fonctionne pas, Desactivation de Light dans GOC_Controller::ChangeAvatar ==> OK !

    ✔ 19/11/2023 : Le drop de slot BodyPart tel que les bones ou les elsapart crée un sprite non définie pour le collectable @done(23-11-22 15:46)
        ce qui resulte en un rect bleu à l'ecran ou du blinking
        => c'est le probleme de NetSpawnEntity qui est incapable de gerer les Slots BodyPart.
        ==> il faut ajouter VariantMap* slotData ... qui n'est pas transmis via ObjectControl
        ==> via ObjectCommand DROPITEM ?
        ===> réglé avec la modification de GOC_Collectable::DropSlotFrom et GOC_Inventory::NetServerDropItem qui permet un spawn avec slot

    ✔ 17/11/2023 : modification inventory client et replication sur server @done(23-11-23 10:27)
        ne pas envoyer de commandes aux autres clients seulement au server en utilisant PushObjectCommand(cmd, &eventData, false, clientid)
        pour ADDINVENTORYITEM (precedemment ADDITEM) probleme pour recuperer le clientID vers lequel on souhaite envoyer la commande.
        cette info doit être trouvée dans l'eventData durant l'envoi HandlePlayServer_Messages/HandlePlayClient_Messages et durant la reception Server_ApplyObjectCommand/Client_ApplyObjectCommand
        processus pour ADDINVENTORYITEM =
            coté server GO_INVENTORYGET->evendata->HandlePlayServer_Messages->PushObjectCommand(ADDINVENTORYITEM, &eventData, false, clientid)
            coté client HandlePlayClient_ReceiveServerUpdate->ObjectCommand->Client_ApplyObjectCommand(ObjectCommand.cmd_==evendata->ADDINVENTORYITEM)->Client_CommandAddItem(eventData)
                qui déclenche un check des nodes GIVER et GETTER si ils existent et de leur inventaire.
        il serait interessant de laisser ADDINVENTORYITEM en ObjectCommand BroadCasté par le serveur (donc clientid=0) et de modifier Client_CommandAddItem pour prendre en compte les clients
        qui n'ont pas les nodes GIVER et GETTER en main (si pas de controller ou inventaire ou collectable alors pas main). Mais on serait incapable de savoir si l'on doit detruire le collectable
        GIVER car pas de transfert de slot possible (et c'est au serveur de decider des quantités à transferer).
        ✔ TRANSFERITEM
            dans HandlePlayServer_Messages, faire le code pour analyse des GIVER et GETTER et Push du/des messages selon les cas suivants
            on renommera ADDINVENTORYITEM par TRANSFERITEM, Client_CommandAddItem par Client_TransferItem et REMOVEINVENTORYITEM par DROPITEM, RemoveItem par Server_UpdateInventory.
            TRANSFERITEM permet au serveur d'envoyer au(x) client(s) concerné(s) les slots transféré.
                si GETTER client/ GIVER serveur ou GETTER serveur/ GIVER client => envoyer TRANSFERITEM avec le clientid.
                si GETTER client1 / GIVER client2 il faut envoyer deux messages TRANSFERITEM (vers les clients 1 et 2).
        ✔ DROPITEM @done(23-11-23 10:27)
            envoi client     GO_DROPITEM->eventData->HandlePlayClient_Messages->PushObjectCommand(DROPITEM, &eventData, false, clientID_) envoi au serveur uniquement
            reception server HandlePlayServer_NetworkUpdate->ObjectCommand->Server_ApplyObjectCommand(ObjectCommand.cmd_==evendata->DROPITEM)->Server_UpdateInventory(evendata)
            -> Server_UpdateInventory doit mettre à jour l'inventaire coté serveur.
            ==> 22/11/2023 : Server_UpdateInventory utilise désormais GOC_Inventory::NetServerDropItem qui met à jour l'inventaire mais spawn aussi l'item si il s'agit d'un drop au sol
            ✔ étant donner que le client a déjà spawné de son coté, il faut vérifier que le SpawnControl fonctionne correctement (il faut faire comme GOC_BodyExploder) @done(23-11-23 10:27)
                ils ne sont pas liés : si l'avatar serveur prend l'item spawné coté serveur, l'item coté client n'est pas detruit.
                le GameNetwork::AddSpawnControl() inclut dans Map::AddEntity lancé via GameNetwork::Client_SpawnItem ne se lance pas ?
                => Map::AddEntity ne lance AddSpawnControl que si le nodeid = LOCAL.
                il faut pouvoir transformer un clientObject en un serverObject.
                pour commencer tous les Drop Client doivent etre des objets serveur.
                => il faut revoir AddSpawnControl pour indiquer le clientid au lieu de prendre le cliendid de l'holdernode
                ==> ok ajout de bool forceserver dans les parametres d'entree
                    il y a une affectation d'un nouveau ObjectControlInfo coté client dans le cas d'un changement du changement d'holderid mais pas coté serveur
                    LOG CLIENT
                    [Thu Nov 23 08:42:39 2023] INFO: GameNetwork() - AddSpawnControl : clientid=1 toclientid=0 node=PirateGun(16781278) ... spawnid=201326646(holderid=16777270,spawnstamp=12) ...
                    [Thu Nov 23 08:42:39 2023] INFO: GameNetwork() - AddSpawnControl : ...  oinfo=1975052248 srvnodeid=0 cltnodeid=16781278 holderptr=2483405888(nodeid=16777270,clientid=0) spawnstamp=12 !
                    ....
                    [Thu Nov 23 08:42:46 2023] INFO: GameNetwork() - AddSpawnControl : clientid=1 toclientid=0 node=PirateGun(16781278) ... spawnid=218103866(holderid=16777274,spawnstamp=13) ...
                    [Thu Nov 23 08:42:46 2023] INFO: GameNetwork() - AddSpawnControl : ... new oinfo=1975052640 srvnodeid=0 cltnodeid=16781278 holderptr=2484569936(nodeid=16777274,clientid=0) spawnstamp=13 !
                    LOG SERVER
                    [Thu Nov 23 08:42:39 2023] INFO: GameNetwork() - AddSpawnControl : clientid=0 toclientid=0 node=PirateGun(16781278) ... spawnid=201326646(holderid=16777270,spawnstamp=12) ...
                    [Thu Nov 23 08:42:39 2023] INFO: GameNetwork() - AddSpawnControl : ...  oinfo=3839142176 srvnodeid=16781278 cltnodeid=0 holderptr=17704784(nodeid=16777270,clientid=0) spawnstamp=12 !
                    ....
                    [Thu Nov 23 08:42:46 2023] INFO: GameNetwork() - AddSpawnControl : clientid=0 toclientid=0 node=PirateGun(16781278) ... spawnid=218103866(holderid=16777274,spawnstamp=13) ...
                    [Thu Nov 23 08:42:46 2023] INFO: GameNetwork() - AddSpawnControl : ...  oinfo=3839142176 srvnodeid=16781278 cltnodeid=0 holderptr=25107040(nodeid=16777274,clientid=0) spawnstamp=13 !
                =>  ne pas oublier que le ObjectControlInfo::SetActive() va effacer l'un des deux nodeids en fonction si c'est la machine est server ou client.
                    dans notre cas la machine est client, et AddSpawnControl cherche dans les serverObjectControls le servernodeid mais il est effacé (car desactivé),
                    donc un nouveau objectcontrolinfo est créé (ce que l'on ne veut pas)
                    correctif : l'obtention du ObjectControlInfo doit etre faite en verifiant les deux nodeids (servernodeid, clientnodeid), si l'un des deux correspond on prend l'objectcontrol.
            ✔ Drop Server => Replication Client, lorsque le server drop un item de qty 2, le client le ramasse mais c'est une qty 1. @done(23-11-22 15:39)
                verifier que Client_TransferItem a la bonne quantity recue.
                il s'agit du spawn qui est ecrasé par un NetSpawnEntity ordonné par ObjectControl.
                    LOG Client
                    [Wed Nov 22 13:03:00 2023] INFO: GameNetwork() - NetAddEntity : got=PirateGun(1491916807) ... serverNodeID=16781278 clientNodeID=16781278 ...
                    [Wed Nov 22 13:03:00 2023] INFO: GameHelpers() - SetCollectableProperties : got=PirateGun(1491916807) sprite=223184016 qty=1 ispart=false
                    [Wed Nov 22 13:03:00 2023] INFO: GameNetwork() - NetAddEntity : got=PirateGun(1491916807) ... node=PirateGun(16781278) enable=true !
                    [Wed Nov 22 13:03:00 2023] ERROR: GameNetwork() - NetSpawnEntity : clientid=1 node=PirateGun(16781278) ... pos=18.59,15.98 spawnid=16777274(holderid=16777274,spawnstamp=1) ...  oinfo=227528136 holderptr=732549440(nodeid=16777274,clientid=1) !
                    [Wed Nov 22 13:03:00 2023] INFO: GameNetwork() - HandlePlayClient_ReceiveServerUpdate : try ObjectCommand cmd=DROPITEM=7 for nodeid=16781278 broadcast=true cmdclientid=0 cmdstamp=6 serverObjCmdAck=5 test=true...
                    [Wed Nov 22 13:03:00 2023] INFO: GameNetwork() - HandlePlayClient_ReceiveServerUpdate : apply ObjectCommand from clientid=0 cmdstamp=6 serverObjCmdAck=5 ... OK !
                    [Wed Nov 22 13:03:00 2023] INFO: GameNetwork() - Client_ApplyObjectCommand : NET_OBJECTCOMMAND : cmd=(DROPITEM=7) nodeid=16781278 ...
                    [Wed Nov 22 13:03:00 2023] INFO: GameNetwork() - SpawnObject : got=PirateGun nodeid=16781278 holder=avatar(16777270) ...
                    [Wed Nov 22 13:03:00 2023] INFO: GameHelpers() - SetCollectableProperties : got=PirateGun(1491916807) sprite=223184016 qty=2 ispart=false
                    [Wed Nov 22 13:03:00 2023] INFO: GameNetwork() - SpawnObject : Node=PirateGun(16781278) spawned ... OK !
                    [Wed Nov 22 13:03:00 2023] INFO: GameNetwork() - NetAddEntity : got=PirateGun(1491916807) ... serverNodeID=16781278 clientNodeID=0 ...
                    [Wed Nov 22 13:03:00 2023] INFO: GameHelpers() - SetCollectableProperties : got=PirateGun(1491916807) sprite=223184016 qty=1 ispart=false
                    [Wed Nov 22 13:03:00 2023] INFO: GameNetwork() - NetAddEntity : got=PirateGun(1491916807) ... node=PirateGun(16781278) enable=true !
                    [Wed Nov 22 13:03:00 2023] ERROR: GameNetwork() - NetSpawnEntity : clientid=1 node=PirateGun(16781278) ... pos=17.95,15.98 spawnid=184549430(holderid=16777270,spawnstamp=11) ... new oinfo=227140040 holderptr=230931408(nodeid=16777270,clientid=0) !
                    ==> plusieurs NetSpawnEntity polluantes arrivent ... une avant et une autre après le SpawnObject
                il faut pouvoir indiquer le netspawnmode dans Map::AddEntity
                    ajout de skipNetSpawn_ dans SceneInfo : par defaut on autorise le netspawn
                    ajout de SceneInfo::skipNetSpawn_ = true dans GOC_Collectable::DropSlotFrom qui n'autorisera jamais de netspawn.
                NOTE IMPORTANTE : si l'on appelle Context::GetEventDataMap() attention car lors de la creation de Node Urho3D va aussi l'appeler écrasant son contenu (cf Node::AddChild)...
                c'est le cas lorsque l'on fait appelle à ObjectPool::CreateChild() par exemple qui est appelé par Map::AddEntity() <= World::SpawnEntity()
                donc on ne peut garder son contenu, il faudra utiliser une autre VariantMap. C'est ce qui est fait dans GOC_Collectable::DropSlotFrom() pour slotData qui aurait été effacé dans Map::AddEntity
                lors du ObjectPool::CreateChild() et donc avant d'arriver à la ligne de GameHelpers::SetCollectableProperties().
        ✔ SETITEM @done(23-11-22 18:44)
            permet au client d'envoyer au serveur tout modification dans l'inventaire. Et ainsi mettre à jour l'inventaire coté serveur.
            il ne doit pas interferer avec le UPDATEEQUIPMENT
            via UISlotPanel envoyer à GameNetwork un event de modification d'inventaire ? ou bien directement dans GOC_Inventory ce qui est plus logique
            il faudra faire attention à DROPITEM qui est deja envoyer.
            comment gerer le shop ou le craft ?
            ajout de GO_INVENTORYSLOTSET à mettre en place pour le bagpanel
            on utilisera Slot::GetSlotData() et Slot::SetSlotData() : pas tres performant mais bon on verra apres.
            => mis en place dans UIC_BagPanel::UpdateSlot si Client.

    ☐ 17/11/2023 : lorsqu'un avatar est touché avec un effet de feu, l'effet ne se produit pas sur un client distant

    ☐ 16/11/2023 : snap initial
        le serveur doit envoyer un snap initial au client qui se connecte.
            cela doit faire partie de la phase PLAYSTATE_CLIENT_LOADING_SERVEROBJECTS
            tous les nodes ajoutés/retirés et les states : ex: l'etat des coffres(plein, vide), l'etat des lights(allumé,eteint)
            => il faut tracer dans World2D les ajout/suppression de nodes.
        le client recupère le snap et synchronise sa scene
            fait le tri sur les nodes déjà existants, ceux à supprimer et ceux à créer.
            supprime, crée et met à jour les nodes avec les bons attributs, états.
        ✔ 16/11/2023 : ajout de GameNetwork::Server_SendSnap et GameNetwork::Server_SendInventories
        ✔ 23/11/2023 : ajout de Weather => GameNetwork::Server_SendWeatherInfos @done(23-11-28 15:04)
        ✔ 28/11/2023 : ajout des TileModifiers => GameNetwork::Server_SendWorldObjects @done(23-11-28 15:04)
        ☐ ajout des entities/furnitures et des states initiaux (d'animation principalement pour les lumieres)
            => il faut la liste des nodes effacés par rapport à la génération initiale.
        ☐ envoyer les serverObjects qui ne sont pas NetSpawnable.
            => attention, il ne faut pas utiliser de nouveaux spawnstamp et les spawnstamp doivent etre synchronisés
            ==> utilisé GameNetwork::NetAddEntity et pas GameNetwork::NetSpawnEntity
            ==> reconciliation des spawnstamps dans GameNetwork::Client_SetWorldObjects
            ==> cela fonctionne en arena, mais en world cela va surement poser probleme pour la prise de nodeid.

    ✔ 14/11/2023 : ajouter deux modes reseau : arena (salle d'attente, redirection vers une partie en attente, synchronisation des autres clients, lancement) et world (pas d'attente) @done(23-12-06 16:15)
        avec le NetSimulator activé, pour le moment il y a un probleme pour mode reseau sans attente, car en arena si on lance un serveur et un client en playstate. Puis on ajoute un second client et playstate
        alors le second client n'a pas la synchro du snap initial, ni les equipments ...
        => corrigé le 05/12/2023. Il faut maintenant créer le reseau en world.

    ✔ 14/11/2023 : les inventaires des autres clients et serveur doivent être communiqués à tout nouveau client qui se connecte. @done(23-11-17 16:07)
        les clients ne doivent pas avoir à charger de l'inventaire local, l'ordre doit venir du serveur.
        ✔ 16/11/2023 : Modification majeure de l'envoi/reception des inventaires : l'event GO_INVENTORYLOAD n'est plus nécessaire @done(23-11-17 11:30)
            Le serveur envoit les inventaires par PushObjectCommand(SETFULLINVENTORY) pour chaque player d'un client
            Le serveur envoit les equipments (seulement la section equipment de l'inventaire) par PushObjectCommand(SETFULLEQUIPMENT) à tous les clients autre
            pour cela ObjectCommand est modifiée pour l'envoi de Command BroadCastée
            Ajout de GOC_Inventory::LoadInventory (gestion global net/local) qui remplace aussi Player::LoadStuff pour le mode local
            Ajout de GOC_Inventory::NetClientSetEquipment(node) qui permet sur les clients d'afficher l'equipment des players distants
                Après ChangeAvatar sur un client il faut lancer NetClientSetEquipment
            1. pb si le node n'existe lors de la reception coté client, il faut donc sauvegarder l'inventaire/equipment reçu
                ceux ci sont stockés dans GOC_Inventory::clientInventories_ et GOC_Inventory::clientEquipmentSets_
                attention ces deux containers contiennet des VariantVectors qui ont des structures differentes
                    pour GOC_Inventory::clientInventories_ les VariantVector contiennent des String de slots générées cf. GOC_Inventory::GetInventoryAttr (Slot::GetSlotAttr)
                    pour GOC_Inventory::clientEquipmentSets_ les VariantVector contiennent des UInt cf. GOC_Inventory::GetSectionSlots
            2. pb dans GOC_Inventory::NetClientSetInventory(uint nodeid) et GOC_Inventory::NetClientSetEquipment(uint nodeid) lors de la verification du node
                il y a un pb avec GameContext::Get().rootScene_->GetNode(nodeid) alors que le node est bien créé en amont (la vérification a été faite)
                création d'un cache des nodes créé précédemment dans GOC_Inventory::clientNodes_ via GOC_Inventory::RegisterClientNode
                    Processus Client : creation de l'avatar => NetClientSetEquipment(Node*) enregistrement du node via RegisterClientNode
                                        si l'inventaire/equipment a été reçu dans clientInventories_/clientEquipmentSets_, alors on le monte
                                        sinon lors de la reception on utilise NetClientSetEquipment(uint nodeid) qui enregistre l'equipment dans clientEquipmentSets_
                                        verifie nodeid dans clientNodes_ et renvoi vers NetClientSetEquipment(clientNodes_[nodeid])
        ✔ 17/11/2023 : ObjectCommand broadcast encore un probleme à régler avec cmd.stamp_ @done(23-11-17 16:07)
            coté serveur, lors du PushObjectCommand quelle valeur assignée à cmd.stamp puisque
            chaque connection à une valeur GetServerObjCmdAck differente : si on veut que le message soit envoyer à chaque client
            il est nécessaire d'avoir un cmd.stamp_ superieur à la valeur Connection::GetServerObjCmdAck specifique à chaque client
            un workaround est mis en place dans GameNetwork::HandlePlayServer_NetworkUpdate, mais doit etre supprimer
            cela doit etre fait dans GameNetwork::PushObjectCommand
            dans ObjectCommand : ajout un vector pour stocker les valeurs stamp à utiliser pour chaque client
                Ok ajout de Vector<unsigned short> ObjectCommand::broadcastStamps_, ObjectCommandSetBroadStamps et modif ObjectCommand::Write
                modification de GameNetwork::PushObjectCommand et GameNetwork::HandlePlayServer_ReceiveUpdate
                suppression du workaround et test ok avec activation du define ACTIVE_OBJECTCOMMAND_BROADCASTING

    ✔ 14/11/2023 : coté distant, le grapin reste en permanence. @done(23-11-25 20:45)
        ex: spawn coté serveur et destruction -> spawn coté client mais reste.
        -> il s'agit surement d'un probleme similaire à la collecte au sol de collectable
        ==> il faut que le serveur envoie une commande de remove object aux clients
        => Resolu suite à la resolution du 23/11/2023 DROPITEM sur la synchro serveur/client des ObjectControl via AddSpawnControl
        25/11/2023 : Le grapin qui n'est pas encore accroché, ne s'efface pas coté remote
        => OK : Modification de GOC_PhysicRope::Release() => 3eme etat holderinfo_.id_ = M_MAX_UNSIGNED, modif GameNetwork::UpdateControl()

    ✔ 14/11/2023 : coté distant, le grapin n'affiche pas toujours la chaine @done(23-11-26 16:13)
        -> l'etat attaché est defini lorsque le holderinfo.id_ est different de 0. cf GameNetwork::UpdateControl()
            le probleme survient du à l'approximation faite dans le packing de l'objectcontrol.
            GOC_PhysicRope::CreateRope n'est pas en mesure de créer la chaine si deltay >= 0.
            ajout d'un seuil superieur et ne pas utiliser le holder->GetWorlMassCenter() mais GetWorldPosition2D()

    ✔ 13/11/2023 : l'envoi de l'etat allumé éteint des torches/bougies est à faire. @done(23-12-06 15:29)
        via ObjectCommand
        -> 06/12/2023 : on utilise un duo d'event GO_TRIGCLICKED et NET_TRIGCLICKED pour eviter un ping pong infini entre peers
        ==> ces events sont enregistrés dans les GOC_AnimatorTemplate "AnimatorTemplate_InteractiveFire" et "AnimatorTemplate_InteractiveFurniture"
        ==> GOC_Animator2D prend ensuite le relai (notamment avec CheckFireLight pour les lumières)
        ===> RAF : il y a encore un probleme mineure : CheckFireLight est utilisé deux fois de suite ... bizarre.

    ✔ 13/11/2023 : pouvoir se connecter en tant que serveur ou client sans avatar pour observer @done(23-12-06 15:29)
        permet de realiser des tests distants et verifier la replication
        => 6/12/2023 : il suffit de modifier GameCommands::Launch pour permettre de taper dans la console numplayers=0
        => mettre par défaut numplayers=0 pour le serveur.

    ✔ 13/11/2023 : les lustres sont répliqués par ObjectControl ce qui ne doit pas être le cas @done(23-11-13 18:28)
        les furnitures ne sont pour le moment pas répliqués cf MapBase::SetFurnitures il n'y a pas de commande network
        -> il s'agit de GOC_PhysicRope, qui est utilisé principalement pour le grapin
        --> modification de GOC_PhysicRope pour qu'il vérifie qu'il ne soit pas dans un node furniture

    ✔ 13/11/2023 : ne pas mettre les rip stele en mode reseau arena @done(23-11-19 00:37)
        -> si l'avatar coté serveur meurt, elle ne pope pas au bon endroit coté client (elle pope au dessous de l'avatar client)

    ✔ 13/11/2023 : inventaires et charactermapping ne fonctionnent plus ? @done(23-11-14 10:31)
        voir si ObjectCommand est operationnel pour envoyer le stuff d'equipement pour mettre à jour les inventaires.
        -> cela fonctionne sur la version 20210925. Recherche du pb!
        ✔ dans GOC_Inventory::LocalEquipSlotOn le variantmap etait alimenté par des StringHash. Il faut l'alimenter par les Value des StringHash. @done(23-11-13 22:40)
        ✔ il y a eu un crash après changement d'equipement sur l'avatar du serveur + changement de l'avatar petit qui porte epee flame vers avatar non porteur d'equipement. @done(23-11-14 10:31)
            inspecter tout les variantmap envoyé par NetCommand et debug du client.
            le crash provient de GOC_Controller::ChangeAvatar->GameHelpers::CopyAttributes->AnimatedSprite2D::OnSetEnabled->renderedAnimations_[i]->GetNode()->SetEnabled(enabled)
            -> modifier AnimatedSprite2D pour eviter le crash => difficile. Il faut changer la struct renderedAnimations_ par Vector<WeaktPtr<AnimatedSprite2D> > ...
            -> OK : ajouter à GameHelpers::CopyAttributes, la methode GOC_Animator2D::UnplugDrawables() ou AnimatedSprite2D::ClearRenderedAnimations().

    ✔ 11/11/2023 : pb de ghosting coté client ou serveur lorsque l'avatar distant s'arrete. @done(23-11-13 15:37)
        reprise du mode reseau apres 2 ans off. ce probleme n'existe pas sur la version 20210925
        il n'y a pas eu de modification sur Urho3D::Network, ni dans Urho3D::Scene
        -> ont été ajouté dans ObjectControlInfo : BackupReceivedControl(), GetPreviousReceivedControl() et lastNetChangeCounter_.
        --> Test1 : integration de l'ancien PackedObjectControl dans la version courante de Frombones => meme pb
        --> Test2 : integration de la version courante de PackedObjectControl dans la version 20210925 => fonctionne correctement.
        --> cela ne provient pas de GameNetwork : lorsque l'avatar est immobile et que le serveur reçoit l'ObjectControl la position reçue ne varie pas (Log dans HandlePlayServer_ReceiveUpdate=>UpdateControl).
        -> cela provient du changement dans GOC_Controller::Update puis impact GOC_Move2D qui a physicsEnable_ => si les buttons ne sont pas setté alors GOC_Move2D va appliquer une force dans la direction
        --> 13/11/2023 : Ok patch dans GOC_Controller::Update.

    ✔ 04/10/2021 : il faut revoir une fois de plus lorsque l'entité attaque, l'animation loop parfois encore cette fois en local. GOC_Animator2D::SetState(), GOC_Animator2D::CheckAnim()
        -> modif dans GOC_Animator2D::CheckAnim()
            toujours le meme pb. dur à reproduire : vu uniquement en world. En arena en mettant bcp d'entité, non reproduit.
        ==> 01/02/2024 : cf Correctif 01/02/2024 BEHAVIOR

    ✔ 27/09/2021 : la collecte d'un collectable au sol par un client est bien repercuté coté server mais pas vers les autres clients. @done(23-11-18 17:27)
        -> 14/11/2023 : il faut que le serveur envoie une commande de remove object aux autres clients
        -> 17/11/2023 : OK correctif dans GOC_Destroyer::Destroy

    ✘ 20/09/2021 : lors du changement d'ability sur un client, il faut le repercuter coté server autrement le server ne sera pas quelle abilité utilisée dans Player::OnFire2() @cancelled(23-11-19 21:55)
        => 21/09/2021 : Etant donner que le Player::OnFire2() n'est plus utilisé en version Net (coté server), ce cas ne se pose plus.
        ==> le faire neanmoins, pour assurer d'eventuels cas.

    ✘ 19/09/2021 : snap initial lorsqu'un client se connecte en cours de partie. Ce n'est pas nécessaire en arene. Cela le sera en World networked @cancelled(23-11-14 11:26)

    ✔ 29/08/2021 : le reseau est saturé apres plusieurs suicides avec le skeleton @done(23-11-23 18:10)
        => pb avec knet ? comme pour les messages reliables ?
        => voir pour afficher dans le DebugHud, le nombre d'ObjectControl et ObjectCommand envoyés et reçus.
        ==> voir pour passer à SlikeNet : integration faite dans la version 1.7 d'Uhro.
        ===> 31/08/2021 : integration faite avec FromBones : pas d'incidence sur le code de FromBones.
        ====> Modification de SLikeNet pour activer le Latency Simulator : modification de ReliabilityLayer::ApplyNetworkSimulator et RakPeer::ApplyNetworkSimulator ... inversion de logique => _DEBUG par_RELEASE
        =====> IMPORTANT : par defaut le net simulateur est activé. NE PAS OUBLIER D'ACTIVER dans slikenet/include/defines.h la ligne #Define _RETAIL pour desactiver le NetSimulator en version Publique._
        ====> apres 3 suicides avec ACTIVE_NETSIMULATELATENCYANDPACKETLOSS, les nouvelles boneparts deviennent instables (elles se déplacent dans tout les sens) puis il y a un certain temps, elles arrivent à leur position
        =====> en corrigeant GOC_Destroyer::HandleUpdateTime() pour permettre la destruction des bones, il n'y a plus de congestion lors du test.
        =====> logger les stamps, verifier le nombre de paquets, verifier la gestion de la congestion par SLNet
        ======> utilisant GameCommands::"netstate" => 25 paquets envoyés par sec => le network etant configuré à 25 fps ; apres plusieurs suicide, le nombre de paquets diminue à 1-2 par sec.
        ======> utilisant GameCommands::"netlog" pour obtenir le LogStatistics de Connection => le nbBytesPerSec est de 25000KBytes/sec apres le 2eme suicide, la congestion a lieu apres le 3eme suicide, soit environ 35000KBytes/sec => 286MBits/s ce qui est beaucoup
        =======> en prenant à l'envers à partir de la taille des ObjectControls : 3 suicides pour le client correspond à 3*17Bones*3+1Avatar=52 ObjectControls envoyés vers le serveur = 52 * 72 Bytes = 3744Bytes pour une frame (sans la compression)
        =======> soit 3744Bytes*25fps=94KBytes/sec ---> on est loin de ce qui est affiché par LogStatistics => erreur dans Connection::SendRemoteEvents() les KB sont des Bytes et pas de KiloBytes
        ========> en corrigeant/activant ACTIVE_PACKEDOBJECTCONTROL, la taille des objectcontrols passe à 48Bytes, la congestion arrive un peu apres.
        =========> il faut logger l'envoi des objectControls et des objectCommands par seconde dans GameStatus::"netlog" -> ajouter le code dans GameNetwork::DumpObjectControls()
        ==========> 1) limiter le nombre de traitement d'objectControls par envoi.
        ===========> OK : 06/09/2021 -> modification de GameNetwork::HandlePlayServer_NetworkUpdate  GameNetwork::HandlePlayClient_NetworkUpdate() limite l'envoi à MAX_OBJECTCONTROLTOSEND maximum
        ============> conséquence : plus de sacade coté des autres clients. Il faut donc limiter un maximum les Object controlés par les clients.
        ==========> 2) les "acks" server->client sont pour le moment des objectcontrols. ils doivent être changer par une structure moins consommatrice de données pour limiter la qté de data à retourner.
        ============> OK : 06/09/2021 -> modification de ObjectControlInfo (WriteAck et ReadAck) et modification de GameNetwork::HandlePlayClient_ReceiveClientUpdate et modifier GameNetwork::HandlePlayServer_NetworkUpdate pour recevoir et
             envoyer les acks uniquement dans le cas du retour ACK serveur/client, ajout de GameNetwork::UpdateControlAck().
        ==========> coté client, il faut eviter d'envoyer trop d'ObjectControl vers le serveur. C'est le serveur qui est dimensionné pour avoir le meilleur debit d'envoi.
        ==========> 3) apres spawn des part bones ou bien drop d'items et ack du server, il faudrait reaffecter le ownership au server.
        => 23/11/2023 : il ne s'agit pas de congestion, c'est lié au BodyExploder uniquement
            il s'agit des composants physiques (Rigidbody et CollisionBox) qui sont désactivés après la seconde mort ...
            il y a aussi une variable non reconnue aussi
            LOG CLIENT NON MAIN
                [Thu Nov 23 11:38:12 2023] INFO: GameHelpers() - DumpNode : avatar(16777278) ...
                ...
                [Thu Nov 23 11:38:12 2023] INFO:  => Var (726139502) type=Bool value=false
                ...
            => il s'agit de GOA_Destroying qui n'etait pas enregistré.
            ==> cette var doit etre supprimé au respawn.
            sur les clients distants les nodes sont reactivés cf UpdateControl
            => Le probleme reside dans la non-desactivation du node au moment de la notification de la mort de l'avatar car celui-ci n'est déjà plus dans la map
            LOG CLIENT NON MAIN 1ere mort
                [Thu Nov 23 14:32:05 2023] INFO: GameNetwork() - Client_ApplyObjectCommand : NET_OBJECTCOMMAND : cmd=(ENABLENODE=2) nodeid=16777278 ...
                [Thu Nov 23 14:32:05 2023] INFO: GOC_Destroyer() - Destroy : node=avatar(16777278) ... enabled_=true delay=0.100000001490116 mode=DISABLE ...
                [Thu Nov 23 14:32:05 2023] INFO: GOC_Destroyer() - OnSetEnabled : node=avatar(16777278) !maincontroller => keep update position !
                [Thu Nov 23 14:32:05 2023] INFO: GOC_Collide2D() - OnSetEnabled : avatar(16777278) ... scene=2603929264 enable=0 body=2729263248 shapes=0
                à la premiere mort, GOC_BodyExploder a desactiver le RigidBody au moment de l'explosion puis,
                GOC_Collide2D::HandleDead desactive la CollisionShape qui n'a pas de contact Bottom (c'est le CollisionBox de corps)
                Le Node est bien desactivé
            LOG CLIENT NON MAIN 2eme mort
                [Thu Nov 23 14:35:08 2023] WARNING: World2D() - HandleObjectDestroy : GO DESTROY node=avatar(16777278) no entity in mpoint=0 0 !!!
                [Thu Nov 23 14:35:09 2023] INFO: GameNetwork() - HandlePlayClient_ReceiveServerUpdate : try ObjectCommand cmd=ENABLENODE=2 for nodeid=16777278 broadcast=true cmdclientid=0 cmdstamp=11 serverObjCmdAck=10 test=true...
                [Thu Nov 23 14:35:09 2023] INFO: GameNetwork() - HandlePlayClient_ReceiveServerUpdate : apply ObjectCommand from clientid=0 cmdstamp=11 serverObjCmdAck=10 ... OK !
                [Thu Nov 23 14:35:09 2023] INFO: GameNetwork() - Client_ApplyObjectCommand : NET_OBJECTCOMMAND : cmd=(ENABLENODE=2) nodeid=16777278 ...
                Le cycle est rompu à partir de là
            ==> ENABLENODE envoyer par le server n'est pas bon dans ce cas : creation de Client_CommandEnableObject qui va tester si le node est mort et le retirer proprement avec WORLD_ENTITYDESTROY et destroyer->Reset(false)
            ===> il y a eu ensuite un pb de desactivation des physics (body,shapes) resolu en modifiant l'ordre d'activation des composants dans GameNetwork::UpdateControl

    ✘ 14/08/2021 : pour ameliorer le temps de deconnection d'un client, le serveur pourrait controler la reception du stamp dans GameNetwork::HandlePlayServer_ReceiveUpdate(). @cancelled(23-11-27 08:51)
        => si le stamp est toujours le meme pendant Xs alors deconnection du client.
        ==> 08/09/2021 : avec SLNet, lorsque le server est deconnecté, le temps de deconnection des clients est encore plus long (30sec)

    ✔ 12/08/2021 : les body parts doivent pouvoir être détruites par les differents clients @done(23-11-19 21:52)
        => OK : il suffit de modifier les attributs de ScrapsEmitter dans avatar-newskeleton.xml
        => Resolu par les modifications dans GOC_BodyExploder2D et GameNetwork (NetCommand EXPLODENODE)

    ✔ 11/08/2021 : pb de spawn lors par exemple de l'explosion du skeleton ou bien d'elsarion. @done(23-11-23 11:51)
        => cf GOC_BodyExploder2D, GameNetwork::AddSpawnControl()
        ==> le spawn multiple au meme instant entraine-t-il le debordement du spawnstamp ?
        ===> la suppression du check localspawnstamp receivespawnstamp dans GameNetwork::AddSpawnControl() résout ce pb mais il n'y aura plus de synchro de spawnstamp
        ✔ 19/11/2023 : cela semble impacter tout le netspawning : à priori c'est du au spawnstamp @done(23-11-19 16:18)
            l'interet de GOC_BodyExploder2D est de preparer les nodes explosés. Il faut donc garder le principe lors du netspawn. si l'on utilise Net SpawnControl, cela perd tout son interet.
            il faut donc envoyer une command Explode avec le spawnstamp de depart et utiliser GOC_BodyExploder2D (mais ne pas utiliser le NetSpawnEntity).
            => ajout de NetCommand EXPLODENODE et GameNetwork::Explode(EventData)
            ==> le spawn semble ok sur le serveur + 2 clients
        ✔ 19/11/2023 : lors de la mort du skeleton et repop, le mouvement du skeleton est saccadé sur les autres clients @done(23-11-20 11:56)
            apparement les composants physic2D ne sont plus actifs.
            en effet lors de la mort du skeleton, GOC_BodyExploder desactive le RigidBody qu'il faut donc reactiver au repop coté client distant
            => GameNetwork::UpdateControl()->GOC_Destroyer::Reset(true)->GOC_Destroyer::OnSetEnabled() -> ajout de la reactivation du rigidbody
            ==> Cela ameliore mais ne semble pas resoudre completement les saccades : il faut logger les ObjectControls. => close => cf todo 29/08/2021

    ✘ 03/07/2021 : suite à la modification du spawning effectuer coté client (le client spawn desormais toujours sans attendre la reponse du serveur), @cancelled(24-01-19 08:46)
        le spawn d'une bombe par exemple coté client fait apparaitre le pb de "snapping" des synchronisation avec le serveur.
        La bombe revient en arriere est prend la position du serveur avec le double de decalage (puisque latence client->serveur, puis serveur-client).
        => il faut introduire les concepts de client prediction+server reconciliation et lag compensation pour diminuer les effets de la latence (cf. https://www.gabrielgambetta.com/lag-compensation.html)
        ==> client prediction necessite de bufferiser les ObjectControls envoyés au serveur. Pour le moment seul le dernier objectcontrol prepared est stocké et seuls les 2 derniers objectcontrol reçus sont stockés.
        ==> un objet spawné par le client est stocké dans GameNetwork::clientObjectControls_, le server reçoit l'ObjectControlInfo d'une part et d'une autre le spawn lui meme
        ==> todo : de meme coté serveur ...
        ==> il faut revoir le stamp client et le stamp serveur.
        ==> lors du spawn, il faut verifier si l'entity qui spawn appartient à la machine.
            Si la machine est le server, le nodeid ira dans ObjectControlInfo::serverNodeID_ autrement dans ObjectControlInfo::clientNodeID_
            Modifier GameNetwork::AddSpawnControl() qui pour le moment spawn avec owner=0(server)
            Le node spawné hérite le owner du node holder.
        ==> remplacer ObjectControlInfo::owner_ par clientId_
        ===> si un etat revient different au client, il doit corriger son etat courant en tenant compte de l'etat recu et l'extrapolant selon la latence.
        ====> pour le moment, le serveur prend pour argent comptant les informations provenant du client. Il lui faut une méthode pour lutter contre le cheating.
        =====> par ex : calcul des distances possibles parcourable entre chaque reception. si la distance parcourue est superieure à la distance possible calculée, il y a triche. Sauf si pouvoir de teleportation utilisé biensur.
        ==> lag compensation va s'occuper des cas ou l'avatar coté client arrive à toucher une cible. Cette cible est à une position passée pour le client possesseur de cette entité.
            coté client, les animations hurt doivent popper des que l'avatar touche une cible sans attendre l'approbation du serveur mais ne pas etre repetes à la reception des infos serveur. (server reconciliation)
        ==> vérifier que tout les packets envoyés soit en message soit par ObjectControlInfo soit taggé par un stamp généré par le client emetteur.
            Le serveur recoit les stamps de chaque client et permet de classer pour chaque client la chronologie des commandes passées.

    ✘ 23/06/2021 : crash si un client meurt et drop son inventaire et qu'un autre client ramasse du stuff @cancelled(23-11-19 00:39)

    ☐ 08/06/2021 : en Reseau Arena si mort de l'avatar, faire un repop automatiquement au bout de 5sec (mettre un timer de repop)
        => modifier PlayState::CheckGameLogic() => GOManager::GetNumActivePlayers() prend en compte les Players et les Net_Players alors qu'il ne faut uniquement que prendre en compte les joueurs locaux pour le mode arena
        => l'objectif pour gagner pourra être dans un temps imparti (5min/10min...)
        ==> Tuer le maximum de joueurs
        ==> ou Obtenir le maximum d'un objet déterminé (exemple des bones)

    ✔ 22/08/2019 : @done(23-11-18 17:29)
        -> GOC_Inventory : lors du drop d'un player sur un client, mettre à jour l'inventaire coté serveur du joueur
        --> car sinon impossibilité du GetSlot si l'inventaire coté serveur est plein alors que celui du client non.
        --> les DPS sont calculés sur le serveur. Donc si l'equipment n'est pas le bon les DPS envoyés vers le Client ne seront pas bons.
        ==> 02/06/2021 : OK pour le moment ajout de GOC_Inventory::NetServerSetSlot() et modification de GameNetwork::ChangeEquipment()
        ===> il s'agit que de l'ecrasement d'un slot d'equipment sur le server par le slot du client
        ====> lors des procedures de chargement d'equipement coté client tel que Player::LoadStuffOnly(),
            il faut en informer le server qui aura également sauvegarder les inventaires de tous les clients dans ses bases.
        ====> OK depuis 17/11/2023

    ✔ 17/10/2019 : Crash du serveur lorsque l'avatar server meurt et que le client recupere des obj de l'inventaire dropper. @done(23-11-20 22:38)
        -> Crash Coté Server dans ou après Player::OnServerGetCollectable
        --> dans Equipment::UpdateAttributes() : la money passe en index=0 ce qui fait planter la procedure qui recherche sur index-1 -> correctif interdit index=0
        -> Boucle infinie coté client après correctif sur serveur apres Player::OnGetCollectable()
        --> dans GOC_Collectable::TransferSlotTo() : ajout d'un break en cas ou Slot::TransferTo() retourne une quantity nulle
        ---> les objets et quantités de money ne sont pas identiques avec ceux de l'inventaire initial du player mort.
        ----> 18/10/2019 : verifier l'inventaire dropper à la mort du player et verifier la recuperation de chaque collectable.
        -> 20/11/2023 : le server ne crash plus.

    ☐ 08/10/2019 : la force d'impact à produire lorsqu'une entité est touché est differente entre le client attaquant et les autres à cause de l'equipment
        -> voire pour repliquer la valeur de cette force ou bien tout l'equipment.

    ✘ 26/09/2019 : probleme lors du spawn du grapin en reseau. L'ancienne chaine est parfois toujours attachée ... @cancelled(23-11-26 16:13)
        -> Vérifier le code dans GameNetwork::HandleObjectControlHolderChanged()

    ☐ 19/08/2019 : le marchand coté client n'est pas un actor donc ne peut pas intéragir avec le joueur.
        -> voir pour l'ajout d'actor avec ObjectPool via le network

    ✘ 18/08/2019 : Comment assurer la corrélation entre les numeros d'entités, les maps en mémoires sur l'ensemble des clients connectés avec le serveur @cancelled(24-01-19 08:45)

    ✘ CharacterMapping: @cancelled(23-11-14 11:10)
        --> envoyer un RemoteEvent des changements d'equipment ou bien via ObjectControl => OK, en cours
        --> 19/08/2019 : lors du pop coté clients d'entités à synchroniser avec le serveur, le charactermapping n'est pas communiqué.

    ✘ GOB_MountOn : l'entité portée ne doit pas avoir de mouvement relatif / entité porteuse @cancelled(24-01-19 08:45)
        -> ajouter idparentnode dans ObjectControl ou bien RemoteSendEvent

    ✘ affichage du mauvais avatar pour les seconds joueurs locaux @cancelled(23-11-14 11:28)


Archive:

    ✔ 27/09/2021 : parfois l'animation attack de l'ours est repeté 2x sur un client foreign.
        => cela pourrait occasionner des problemes si attack avec un spawn d'entité. Ce n'est pas le cas pour power2 de mirubil.
        ==> verifier AnimatorTemplate_Attacker (utiliser par loup, ours, bitroll, goblin, karotos, lizard, merchant, shuktuk), vu aussi sur l'avatar-lizard
        ==> verifier si pas de doublon entre l'application du state buttons et application de l'animstate
        ===> les logs font apparaitre que GOC_Animator2D::ChangeAnimation() est sollicité une fois par GameNetwork::UpdateControl pour le passage au state Attack
            puis une fois par l'update local en state Idle puis encore par GameNetwork::UpdateControl pour le passage au state Attack une nouvelle fois.
        ====> il faut pouvoir tester s'il s'agit d'un nouveau changement d'animation. Ou bien simplement la continuité du state courant.
        =====> stocker le dernier etat appliqué par GameNetwork::UpdateControl() et tester.
        ======> ne permet plus d'utiliser les animations switchable (tickdelay).
        =====> il faut mettre un id pour chaque changement d'anim. (un peu comme pour les spawn)
        ======> si l'anim id reçu est identique au dernier id utilisé alors ne pas changer d'animation.
        =======> l'affectation de l'anim id doit se faire par GameNetwork::PrepareControl() et dans GOC_Animator2D
        ========> remplacement de ObjectControl::states_.spawnmode_ par flag_ (bitflag) le bit0 correspondant au spawnmode et le bit1 à l'animation changed
        ========> modifier ObjectControl::states_.animation_ par unsigned char ObjectControl::states_.animstateindex_ (template animation state index) et unsigned char ObjectControl::states_.animindex_ (animatedsprite (sprite) index)
        =========> 30/09/2021 : OK modification de GOC_Animator2D::SetStateSilent() et remplacement par GOC_Animator2D::SetNetState().
        =========> RAF : Tester si le state courant peut etre interrompu par le nouveau state. (attack -> walk normal non possible). Autrement certaines animations seront interrompues avant leur terme.
        ==========> OK ajout de AnimatorState::CanTransitToState()
        ===========> 01/09/2021 : OK gestion conforme des SwitchableAnimation notamment.

    ✔ 06/09/2021 : il faut finir les modifications de Spawn des ObjectControls => RAF le grapin avec le holderinfo.
        => le spawn des bombes se déroule
        ==> en local avec le clavier GOC_Animator2D => en net => GameNetwork::UpdateControl => ChangeAnimation => spawn par GOC_Animator2D qui utilise alors static Ability::Use(),
            le principe des SpawnControl est respecté : le spawn d'entity est toujours effectué localement sur chaque client puis à la reception des ObjectControl, la synchronisation des positions, states s'effectue.
        ==> en local avec la souris Ability::UseAtPoint() => en net il n'y a pas de state transmis qui permet le spawn dans GameNetwork::UpdateControl
        ===> il peut y avoir un probleme de coherence de spawn (local/net), si changement de l'animation avant le spawn soit coté local, soit coté net.
        => le spawn des autres abilités (sauf bombe) se déroule
        ==> en local, utilisation de la souris pour spawner (Player::HandleClic() => Ability::UseAtPoint()) uniquement local non transmise par le net
        ==> en local, utilisation de la touche action pour spawner (Player::OnFire2() => Ability::Use()) transmis via le net par le state ObjectControl::states_::buttons_ de l'avatar
        ==> seul le server connait l'abilité active, donc pas de spawn sur les autres clients
        ===> à la reception de l'ObjectControl, il faudrait realiser le spawn : ajouter ce cas dans GameNetwork::HandlePlayServer_ReceiveUpdate() et GameNetwork::HandlePlayClient_ReceiveServerUpdate() => voir les consequences avec les controllables et les bombes.
        ===> modification et unification de static Ability::Use() qui est utilisé dans GameNetwork::NetAddEntity() -> World2D::NetSpawnEntity().
        ====> RAF la lame spawn bien, mais la faction n'est pas la bonne.
        ====> 17/09/2021 : OK Correctif dans GOC_PhysicsGrapin::HandleRoofCollision() pour eviter la creation d'un autre spawncontrol
        =====> de client => server OK mais client => server => other client pas de spawn
        =====> avec un server et deux clients => double spawn des bombes.
        ======> il s'agit du probleme classique si le principe du SpawnControl n'est pas respecté.
        =======> si GOC_Animator2D est utilisé pour le spawn, il ne faudrait jamais spawner via GameNetwork::NetAddEntity()
        ========> Si le mode de spawn utilisé est "Animator" (mode à communiquer dans l'ObjectControl), le code dans GameNetwork::HandlePlayServer_ReceiveUpdate() et GameNetwork::HandlePlayClient_ReceiveServerUpdate() concernant GameNetwork::NetAddEntity() sera skippé.
        ========> ajout de NetSpawnMode, ajout ObjectControl::states_::spawnMode_, si spawnMode_ = LOCALANDNETSPAWN alors GameNetwork::NetAddEntity() est utilisé.
        =======> if faut absolument que
        ========> un client qui spawn un poolnode envoit toujours un ObjectControlInfo dont le serverNodeId_=0
        ========> le server qui spawn un poolnode envoit toujours un ObjectControlInfo dont le clientNodeId_=0
        =========> 19/09/2021 : pas mal de correctif, ajout de GameNetwork::NetSpawnControlAlreadyUsed() mis dans GOC_Animator2D::SpawnEntity() qui permet de skipper si une entity est déjà spawnée avant le prochain network update
            evite le double spawn pour les bombes (les bombes spawnées en local via le controle clavier)
        ==========> faire la documentation des cas d'utilisations. voir si possibilité de simplification (pour respecter strictement le spawncontrol établi).
        ==========> le spawn local doit etre respecté à 100% autrement sur les autres clients, lors d'un tir l'entité risque d'etre instancié trop loin de son porteur : le serveur recoit du client les coords et les met à jour avant l'envoi vers les autres clients.
        ===========> il faut toujours passer par GOC_Animator2D
        ===> si le changement de button n'est pas reçu car perte de packet, alors Player::OnFire2() ne sera pas appelé et il n'y aura pas spawn.
        ====> privilègier le NetSpawn permet d'éviter ce probleme. remplacer NETSPAWNONLY à la place de LOCALANDNETSPAWN. Il faut désormais résoudre le probleme de pop trop loin du porteur.
        =====> lors du GameNetwork::PrepareControl(), il faut skipper la maj du physic s'il s'agit d'un pop initial
        ======> ajout de ObjectControlInfo::spawninit_ qui permet de skipper la preparation du physique avant l'envoi sur le reseau s'il s'agit du pop du spawn.
        =======> le pop à position initiale ne fonctionne pas à tout les coups à cause des pertes de packets
        ========> à la place de ObjectControlInfo::spawninit_ il faut toujours maintenir la position de pop initiale dans ObjectControl
        =========> 21/09/2021 - OK : utilisation de ObjectControl::holderinfo_::point1x_ et ObjectControl::holderinfo_::point1y_ en position initiale : ajout de ObjectControlInfo::UseInitialPosition() et ObjectControlInfo::CopyPreparedPositionToInitial()
        =========> sur client foreign, des mouvement sacadés des lames apparaissent apres plusieurs spawn
        ==========> pour les entites qui n'ont pas de GOC_Controller, ne pas utiliser GameHelpers::SetPhysicProperties() avec le smoothtransform
        =========> le grapin ne se decroche pas cote client foreigner entrainant une desynchro : cf GameNetwork::UpdateControl() et GOC_PhysicsGrapin
        ==========> 22/09/2021 - OK : cela arrive quand le RemoveObject de GameNetwork passe avant le lifetime de GOC_Destroyer : ajout dans GOC_PhysicsGrapin::OnSetEnabled() si false alors detachchains et release.
        =========> sur client foreign, parfois des lames repop en boucle, le grapin n'arrive pas à s'accroche et repop en boucle ...
        ==========> remettre les logs dans GameNetwork : pb de desactivation des ObjectControlInfo coté server ? voir si y'a pas des doublons d'ObjectControlInfo comme c'est déjà arrivé.
        ===========> 22/09/2021 - OK : dans GameNetwork::Client_RemoveObject() et GameNetwork::Server_RemoveObject() desactivé tous les ObjectControlInfo avec le bon nodeid (pas seulement le premier trouvé).
        ============> RAF : pour solutionner définitivement ce probleme, il faudrait implementer un pool d'ObjectControlInfo plutot avec deux listes (active/inactive)... de plus ça limiterai le nombre d'ObjectControlInfo.
        =====> correctif pour le spawn de bombe via clavier avec GOC_Animator2D : modification de ABIBomb::Use => spawnMode = LOCALSPAWNONLY.
        =====> encore des pbs de decalage de spawnstamp : entre GOC_Animator->GameNetwork::AddSpawnControl() et GameNetwork::HandlePlayServer_ReceiveUpdate()
        ======> cela peut arriver si une entity n'a pas pu etre créer du au manque dans un nodepool.
        =======> supprimer GameNetwork::NetSpawnControlAlreadyUsed() de GOC_Animator2D::SpawnEntity() car plus nécessaire (aucun cas LOCALSPAWNONLY utilisant Player::OnFire2() - cf "network - spawncontrol function callings.txt")
        ========> toujours des decalages : il faut trouver une compensation qui fonctionne
        ======> dans certain cas sur server ou foreign client, le grapin ne s'accroche pas alors qu'il l'est coté client spawner.
        =======> si GameNetwork::UpdateControl() impose une position au grapin avant qu'il ne soit accrocher (avant l'appel de GOC_PhysicsGrapin::HandleRoofCollision()) alors le grapin ne peut plus s'accrocher (se mettre en static).
        ========> modifier GameHelpers::SetPhysicProperties() qui se fait toujours en initial dans le cas des entités sans SmoothTransform : eviter le changement de position si faible ecart.
        ========> si il est accroché sur le client spawner, il faut qu'il le soit aussi sur le server et les autres clients. De meme s'il ne s'accroche pas coté client spawner.
        =========> dans GOC_PhysicsGrapin::AttachOnRoof() il faut integrer le code de GOC_PhysicsGrapin::HandleRoofCollision() en trouvant de plus la collisionshape et le tileindex correspondant au point d'accroche.
        ==========> OK ajout de World2D::GetCollisionShapeAt() et World2D::GetNearestBlockTile()
        ==========> il reste le cas ou GameNetwork::UpdateControl() detache la corde en laissant le grapin static accroché et ensuite GameNetwork realiser un RemoveTile(), le grapin reste toujours accroché.
        ===========> le collisionshape renvoyé dans GOC_PhysicsGrapin::HandleBreakContact() n'est peut-etre pas le meme que GOC_PhysicsGrapin::shapeInContact_.
        ============> 25/09/2021 - OK : enregistrer une liste de collisionshape de contact lors du World2D::GetCollisionShapeAt() et donc souscrire à ces shapes pour le HandleBreakContact()

    ✔ 26/09/2021 : pb lors du spawn oeuf avec mirubil car l'animation sur les clients foreign peut etre interrompue par GameNetwork::UpdateControl() avant le trigger envoyé par AnimatedSprite2D vers GOC_Animator2D pour le spawn.
        => cela peut aussi etre le cas pour d'autres spawn d'entité via AnimatedSprite2D -> GOC_Animator2D.
        ==> il faudrait que ce state ne puisse etre interrompu que par hurt ou dead par exemple.
        ===> il faut tester dans GameNetwork::UpdateControl() s'il est possible de changer d'un state à un autre
        ====> il faut tester si le state courant a un event TICKLOOP et si oui s'il est achevé
        =====> ald faire SetStateSilent, etablir une nouvelle fonction GOC_Animator2D::SetNextStateSilent à utiliser dans GameNetwork::UpdateControl qui va permet le changement d'animation lorsque les conditions le permettent (fin du TICKLOOP ou bien instantanement si pas de tickloop)
        ======> OK le 27/09/2021 : à verifier.

    ✔ 06/09/2021 : avec SLNet verifier si la synchronisation des clients au lancement fonctionne. Il semble y avoir desormais un decalage.
        => OK 27/09/2021 : du au packet loose, sans la simultation packet loose c'est parfait. On laisse en etat.

    ✔ 06/09/2021 : avec SLNet les clients n'arrivent pas à se connecter parfois. (à cause du packet loose). Il faut remedier à cela.
        => cf GameNetwork::HandleSearchServer()
        ==> OK 27/09/2021 : augmentation du delai de connection au server. NET_DELAYCHECKCONNECTION et NET_DELAYCONNECTSERVER

    ✔ 06/09/2021 : apres plusieurs suicides d'un avatar, l'avatar a des mouvements de plus en plus sacadés sur les autres clients car les informations n'arrivent plus avec le meme fps
        (il s'agit de l'effet de la limitation du nombre d'objetcontrol par envoi precedement realisé)
        => il faut compenser ces sacades par une simulation locale du mouvement : dans ce cas il faut que GOC_Move2D::IsPhysicEnable() soit vrai.
        => les GOC_Move2D::SetPhysicEnable(false) sont commentés.
        ==> les sacades sont presentes si NET_DEFAULT_LOSTPACKET > 0 avec NET_DEFAULT_UPDATEFPS=20fps
        ===> il faut verifier si les velocités sont correctes (peut-etre qu'il faut l'impulse à la place) : creer des draw debugs pour les velocités. les velocités sont bien présentes.
        ==> avec NET_DEFAULT_UPDATEFPS=1fps et NET_DEFAULT_LOSTPACKET=0 montre bien que la simulation physique est activé (l'entité n'est soumise qu'à la gravité)
        ===> le probleme provient de SmoothTransform. Si il est desactivé la simulation locale se fait (certes avec de mauvais resultat ... à améliorer)
        ====> modification de Urho3D::SmoothedTransform et GameHelpers::SetPhysicProperties() pour eviter que le smoothing continue sans arret (secousse incessante de l'entité)
        =====> Toujours des pbs de secousse : voir si c'est du à un pb avec la simulation physique locale (GOC_Move2D) : ACTIVE_NETWORK_LOCALPHYSICSIMULATION_MAINONLY active de la simulation local que pour les maincontroller.
        ======> Les buttons n'etaient pas setté sur le server si le button=0. Le server utilisait GOC_Controller::Update() en mode non forcé => il faut le forcer.
        =====> GOC_Move2D::SetPhysicEnable() suppression de l'activation/desactivation du SmoothTransform en fonction du GOC_Move2D::physicsEnable_
        ==> avec 10fps avec smoothtransform et sans perte de packet, les resultats sont pas mal.
        ===> avec perte de packet, la simulation va prendre le relai apres le smoothing mais cela donne pas mal de saccades ...
        ====> activer ACTIVE_NETWORK_LOCALPHYSICSIMULATION_MAINONLY pour ne plus simuler avec les buttons et utiliser la simulation par les velocités GOC_Controller::HandleNetUpdate ACTIVE_NETWORK_LOCALPHYSICSIMULATION_VELOCITY_NONMAIN
        =====> ne donne pas de bon resultat avec un fps > 5
        ===> reduction de NET_DEFAULT_SMOOTHTHRESHOLD à 0.001, les saccades sont reduites.
        ====> desactiver ACTIVE_NETWORK_LOCALPHYSICSIMULATION_BUTTON_MAINONLY (=utilisation de la simulation physique button pour tout les controllers) et desactiver ACTIVE_NETWORK_LOCALPHYSICSIMULATION_VELOCITY_NONMAIN (=ne pas utiliser la simulation locale par les velocités)
        =====> ajout de la coherence entre velocité et positionnement dans GameHelpers::SetPhysicProperties() pour limiter les saccades : les velocités sont la reference.
        ======> 14/09/2021 : OK les resultats sont beaucoup moins saccadés avec 15fps et 25% packetloose
        ======> pour améliorer encore, il faudrait pouvoir lissé le mouvement lorsque les velocités sont discontinues.

    ✔ 01/09/2021 : avec SLNet, les clients crashent lorsque le serveur est déconnecté.
        ==> voir Connection et Network::Start et Network::Stop et reprendre exactement la meme logique qu'avec Urho3D-kNet.
        ===> le probleme se situe dans Urho3D::Network::Update() qui a besoin de rakPeer_ or celui-ci est supprimé après l'appel de Urho3D::Network::HandleIncomingPacket() => Urho3D::Network::OnServerDisconnected() => GameNetwork::HandleConnectionStatus() => GameNetwork::StartLocal() => GameNetwork::Stop() => Urho3D::Network::Stop()
        ====> OK : Patch de Urho3D::Network::Update()

    ✔ 06/09/2021 : pb avec les effets de poussieres sur les Entités qui ne sont pas local du client et qui sont sur passerelles : l'effet dust spawn en permanence.
        => c'est surement du à la mise à jour des positions en continue.
        ==> cf GameNetwork::UpdateControl(), ce n'est pas le cas. Sollicitations en continue de GOC_Collide2D::HandleBeginContact et GOC_Collide2D::HandleEndContact(). cf Urho3D
        ===> RigidBody2D::ApplyWorldTransform() montre que la position varie et fait decrocher l'entité du sol.
        ===> ce probleme affecte le server puis reimpacte sur les clients
        ====> faire un essai en mettant le body en awake=false des que le sol est touché.
        =====> correctif de Urho3D::RigidBody2D::SetAwake() et ajout dans GOC_Collide2D::AddWallContact2D (meilleur choix : on aurait pu le mettre aussi dans GameNetwork::UpdateControl() mais pas exactement equivalent). Toujours des pbs.
        ======> il s'agissait de la position en y qui fluctue du aux approximation sur les float => il faut garder la position courante en y du node lorsque celui-ci est sur le sol lorsque la difference entre la nouvelle position et la position courante est faible.
        =======> OK : modification de GameHelpers::SetPhysicProperties()

    ✔ 17/08/2021 : pour solutionner le pb de l'envoi de message en reliable qui ne parviennent pas à destination, il faut tout passer par les ObjectControls
        => coté client, dans GameNetwork::HandlePlayClient_NetworkUpdate(), en meme temps que d'envoyer le gamestatus, envoyer les infos specifiques à delivrer tel que changetile, inventory etc...
        ==> ald d'envoyer directement via remoteevents, stocker les events à envoyer dans un buffer avec comme index le timestamp client.
        ===> structure => HashMap<!unsigned short int, Vector<NetObjectCommand> !> GameNetwork::objectCommands_;
        ==> le client devra envoyer les events à partir du dernier timerstamp client reçu du serveur et accusé reception du client => short unsigned GameNetwork::lastObjectTimeStamp_
        ===> à la reception du timestamp pris en compte par le serveur, le client peut supprimer les actions déjà pris en compte par le serveur pour le prochain envoi.
        => coté serveur, reception du timestamp client, update et renvoi vers le client avec le meme timestamp. de meme le serveur stocke dans un buffer les events à envoyer avec comme index le timestamp serveur
        ==> la partie delicate est l'envoi à l'ensemble des clients : il va falloir un timestamp serveur et que les clients renvoient le timestamp du serveur à la reception pour prise en compte.
        ==> le serveur envoi les infos specifiques vers chaque client.
        ===> les autres clients comparent le nouveau timestamp serveur reçu avec le dernier timestamp server pris en compte et renvoit le timestamp serveur vers le serveur pour prise en compte.
        ====> le serveur recoit donc deux timestamp, un client et un retour serveur.
        => à modifier GameNetwork::Server_SendObjectCommand et GameNetwork::Client_SendObjectCommand() pour creer et stocker les NetObjectCommand dans GameNetwork::objectCommands_.
        ==> 27/08/2021 : pb avec GameNetwork::HandlePlayServer_ReceiveUpdate() lors de la reception/copie coté server d'un ObjectCommand client => ok oublie d'ajouter de newObjectCommands_ = true
        ===> OK : 29/08/2021 - A Verifier avec toutes les commandes.

    ✔ 15/08/2021 : le changement d'un slot d'equipment sur un client n'est pas pris en compte sur le serveur. (le load equipment ok)
        => OK : correctif dans la logique de GOC_Inventory::LocalEquipSlotOn()
        ==> Il faut maintenant solutionner le pb de message reliable qui n'arrive pas à destination
        => manque l'implementation du remove item
        ==> OK : modification de GOC_Inventory::NetServerSetSlot permettant de traiter le cas ou le type est nul.

    ✔ 11/08/2021 : pb animation avec hurt
        => 15/08/2021 : revision de la strategie : la simulation doit etre realisée des 2 cotés clients et server. En local, le State Hurt est appliqué directement => Le state Hurt provenant du network ne doit pas etre appliqué.
            Cela permet coté joueur d'avoir l'impression d'avoir touché. les dps sont toujours conserver du coté serveur (autoritatif)
        ==> OK : Modification de GameNetwork::UpdateControl(), Modification de GOC_Life::ReceiveEffectFrom() pour enlever la tempo
        ===> le pb c'est les equipments qui ne sont pas repliqués (les valeurs de defense et d'attaque ne seront pas les memes entre client owner et les autres clients)

    ✔ 13/08/2021 : pb si le serveur est lancé et que tous les clients ne sont pas connectés
        => avant les modifications d'aout, il etait possible qu'un nouvel avatar arrivé d'un nouveau connecté (après le spawn des premiers clients), fonctionne bien sur les autres clients (comme sur les MMO)
        ==> solution 1 : laisser tel quel car cela correspond au fonctionnement de base d'un jeu en arene pvp, il faudrait creer une UI "salle d'attente".
        ==> solution 2 : remodifier pour avoir le meme comportement avant aout cad type MMO
        ===> Reserver sur tous les serveurs et clients la meme plage de nodeid pour les avatars des joueurs.
        ====> par clientid reserver MAX_NUMPLAYERS nodes locaux => nodes à reserver = GameStatus::MAX_NUMPLAYERS*GameStatus::MAX_NUMNETPLAYERS
        =====> OK : ajout de GameStatus::ReserveAvatarNodes(), modification ClientInfo::CreateAvatarFor & PlayState::SetPlayers() et suppression du code specifique à PLAYSTATE_CLIENT_LOADING_SERVEROBJECTS (plus nécessaire)

    ✔ 09/08/2021 : le suicide (la mort et respawn d'un player) ne fonctionne pas correctement.
        => à la mort du player, l'animation dead n'est pas joué coté serveur. il n'y a pas de mort de l'avatar chez les autres clients.
        => la reactivation passe par le changement de gamestatus PLAYSTATE_STARTGAME sur le client et envoi au serveur qui reactive le player, mais le client continue d'envoyer le status
        ==> voir coté serveur GameNetwork::HandleServer_MessagesFromClient
        ===> modification mineure dans GameNetwork::HandlePlayClient_ReceiveClientUpdate pour envoyer le gamestatus PLAYSTATE_RUNNING apres reception de la bonne prise en compte par le serveur.
        ====> encore certains problemes apres repop sur le serveur.
        ====> lorsque le clic sur la messagebox de repop coté client est fait avant que le serveur n'ait stopper le player, alors repop coté client et du coté serveur le player est stoppé et l'avatar disparait.
        =====> soit temporiser pour le clic que le serveur ait bien stopper le player.
        =====> soit modifier pour que le stop player coté serveur soit realiser des que l'avatar meurt (ce qui est plus logique)
        ======> modifier Player::OnDead(), supprimer l'envoi/reception/accuséreception de gamestatus PLAYSTATE_ENDGAME
        =======> attendre la fin de l'animation Dead pour stopper le player : modification de GOC_Animator2D::ToDestroy(),
        ========> GOC_Animator2D::ToDestroy() envoi directement GO_DESTROY -> Player::OnAvatarDestroy() -> GameNetwork::Get()->Server_SetActivePlayer() -> Player::Stop()
        ========> apres un changement d'avatar vers Petite ou Elsarion, coté serveur le processus ne parvient plus à GOC_Animator2D::ToDestroy()
        =========> OK : modification de GameNetwork::UpdateControl() pour eviter de passer du STATE_DEAD vers STATE_EXPLODE sinon GOC_Animator2D reste bloquer sur STATE_DEAD et ne peut parvenir à GOC_Animator2D::ToDestroy()
        =======> l'envoi du gamestate en message reliable (voir aussi pour les changetiles) est parfois tres long voir non realisé (bug coté kNet ?), du coup le respawn du player coté serveur peut aller
            jusqu'à plusieurs secondes (5-6sec)
        ========> OK : lorsque le jeu est en PlayState, obtenir le gamestate du client via GameNetwork::HandlePlayServer_ReceiveUpdate()

    ==> 14/08/2021 : apres suicide et respawn, l'avatar du coté des autres clients et server n'a pas les physic colliders actif. Le probleme est regler en changeant d'avatar.
        => verifier la reactivation sur les autres clients et server.
        ==> OK : modification de GameHelpers::SetPhysicFlipX() pour ne plus utiliser RigidBody::GetCollisionShapes() qui ne retourne que les shapes actives attachées au body.
            car dans notre cas GOC_Animator2D::physicFlipX_ doit être remis à false lors de GOC_Animator2D::Stop() et il faut donc utiliser GameHelpers::SetPhysicFlipX() alors que les shapes sont inactives.
        ===> Elsarion n'apparait pas contrairement aux autres
        ====> GOC_BodyExploder2D::HandleWaitStateForHide desactive le RigidBody2D et le Drawable2D : il convient de toujours les reactiver
        =====> les reactiver dans GOC_Destroyer::OnWorldEntityCreate()
        ======> OK

    ✔ 01/08/2021 : Modification majeure ObjectControl, spawncontrols
        1) ServerSide : entity local server => objectcontrol.clientid_=0
           OK => spawn un servernodeid GameNetwork::AddSpawnControl() et n'a pas besoin du retour client d'un clientnodeid
        2) ClientSide : entity server (ou autre client) sur client => objectcontrol.clientid_=0 || => objectcontrol.clientid_!=clientID_
           OK => spawn un clientnodeid GameNetwork::AddSpawnControl() et attend le retour server d'un servernodeid (GameNetwork::HandlePlayClient_ReceiveServerUpdate)
        3) ClientSide : entity local client => objectcontrol.clientid_=clientID_
            => spawn un clientnodeid GameNetwork::AddSpawnControl() et attend le retour server d'un servernodeid (GameNetwork::HandlePlayClient_ReceiveClientUpdate)
        4) ServerSide : entity client sur server => objectcontrol.clientid_!=0
            => spawn un servernodeid GameNetwork::AddSpawnControl() et attend le retour client d'un clientnodeid (GameNetwork::HandlePlayServer_ReceiveUpdate)
        5) pb de desynchronisation à cause du spawnstamp
        => si le serveur ne spawn pas une entity pour une quelconque raison, il faut s'assurer que le spawnstamp coté serveur soit synchrone avec le client.
        ==> 08/08/2021 : OK : ajout de receivedSpawnStamps_ et localSpawnStamps_ qui permet de maintenir un etat synchone du spawnstamp
        6) pb avec ObjectControlInfo::active_ et ObjectControl::states_::enable_
        => revision de la strategie
        ==> ObjectControlInfo::active_ est true à la creation d'une entity. ObjectControlInfo::active_ est false à sa destruction.
        ===> aucune reactivation possible via le circuit réseau des ObjectControls
        ===> pour réactiver il faut envoyer une commande réseau
        ==> ObjectControl::states_::enable_ s'effectue sur le client maincontroller et est répercuté sur le réseau.

    ✔ 23/06/2021 : avec plusieurs clients, l'ensemble des server/clients se mettent à ralentir lorsque l'un des clients pop un oeuf mirubil.
        => pas reussi à reproduire ce bug en mode net local, mettre ACTIVE_NETSIMULATELATENCYANDPACKETLOSS on
        ==> reussi à le reproduire mais non systematiquement,
        ===> En cas de perte de packet il faut etre sur que coté des autres clients cela popera.
        ====> l'oeuf mirubil comme tout autre objet replicated est spawné directement sur serveur ou client maincontrolled. (tout au moins pour le spawn via GOC_Animator2D::SpawnEntity)
        =====> il serait interessant de pouvoir spawner directement sur tout client egalement (mais pose surement le probleme de changement de nodeid). ce serait bien aussi pour GOC_BodyExploder2D et le drop item.
        =====> 1) tous les clients et le server spawnent tout d'abord en LOCAL
        ======> sur les clients, les ObjectControl necessitant une replication seront stockés dans la table temporaire clientSpawnControls_
        ======> sur serveur et clients, ObjectControl::states_.stamp_ est incrementé (voir comment les stocker ? sur l'ObjectControl du parent ?).
        =====> 2) pour une entity replicated, le server envoie à tous les clients le nodeid attribué ainsi que les infos pour la traçabilité tel que le type d'objet, le node "parent" et l'objectStamp
        ======> le node "parent" est l'entity qui a spawné le nouvel objet, l'objectStamp est un int permettant de faire la correspondance du nouvel objet entre le serveur et le client.
        ======> ces infos doivent etre maintenu dans l'ObjectControl
        ======> le state ObjectControl::states_.idle_ devient ObjectControl::states_.enable_ et ajout de ObjectControl::states_.stamp_, ObjectControl::holderinfo_.id_ sera utilisé pour indiquer le node parent.
        =======> à la reception d'un ObjectControl server par un client, le client verifie dans clientSpawnControls_.
        ========> Si l'ObjectControl reçu correspond à une entrée dans clientSpawnControls_ (ObjectControl::states_.stamp_, ObjectControl::holderinfo_.id_)
        =========> l'entrée est supprimé de clientSpawnControls_ et le lien est établit entre le nodeid server et le nodeid local (evitant le ChangeID). L'entrée est également supprimé lors de la destruction du node.
        ==========> ajouter clientNodeID_ dans ObjectControlInfo
        ========> Sinon celui-ci est ignoré.

    ✔ 22/06/2021 : le changeEntity de petite lorsque changement d'avatar durant la nuit n'est effectif que sur le client main et le serveur.
        => OK : modification de GOC_Animator2D::ChangeEntity (les clients nonmain n'ont pas pas de currentTemplate)

    ✔ 22/06/2021 : apres la mort d'un client et son repop, il ne perd plus de vie
        => pb coté serveur : au repop les collisionshapes de l'avatar n'ont pas les memes maskbits que celles du pop initial.
        ==> en changeant de viewZ, il n'y a plus de pb.
        ===> OK : dans Player::Start() ajout de GOC_Destroyer::UpdateFilterBits()
        ====> RAF : voir si une autre solution est preferable (mettre dans Actor::Start() ... ou en amont dans GOC_Destroyer ...)

    ✔ 08/06/2021 : utilisation de la potion de soin ne fonctionne pas sur les clients
        => etant donné que seul le serveur permet la modification du state energie/pdv,
        ==> dans ce cas, le client doit pouvoir utiliser l'effet immediatement et envoyer au serveur l'utilisation d'un objet
        ===> la mise à jour du state (pdv dans le cas de la potion), ne reprendra qu'apres envoi d'une confirmation par le serveur. Si le serveur n'envoit pas de confirmation au bout d'un certain délai, la mise à jour sera débloquer.
        ===> cf UISlotPanel::HandleSlotDragEnd -> GOC_ZoneEffect::HandleContact -> EffectsManager::AddEffectOn -> EffectsManager::ApplyEffectOn -> GOC_Life::ReceiveEffectFrom ... GOC_Controller::Update,
        ====> dans GOC_ZoneEffect::HandleContact il faut si CLIENTMODE setter une propriété permettant la modification du comportement dans GOC_Life::ReceiveEffectFrom et GOC_Controller::Update et l'envoi d'un event vers le server.
        =====> de façon générale, tout item retiré de l'inventaire doit faire l'objet d'un event vers server.
        =====> OK : il reste à initialiser coté serveur l'inventaire en cas de LoadStuffOnly.
        ======> 17/06/2021 - RAF : dans Player::LoadStuffOnly() obtenir le bon savedPlayerFile_ pour le serveur correspondant au bon player coté Client

    ✔ 22/06/2021 : resoudre le pb de synchronization serveur/clients au lancement du mode arena.
        => cf PlayState::HandleInitialize, GameNetwork::HandleClient_MessagesFromServer et GameNetwork::HandleServer_MessagesFromClient
        ==> OK modification de GameNetwork::HandleClient_MessagesFromServer et ajout de GameNetwork::serverGameStatus_ utilisé en mode client.

    ✔ 21/06/2021 : les entity ne subissent plus les degats en regard de la barre de vie.
        => OK correctif dans GameNetwork::UpdateControl() pour permettre l'update des GOC_Controller meme si idle

    ✔ 08/06/2021 : lorsque le serveur est supprimé, les clients se relancent en mode local mais les avatars des autres clients pop aussi.
        => sans changer d'avatar sur les clients, il n'y a pas de probleme. Verifier le change avatar coté client.
        ==> lors du change avatar, l'avatar est detruit. cela provient de GameNetwork::ChangeObjectControlIdleState(ObjectControlInfo& cinfo) si le state est enable=false => send de WORLD_ENTITYDESTROY.
        ===> Il n'y a alors plus de subscriber pour un nouveau WORLD_ENTITYDESTROY.
        ===> Correctif OK : ne pas envoyer WORLD_ENTITYDESTROY.
        ====> pb pour la destruction des Lames et des Bombs : possibilité de laisser activer le LifeTimer de GOC_Destroyer (cf World2D::NetSpawnEntity) => ok pour les Lames mais pas pour les Bombs qui n'ont pas de LifeTimer
            Les Bombs sont detruites suivant la succession d'Etats state_use -> state_dead -> state_destroy => verifier l'utilisation de GOC_Animator2D::ToDestroy() sur les autres clients.
        =====> GOC_Animator2D::ToDestroy() OK sur les autres clients.
        ======> Au bout d'un moment les Bombs ne pop plus sur le serveur et les autres clients => verifier avec une ancienne version => aucun pb avec la version du 31/05,
        =======> voir si seules les modifications dans GameNetwork::ChangeObjectControlIdleState() ont impactées les bombes.
        ========> en envoyant le WORLD_ENTITYDESTROY dans GameNetwork::ChangeObjectControlIdleState il n'y a plus de probleme donc dilemme
        =========> modifier le change avatar et laisser le WORLD_ENTITYDESTROY ?
        ===========> le state idle ne doit pas etre utilisé pour detruire ... trouver un correctif pour les bombes et enlever le WORLD_ENTITYDESTROY
        ============> 21/06/2021 : OK à la place du idle, utilisation le totaldpsreceived

    ✔ 14/06/2021 : Apres avoir supprimer le serveur, essayer de spawner des lances => crash
        => apres suppression du serveur, les clients n'ont plus de network
        ==> Crash dans GOC_Animator2D::SpawnEntity
        ===> Correctif OK !

    ✔ 08/06/2021 : Lorsque l'avatar d'un joueur (client) est touché par un monstre, coté serveur l'avatar semble bloqué quelque temps alors que du coté de ce joueur (client), l'avatar répond bien.
         pendant ce temps de bloquage coté serveur l'avatar se fait taper et perd de la vie.
        => Test réalisé avec le pop d'un Elsarion par Mirubil et attaque de celui-ci par un joueur.
        ==> le client gérant la position, il faut verifier ce qui empeche l'update de cette position coté serveur.
        ===> cf. GOC_Controller::Update(const ObjectControlInfo& info) avec le bloquage pour le STATE_HURT.
        ====> OK modification de GOC_Controller::Update pour permettre le déplacement.

    ✔ 03/06/2021 : pb de SpawnEntity avec l'Oeuf de Mirubil puis Spawn d'Elsarion
        ==> verifier les coordonnees de pop d'Elsarion ... il semble être détruit des le spawn (sa position ne serait pas setter ?)
        ===> OK : correctif dans GameNetwork::ChangeObjectControlIdleState() => priorité au NetSpawnEntity
        ===> OK : Correctif dans GameNetwork::HandlePlayServer_ReceiveUpdate => creer le bon ObjectControl coté serveur lorsque le spawn d'entité serveur est demandé par un client.
        ===> OK : durant le World2D::NetSpawnEntity il faut bien mettre GOC_Move2D::SetPhysicEnable() à false pour permettre à l'entité d'être déplacé par les datas provenant du serveur.

    ✔ 03/06/2021 : les Effects et leurs ticks ne semblent pas reproductibles coté clients.
        => OK : erreur avec angle (NaN value) dans EffectsManager::ApplyEffectOn => si nan mettre angle à 0.f
        => OK : modification GOC_Life::ReceiveEffectFrom pour permettre aux NetPlayers de s'attaquer.

    ✔ 13/08/2019 : ajouter les modifications de map (WALLBREAKER WALLBUILDER) en reseau
        => 05/06/2021 : OK ajout de GameNetwork::ChangeTile et NetCommand::CHANGETILE
        ==> OK : envoi de l'event ObjecCommand(CHANGETILE) dans ABI_WallBreaker et ABI_WallBuilder

    ✔ 03/06/2021 : pb de spawn directionnel avec la lance ou bien le pistolet
        ==> la lance est REPLICATED : spawné via GameNetwork::ChangeObjectControlIdleState() -> World2D::NetSpawnEntity()
        ==> la bullet ne l'est pas : spawné via GOC_Animator2D::SpawnEntity()
        ===> le spawnAngle_ si utilisation de la souris est setté par GOC_Animator2D::SetShootTarget() dans ABI_AnimShooter::Use()
        ===> cet angle n'est pas transmis par le reseau.
        ====> voir pour le transmettre via ObjectControl.holderinfo_.point1x_, ObjectControl.holderinfo_.point1y_
        =====> lors du changement de ObjectControl.states_.animation_ vers STATE_SHOOT, utiliser GOC_Animator2D::SetShootTarget(Vector2(ObjectControl.holderinfo_.point1x_, ObjectControl.holderinfo_.point1y_))
        ======> Setting de ObjectControl.holderinfo_.point1x_, ObjectControl.holderinfo_.point1y_ dans ABI_AnimShooter::Use().
        =======> OK pour l'orientation de la lance qui est replicated. RAF le flipX est mauvais si l'angle est sup à 90° et la lance fait des degats au lanceur.
        ========> voir pour recalquer GOC_Animator2D::SpawnEntity() dans World2D::NetSpawnEntity()
        =========> OK : correctif dans GameNetwork::PrepareControl() d'une erreur sur l'obtention de la direction via Variant (Float remplacé par Vector2) et modification de World2D::NetSpawnEntity()
        =======> pour la bullet qui n'est pas replicated ... il faut que GOC_Animator2D prenne en compte (si NetWorked) le Vector2(ObjectControl.holderinfo_.point1x_, ObjectControl.holderinfo_.point1y_) transmis.
        ========> OK modification de GOC_Controller::Update(const ObjectControlInfo& info) qui met à jour les composants apres reception via le Net de cette donnée.
        =====> 04/06/2021 : OK la lance set remise en non repliqué (local) afin d'éviter les problemes de collision/stick

    ✔ 03/06/2021 : la pluie n'est pas synchrone => vérifier WeatherManager::SetRainTime()
        => OK : Remplacer le Random par GameRand

    ✔ 23/10/2019 : l'avatar du server n'apparait pas sur certains clients
        -> il n'y avait plus de reservation de node pour les avatars et donc un node utilisé pour un particule effect prenait la place du nodeid de l'avatar du server.
        --> solution1 : reservation des nodes lors du PLAYSTATE_CLIENT_LOADING_SERVEROBJECTS => cela ne fonctionne qu'une fois au chargement !
        ---> OK : modification de GameNetwork::HandlePlayClient_ReceiveServerUpdate() et les clients auront toujours le SetEnabledServerObjectControls(true)
        --> solution2 : s'assurer que tous les nodes soit dans des pools (donc numeros deja reservés et alloués)
        ---> modification des GameHelpers::SpawnParticleEffect et autre pour utiliser des pools.

    ✔ 22/10/2019 : les entity spawné comme le ghost vampire ne sont pas bien flippé. Ceci apparait depuis les modifications apportées coté réseau septembre 2019.
        => OK : reapplication de l'ancien code anterieur au 26/09/2019 dans GameHelpers::SetPhysicProperties() pour assurer le flipx si direction inf à 0
        ==> pb de nouveau sur churros, vampire ... cf correctif du 26/09/2019
        ===> OK : reapplication du code du 26/09/2019 et modification dans GOC_Animator2D::SpawnEntity

    ✔ 23/10/2019 : les bullets ne doivent pas etre controlés via le reseau car trop lent.
        -> OK : Simplement changer le replicatedmode dans Data/Objects/Objects.json

    ✔ 22/10/2019 : Les bullets ne semblent plus fonctionner en reseau. Les premieres sont bien spawnées.
        -> OK : le probleme est dans GameNetwork::Server_RemoveObject() qui reset le cinfo.node_
           ce qui empeche GameNetwork::Server_PrepareObjectControlsMessages() d'envoyer l'objectcontrol sur le reseau.

    ✔ 19/08/2019 : pb d'affichage des equipments (dimension des épées) coté client ou serveur apres un add equipment transmis via le network.
        -> cf GOC_Inventory::EquipSlotOn(Node* node)
        --> OK 22/10/2019 : Utiliser pour les slots armes AnimatedSprite2D::SwapSprites(keepProportion=true)

    ✔ 15/10/2019 : lors du pop d'un client, les monstres detruits sur le serveur sont quand meme spawnés.
        -> pour cela desactiver simplement dans Map::SetEntities_Add la creation des entités dynamiques en ClientMode.
        --> les entités apparaissent alors en position ZERO et non pas de charactermap appliqué.
        --> desactiver les entités simplement et attendre le serveur : modifier Map::SetVisibleEntities pour prendre en compte le GameNetwork
        ---> 16/10/2019 : OK !

    ✔ 15/10/2019 : Mettre les bombes en GO_Pools.
        -> OK : ajout dans Ability de ABIBomb + modification GOC_Animator2D::SpawnEntity() + ajout de l'ability dans avatar-junkelspil.xml + modif junkelspil.scml pour modifier le Trigger par Entity_ABIBomb ald Entity_Bomb

    ✔ 09/10/2019 : REFACTOR
        -> reintegrer le code ajouter à URHO3D::Connection dans GameNetwork
        -> modifier les boucles d'update network : integrer la creation du messages à envoyer directement dans GameNetwork et mettre à disposition ce buffer dans les Connections.
        -> dissocier les boucles de send et de receive dans GameNetwork
        --> HandlePlayServer_NetworkUpdate et HandlePlayClient_NetworkUpdate sont lancés avant l'envoi sur le reseau.
        ---> creer le buffer commun pour tous les clients et ensuite les buffers specifiques par client.
        --> creer HandlePlayServer_ReceiveUpdate et HandlePlayClient_ReceiveUpdate qui seront lancés après la reception.
        ---> les controles des entités seront updatés par ces procédures.
        -> OK le 12/10/2019 : pop des avatars
        --> RAF : régler les pbs avec Lames et Bombes
        ---> Lames OK
        ---> Bombes : modification de HandlePlayServer_ReceiveUpdate pour prendre en compte le changement d'owner d'un objectcontrol.
            Lorsqu'un objectcontrol est créé/activé sur le serveur, l'owner est 0 (serveur) ou != 0 (client) cf GameNetwork::GetOrCreateServerObjectControl()
            Lorsqu'un objectcontrol est désactivé, l'owner revient à 0. cf GameNetwork::Server_RemoveObject() et GameNetwork::ChangeObjectControlIdleState()
            HandlePlayServer_ReceiveUpdate exclut les messages provenant des clients qui ne sont pas propriétaires.
        ----> Ajout de DISABLECLIENTOBJECTCONTROL pour desactiver coté client un clientObjectControl utiliser par un autre client ou bien un clientObjectControl déjà notify idle sur le serveur.
            Ce qui permet de reduire le buffer envoyé client-> server
            Ce message est envoyé par le serveur s'il reçoit pour chaque nodeid
                -un owner different de celui dejà affecté (Pour changer de propriétaire, l'objectControlInfo doit déjà avoir le owner_ à 0).
                -un meme owner avec un changement de state vers idle.
        ----> Cette solution ne permet pas de maintenir 2 clients qui s'approprient un meme nodeid.
            En effet, si deux clients font spawnés un node de meme ID alors le serveur donne la propriété au client dont le message est arrivé en premier.
            Ce qui fait que sur le second client, ce node va blitter entre 2 positions. L'une controlée en local et l'autre par le serveur.
        ----> OK le 13/10/2019 : Garder ce code et passer les bombes en GO_Pools.

    ✔ 09/10/2019 : enquêter sur les messages reliable de knet. Car pas mal de probleme de non reception
        -> il est possible que la simulation des pertes Network utilisé dans FromBones en activant ACTIVE_NETSIMULATELATENCYANDPACKETLOSS ne soit pas effective à 100% avec kNet
        -> vérifier les sources Network::SetSimulatedLatency et Network::SetSimulatedPacketLoss
        --> c'est pourtant gérer via Connection::ConfigureNetworkSimulator et kNet::NetworkSimulator

    ✔ 28/09/2019 : les bombes n'appparaissent pas toujours dans certaines sessions (clients et/ou serveur) et peuvent causées un crash
        -> pb de viewZ=0, pb dans GameNetwork::HandleObjectControlIdleChanged() ?
        -> les bombes ne fonctionnent plus
        --> les bombes sont des objects qui ont un replicated state mais dans ObjectPool a été introduit OBJECTPOOL_LOCALIDSONLY qui force les nodes à toujours etre LOCAL.
        --> on peut les mettre en local et les objectcontrols feront le restent
        --> ou bien utiliser un GO_Pool
        --> ou bien corriger le pb
        ---> le 07/10/2019 : en gardant le replicatedstate, ajout crucial de la reactivation dans GameNetwork::Client_CommandChangeNodeID
            autrement comme le node a été enlevé via GameNetwork::Client_CommandRemoveObject, l'objectcontrol est dans l'etat !actived_.
        ---> voir pour modifier ObjectPoolCategory::ChangeToReplicatedID pour accepter l'option OBJECTPOOL_LOCALIDSONLY
        -----> ajout de ObjectPool::ChangeToID() qui accepte le changement de node local, modification de Scene::NodeIDChanged()
            modification de Connection::ProcessSendServerObjectControls() pour supprimer le TransferMessage, qui pose probleme au spawning des bombes
            modification de Connection::ProcessReceiveClientObjectControls() pour copier l'ObjectControl recu directement dans l'objectControl preparé,
            ce qui permet d'avoir le type des Controllables.
        ------> toujours des problemes avec les bombes, verifier que le ChangeToID se déroule correctement, vérifier la chaine avec ObjectPool::Free(Node)
        -------> cette fois-ci, le serveur genere 2 bombes
                 la premiere est genéré par GameNetwork::ChangeObjectControlIdleState
                 la seconde par la commande REQUESTOBJECT
        --------> 1ere approche : si OBJECTPOOL_LOCALIDSONLY, utiliser GameNetwork::AddObjetControl ald GameNetwork::Client_SendRequestObject dans Map::AddEntity
        ---------> approche incomplete si le serveur n'a pas de nodeid correspondant disponible
        ----------> les bombes sont alors ajoutés par le client comme des clientObjects
                    ce qui cause pb dès qu'un autre client les a utilisés, sur le serveur le owner de l'objectcontrol est affecté à la connection qui l'a utilisé en premier
                    et sur le premier client l'object control est bien un clientobject.
                    du coup les autres clients recoivent des clientobjects et des serverobjects avec le meme id generant un un switch permanent de l'etat idle_.
        -----------> OK 13/10/2019 correctif apporté suit au Refactor , mais ne permettra jamais à plusieurs clients d'utiliser un meme nodeid. => passe en GO_Pools pour les bombes

    ✔ 19/09/2019 : certaines lames restent activées sur les autres clients/serveur
        --> la lame recoit bien le idle=true et est bien restauré dans le pool mais recoit juste apres un idle=false et est respawnée
        ---> vérifier le timestamp dans Urho3D::Connection
        ---> reduction de MAX_DELTASTAMP1 à 16 et MAX_DELTASTAMP2 à 32 dans Connection
        -> OK
        --> 07/10/2019 : reapparition du probleme, voir avec l'impact des modifications apportées sur ce probleme
        ---> aucun impact, le probleme existe déjà sur la version du 19/09. En recompilant sans ACTIVE_NETSIMULATELATENCYANDPACKETLOSS, il n'y a plus de pb.
            Le pb provient de la perte possible de la commande ERASENODE. Pourquoi ? le message est censé être reliable comme tous les messages d'ailleurs.
        ----> voir pour se passer completement de cette commande avec uniquement l'envoi du idle_.
        -----> dans GOC_Destroyer::Destroy() utiliser GameNetwork::Server_RemoveObject sans envoi de netmessage
        -----> modification de GameNetwork::Server_RemoveObject : mettre l'ObjectControl en SetReadyToSend
        -----> modification de Connection::ProcessSendServerObjectControls() pour envoyer tous les objectcontrols qui sont readytosend (meme ceux !actived_).
        ------> exclure de la commande ERASENODE, la connection qui est main pour ce noeud
        ------> 08/10/2019 : OK ajout du parametre allconnections dans GameNetwork::Server_RemoveObject utilisé pour les players uniquement

    ✔ 28/09/2019 : pb lors de la mort d'un player coté Client : pas de respawn possible.
        -> 08/10/2019 : il s'agit d'une erreur de creation implicite de "Player" du à l'utilisation de Player::LoadStuffOnly()
        --> le xml contenant le stuff contient un GOC_Controller de type GO_Player qui envoie au chargement du stuff l'event GOC_CONTROLLERCHANGE
            GOManager::HandleGOChangeType() l'intercepte et enregistre un nouveau activeplayer non souhaité
        ---> OK : Ajout en fin de procédure Player::LoadStuffOnly(), d'un kill adéquate (send GOC_LIFEDEAD et GOC_Destroyer::Destroy())

    ✔ 04/10/2019 : modifications ObjectControls
        -> envoi d'un message ou deux messages (nodes server et retour des nodes du client) plutot que de nombreux messages (1 par node)
        -> compression ok LZ4
        --> amelioration possible : un objectcontrol c'est 72bytes + 4bytes pour le nodeid. réduire au max les données à envoyer. si pas de changement garder une version déjà compressée
            et la renvoyer tel quel.

    ✔ 30/09/2019 : GO_Pools::AddPool() reprend de nouveaux numeros à chaque appel. les numeros ne seront alors plus synchro entre serveur et clients dés qu''un client quitte le mode de jeu et y revient
        -> OK : Reserver une seule fois et simplement restaurer les pools après chaque session PlayState

    ✔ 28/09/2019 : crash du client en mode arena lorsque celui-ci retourne au mainmenu et revient dans le mode arena
        -> GameNetwork::PurgeObjects supprime les nodes qui sont des poolnode
        -> Correctif GameNetwork::HandlePlayServer_NetworkUpdate() reset de allClientsRunning_ et allClientsSynchronized_ permet de relancer un client déjà connecté qui est retourné au mainmenu

    ✔ 26/09/2019 : correctif de l'orientation des lames, correctif de l'orientation de Churros, Vampire ... qui ont une orientation inversé
        -> OK : ajouter le set de GOA::DIRECTION dans GameNetwork::PrepareControl() et sa prise en compte dans Ability::Use(static)
        -> OK : suppression du FlipX dans GameHelpers::SetPhysicProperties()

    ✔ 26/09/2019 : Lorsqu'un coup est porté sur un client, GOC_Life::ApplyForceEffect est bien appliqué mais un décalage se produit ensuite en sens inverse de cet effet
        -> vérifier la force appliquée et son point d'application coté client émetteur et client recepteur.
        -> le différé de positionnement introduit dans GOC_Controller::Update() n'est pas suffisant.
        --> Il faut compenser les latences client->serveur->client.
        ---> OK : ajout int updatedState_, cf GOC_Controller::Update()

    ✔ 13/09/2019 : le grapin sur les clients autre que spawneur n'est pas bon au niveau du lien de la chaine avec l'avatar.
        --> sur les clients l'avatar "!MainControlled" a un RigidBody STATIC ce qui pose pb pour l'établissement du lien
        --> mettre les RigidBody en DYNAMIC regle ce probleme (cf GOC_Controller::ChangeAvatar())
        ---> cela créé des problemes de sacade dans le saut desormais sur les autres clients du à GameHelpers::SetPhysicProperties() qui s'assure qu'il n'y ait pas trop de gap de positionnement reseau.
        ---> le code dans GameHelpers::SetPhysicProperties() est indispensable pour eviter que l'entité reste bloquée.
        ---> dans GOC_PhysicsGrapin::AttachOnRoof(), le centre de masse obtenu avec GetBody()->GetWorldCenter() est différent avec des Body de type different (STATIC et DYNAMIC)
        ---> la contrainte Revolute2D ne semble pas etre créée entre le dernier maillon de la chaine et l'entité à attacher.
        ----> pour compenser ces pbs, communiquer en plus la position du node et la position du centre de masse pour l'entité à attacher.
            ---> à réception dans GameNetwork::HandleObjectControlHolderChanged(), setté la position du node et utiliser GOC_PhysicsGrapin::AttachOnRoof(grapin, cm_entité, numlinks)
        ----> OK, mais la chaine n'est pas tendue. Pb de poids ? l'entité attachée étant un STATIC, la simulation n'applique pas de poids ?
        -----> avec l'entité en DYNAMIC -> la corde n'est toujours pas tendue ...
        ------> la simulation n'est pas ok car aucune gravité et force ne s'applique sur les clients avec l'option SetPhysicEnable(false)
        ------> lorsque attachOnRoof, il faut une simulation complete avec gravité et forces => mettre GOC_Move2D::SetPhysicEnable(true, true),
                au moment du détachement de la chaine, remettre physicEnable à sa valeur initiale.
        ------> NOK, surement le resultat des modifications de position via le reseau, voir pour desactiver ces modifications
        ------> NOK en desactivant les modifications de position et en corrigeant GOC_Controller::Update(const ObjectControlInfo& info) pour appliquer completement les entrées buttons
        ------> Il manque l'application des forces et velocités appliquées à l'attachedNode juste avant la création de la chaine. Le dynamique initial en somme.
        -------> 25/09/2019 - OK : Ajout Box2D::SetDynamics() et GetDynamics() et ajout rotation initiale du grapin (ajout float ObjectControl::holderinfo_.rot2_),
                il n'est plus nécessaire d'activer GOC_Move2D::SetPhysicEnable - l'update des Data dynamics dans GOC_Controller suffit.

    ✔ 20/09/2019 : modifier GOC_Life pour que sur les clients l'animation passe au STATE_HURT dès qu'un coup est porté
        -> est-ce possible depuis que les clients sont en STATIC body ? -> modif de GOC_Collide2D::HandleBeginContact() pour appliquer la collision en ClientMode
        --> OK : modification de GOC_Life::ApplyAmountEnergy(), GOC_Life::HandleReceiveEffect() et GOC_Controller::Update() pour eviter l'interruption du STATE_HURT
        --> la force du coup n'est pas appliquée sur les !maincontrolled, du coup l'animation STATE_HURT apparait puis il y a un differé non souhaitable pour l'application de la force
        ---> en STATIC BODY aucun force ne peut etre appliquée, soit repasser en DYNAMIC BODY soit simuler de la force par un déplacement
        ---> OK : les GOC_Controller repasser en DYNAMIC BODY et Modification du GOC_Collider2D::ApplyForceEffect déplacé dans GOC_Life::ApplyForceEffect et utilisation de RigidBody2D::ApplyLinearImpulse() ald RigidBody2D::ApplyForce()
            + modification de GOC_Controller::Update() pour que le changement de position se réalise une fois le STATE_HURT achevé.
        ----> pb de bloquage apres saut sous les plateforms avec DYNAMIC.
        -----> OK : correctif dans Urho3D::PhysicsWorld2D::BeginContact() dans le "One Way Wall" en s'assurant que le point de contact et bien positionner sous le centre du collisionshape de l'entité

    ✔ 16/09/2019 : pb sur le Fly en reseau
        --> OK : GameHelpers::SetPhysicProperties() était sollicité en permanence lors du Fly - desactivé.

    ✔ 16/09/2019 : pouvoir choisir le type de pool (ObjectPool ou GO_Pool) dans GOT::Register() permettant d'appliquer la poolqty dans GO_Pools::AddPool()
        -> OK

    ✔ 31/08/2019 : ABILITY_GRAPIN et GOC_PhysicsGrapin en reseau => utiliser le meme principe que ABILITY_SHOOTER
        -> creer un GOPool pour les chainettes et pour le Grapin.
        -> utiliser AddObjetControl(node) et voir pour modifier Ability::Use(Node* node, const ObjectControl& control) qui est utiliser par World2D::NetSpawnEntity()
        --> 13/09/2019 OK : modification d'ObjectControl pour ajouter holderinfo_ + modif Ability, GOC_PhysicsGrapin + Ajout GameNetwork::HandleObjectControlHolderChanged()

    ✔ 03/09/2019 : ping pong infini client->serveur pour la suppression de Lame (GO_Pools) NetSpawné sur le serveur
        -> coté Serveur : GOC_Destroyer::UpdatePositions() envoit un DIE => qui envoit un netmsg ERASENODE.
        -> Le Server reçoit encore des ObjectControls sur ce node qui font encore NetSpawné le node et rebelotte pour le DIE.
        --> le GOC_Destroyer::UpdatePositions() n'est effectif que si le Body est DYNAMIC. Mettre le body en STATIC avant de passer le node en Enabled.
        ---> OK World2D::NetSpawnEntity ajout de body en STATIC
        --> Attention : poosibilité d'avoir le même problème avec les players qui sont en Dynamic sur le serveur

    ✔ 12/09/2019 : l'attaque d'un client ne touche pas sa cible lorsque le serveur et le client ne sont pas sur le meme viewZ
        -> probleme avec le TriggerAttack qui n'est pas déclenché sur le serveur (fonctionne par contre quand sur le meme viewZ)
        --> il s'agit de la desactivation du rendu des AnimatedSprite2D qui ne sont pas visibles
        ---> il faut voir pour permettre l'activation des triggers coté serveur dans tous les cas
        ----> OK : AnimatedSprite2D::UpdateAnimation() patched

    ✔ 03/09/2019 : Ameliorer la synchronisation des clients au lancement du Playstate
        -> pb avec les timestamp : modification de GameNetwork::HandleServer_MessagesFromClient et ajout de CheckReceivedGameStatus : basé sur les gamestatus plus que sur le timestamp
        -> modification de la logique dans GameNetwork::HandleServer_MessagesFromClient et GameNetwork::HandlePlayServer_NetworkUpdate
        -> OK, fonctionne en mode Synchronization des clients et sans synchro (Modifier GameNetwork::needSynchronization_ dans GameNetwork::Reset())

    ✔ 30/08/2019 : les Lames changent de ViewZ automatiquement.
        -> Ajout à l'objet Lame GOC_Destroyer de l'attribut "World Position Update" = false
        --> OK : ne met pas à jour le world position ni le viewZ

    ✔ 30/08/2019 : les dps ne sont pas appliqués pour client->serveur->client
        -> sur le serveur, les body et les trig attack des clients sont en STATIC. Les contact STATICBODY avec STATICBODY ne sont pas permis (cf b2Body::ShouldCollide)
        --> sur le serveur tous les players doivent avoir des BT_DYNAMIC : Ok correctif dans GOC_Controller::ChangeAvatar
        ---> sur le serveur, cela engendre des rebonds des entités
        ----> essai en desactivant les interaction avec GOC_Move2D qui peut appliquer des forces au contacts avec le sol : réactivation de ajout de GOC_Move2D::SetPhysicEnable() mis à false pour les !mainControlled
        -----> toujours des rebonds : le changement de position tres proche du sol fait-il reagir box2d avec une force de repulsion pour eviter la penetration du DYNAMIC dans un element STATIC ?
        ------> OK ! dans GOC_Move2D::HandleWallContactBegin() ajout de body->SetAwake(false) permettant de supprimer les forces, impulsions appliquées sur le body durant le contact.

    ✔ 30/08/2019 : les Parts Exploded des GOC_BodyExploder2D n'ont pas les meme dimensions serveur et clients
        -> pb avec l'Event OBJECTCONTROLIDLECHANGED : les exploded parts sont spawnées via le net avant d'être spawnées via GOC_BodyExploder2D
        --> solution temporaire GameNetwork::HandleObjectControlIdleChanged() skipper les nodes taggés "UsedAsPart"

    ✔ 19/08/2019 : activer les lames et grapin pour le network
        -> cf GO_Pool et Abilities
        --> Strategie d'allocation de nodeid à revoir : les players doivent tous etre simulés sur le serveur.
            -> les GO_Pools sont alloués et liés à chaque joueur et disposent de leur plages spécifiques d'allocation mais nécessite d'etre alloués sur tous les clients.
            --> ainsi il est facile de popper sur un client et d'avoir la correspondance des ids sur le serveur et les autres clients.
            --> il faut s'assurer que les clientid soient bien définis sur tous les clients => ajout de GameNetwork::Server_GetNextClientID() envoi des clientid par remoteevent=NET_GAMESTATUSCHANGED
            --> On limite à 64/128 ou 256 joueurs et on construit les Pools en fonction de ce nombre max de joueurs => GameStatus::MAX_NUMNETPLAYERS
            --> le joueur a acces à ses pools en indiquant son clientid => GO_Pools::GetPool(clientid, got).
            ---> OK
        --> ABI_Shooter OK pour server vers client
            --> ajouter le sendevent à GameNetwork::AddServerObjetControl() sinon l'ObjectControlInfo reste inactif lors des utilisations suivantes du node poppé
            ---> vérifier les états Idle et Active de l'ObjectControlInfo
            ----> OK avec application du nouveau principe décrit section suivante.
        --> ABI_Shooter client vers serveur
            -> modification du net player sur le serveur (ClientInfo::players_) permettant d'utiliser le FIRE2
            --> GOC_Controller::Update(const ObjectControlInfo& info) recuperation du state buttons_ et sendevent GOC_CONTROLACTION2
            --> lors du pop d'une lame, Crash du à la corruption du Vector GameNetwork::serverObjectControls_
            ---> dans GameNetwork::Server_UpdateObjectControls, lors de la boucle sur GameNetwork::serverObjectControls_ l'appel de GOC_Controller::Update() avec le sendevent GOC_CONTROLACTION2 ajoute un element à
                GameNetwork::serverObjectControls_ => OK : modification du for par un while
            --> régler la direction du Spawn
        ---> changement du principe de Spawn : GameNetwork::AddServerObjectControl() devient GameNetwork::AddObjectControl()
            ----> la variable ObjectControl::idle_ sert à communiquer l'état Spawné via le Network.
            ----> lorsqu'un changement d'état de cette variable intervient, Connection::ProcessReceiveServerObjectControl() et Connection::ProcessReceiveClientObjectControl() envoient
                l'Event OBJECTCONTROLIDLECHANGED qui est récupérer par GameNetwork::HandleObjectControlIdleChanged() pour Spawner l'entité ou la détruire.
            ----> OK !
        --> RAF : GRAPIN

    ✔ 13/08/2019 : pb avec les bones PreparedMode de GOC_BodyExploder2D => 2 cas : LOCAL et REPLICATED mode
        -> en LOCAL (creation de nodes LOCAL permise sur le serveur cf. ObjectPool::CreateChildIn() define OBJECTPOOL_LOCALIDSONLY)
            les Bones sont bien spawnés coté serveur, mais pas coté client : les ids locaux serveur n'arrivent pas à être recréer sur le client
        --> il n'y a pas besoin de les recreer. le client doit les faire exploser (ils sont déjà preparés).
        --> il faut assurer une correspondance entre les nodes client et les nodes serveur, les nodesids ne seront presque jamais identiques dans le cas des nodes préparés et surtout avec la gestion en multi-maps
        ---> OK correspondance assurer : modification de ObjectPoolCategory::GetPoolNode().
        -> les bodyexploder n'explosent pas sur les clients car ne recoivent pas le totaldps leur permettant d'envoyer l'event GOC_LIFEDEAD
        --> OK : modification GOC_Controller::PrepareObjectControl()
        --> les positions des parts ne correspondent pas. Les parts ne sont pas ajoutés à GameNetwork::serverObjectControls_.
        ---> OK : création de GameNetwork::AddServerObjetControlSilent() pour éviter d'envoyer les events ADD_NODE (les node sont déjà créer coté clients et serveur)
        -> en REPLICATED, les Bones ne sont pas préparés comme il faut sur le serveur
        --> RAF !

    ✔ 15/08/2019 : pb avec Scene::NodeIDChanged() pour les childs
        -> si les nodes sont marqués temporary, ne pas modifier les ids
        -> les Bullets ont des AnimatedSprite2D qui génére un node "physic" TRIGATTACK.
        --> OK : les nodes physic sont désormais mis en temporaire pour eviter le changement de ids

    ✔ 15/08/2019 : en mode Client pb de boucle sans fin de add/remove sur les Bullets REPLICATED
        -> GOC_Destroyer::Destroy() est lancé par le GOC_Destroyer::HandleUpdateTime()
        --> mettre GOC_Destroyer::SetEnableLifeTimer(false) pour toutes les entités spawnées par GameNetwork::Client_AddServerObject()
        ---> OK : World2D::SpawnEntity(const ObjectControlInfo&) devient World2D::NetSpawnEntity(ObjectControlInfo& info) et intégre GOC_Destroyer::SetEnableLifeTimer(false)

    ✔ 12/08/2019 - probleme entre serveur et clients, les furnitures spawnés n'ont pas le meme charactermapping ou entityid
        --> voir Map::SetFurnitures(), MapGenerator::GenerateBiomeFurnitures()
        ---> OK : modification de MapGenerator::GenerateBiomeFurnitures(), remplacement du Random() par GameRand(OBJRAND)
            et utilisation du tileindex pour le COT::GetRandomTypeFrom()

    ✔ 11/08/2019 - Reprise de Frombones
        -> Les entités Non-Maincontrolled auront un RigidBody2D de type BT_STATIC (Sur Client toutes les entités non controlées par le joueur sont Non-Maincontrolled).
            ca supprime les décrochages du au calcul Physique des BT_DYNAMIC melé aux updates des positions via reseau. Mais il faut modifier GOC_Collider2D concernant les collisions entre entités réseau.
        --> OK : Appliquer dans GOC_Controller::SetMainController() et GOC_Controller::ChangeAvatar()
        -> Modifier GOC_Collider2D pour autoriser les collisions avec les BT_STATIC des autres clients.
        -> au lancement les players sont superposés.
        --> cf GameNetwork::Server_AllocatePlayers(), ClientInfo::CreateAvatarFor() et GameStatus::SetWorldStartPosition()
        --> le positionnement initial des players doit etre imposé par le serveur et non pas par les clients.
        --> OK : modification de PlayState::SetPlayers() en mode ClientMode, recuperer les positions du serveur via GameNetwork::GetClientObjectControl()

    ✔ A solutionner : Purge des Objects inactivés et Reactivation des objects inactivés
        -> Attention : le reseau envoie des ghosts (persistence)
        => DesactiveTimer OK !

    ✔ au restart d'un joueur :
          -> pour les autres clients, ajouter l'effet respawn
          ==> OK

    ✔ Reconcevoir la creation/suppression des objets en mode réseau :
        --> pb avec GOC_Collectable : drop et collect
        --> les nodeid sont attribués par le serveur
        ---> client demande la creation/suppression au serveur qui le réalise
        ==> OK, test en cours

        --> appliquer le meme procedé pour la creation/suppression d'avatar ?
        ==> OK, test en cours

        -> lors du restart, resoudre le respawn du meme avatar, pas de pb coté client
        --> coté serveur, ne pas regénérer un nouvel avatar
        --> appliquer le meme procedé que pour les objectpools
        ==> OK, test à faire


Notes:
    - 27/12/2023 : En World + Reseau, il ne faut pas utiliser ACTIVE_PACKEDOBJECTCONTROL car le manque de précision conduit à une secousse incessantes des entités.

    - 22/11/2023 : si l'on appelle Context::GetEventDataMap() attention car lors de la creation de Node Urho3D va aussi l'appeler écrasant son contenu (cf Node::AddChild)...
        c'est le cas lorsque l'on fait appelle à ObjectPool::CreateChild() par exemple qui est appelé par Map::AddEntity() <= World::SpawnEntity()
        donc si on veut garder le contenu, il faudra utiliser une autre VariantMap. C'est ce qui est fait dans GOC_Collectable::DropSlotFrom() pour slotData qui aurait été effacé dans Map::AddEntity
        lors du ObjectPool::CreateChild() et donc avant d'arriver à la ligne de GameHelpers::SetCollectableProperties() si on avait utilisé une VariantMap du Context.
        (ref : 17/11/2023 : modification inventory)

    - 14/11/2023 : NOTE de reprise du mode réseau
        on distingue les etats qui changent
            -> en permanence : telle que position, animation => utilise ObjectControl : Cela concerne normalement tous les objets dynamiques (pour le moment pas les furnitures ... cela devrait)
            -> ponctuellement : telle que lumieres, inventaires => utilise ObjectCommand
        le choix de ne pas utiliser la replication de scene d'URHO3D est discutable:
            -> on ne veut pas avoir à envoyer la masse de composants via le réseau.
            -> ne pas remodifier Urho3D pour les besoins du jeu avec toute la gestion des erreurs etc...
            -> il faudrait mettre les attributs repliquables pour chaque nouveau composant fait pour le jeu.
        Envoi     : cf GameNetwork::HandlePlayServer_NetworkUpdate, GameNetwork::HandlePlayClient_NetworkUpdate
        Reception : cf GameNetwork::HandlePlayServer_ReceiveUpdate, HandlePlayClient_ReceiveServerUpdate et HandlePlayClient_ReceiveClientUpdate
        Ressources/Docs/network.svg est à mettre à jour.

    - 04/06/2021 : NOTE pour gagner en rapidité, les objets spawnés via GOC_Animator2D::SpawnEntity() n'ont pas tous un ObjectControl
        ObjectControl permet le controle des etats d'une entité (position,animation...) via le serveur.
        par exemple c'est le cas pour les bullets et les boules de feu. Ces objets sont gerés en LOCAL.
        pour cela il suffit de mettre dans Objects.xml l'attribut "replicateMode":0
        le spawn s'effectue sur le serveur et les clients de façon local. L'attribut de shoottarget est completé
        avec ObjectControl::holderinfo_::point1x_,point1y_ via envoi:ABI_AnimShooter::Use() -> reception:GOC_Controller::Update()
